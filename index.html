<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Aoki&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="website">
<meta property="og:title" content="Aoki&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Aoki&#39;s Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Aoki&#39;s Blog">





<link rel="icon" href="/images/gen.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-133326618-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-133326618-2');
</script>


    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/gen.svg" alt="Aoki&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item is-active" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="My GitHub" href="https://github.com/YHCClin?tab=repositories">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/HexoEditor/" class="image is-7by1">
            <img class="thumbnail" src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/icons/HexoEditor.svg?sanitize=true" alt="HexoEditor">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T13:09:02.000Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Course/">Course</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 minutes read (About 353 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/HexoEditor/">HexoEditor</a>
            
        </h1>
        <div class="content">
            <hr>
<blockquote>
<p>HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。<br>GitHub：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HexoEditor</a></p>
</blockquote>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2019/01/27/HexoEditor/#more">Read More</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/arrayandlist/" class="image is-7by1">
            <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549179243&amp;di=d0595deef1085246079f16279e96f2ba&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fsource.aliog.com%2Fwp-content%2Fuploads%2F2015%2F05%2F20150521_555d7178d1052.png" alt="Array Marix GeneralList">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T07:07:54.237Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 minutes read (About 1657 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/arrayandlist/">Array Marix GeneralList</a>
            
        </h1>
        <div class="content">
            <a id="more"></a>
<hr>
<h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><ol>
<li><p>常见的数组有一维数组和二维数组，二维数组是元素可以看成是一维数组的一维数组。对于数组主要考察元素下标计算的问题。对于一维数组较为简单，而对于二维数组的元素位置计算较为复杂，要考虑行优先和列优先两种情况。</p>
</li>
<li><p>二维数组的行优先和列优先存储：</p>
</li>
</ol>
<ul>
<li><p>行优先：从起始行开始一行一行地存入连续空间中<br><img src="blob:https://maxiang.io/6dfe17a8-d9a7-4ff6-9082-4c37be364b74" alt="Alt text"></p>
</li>
<li><p>列优先：从起始列开始一列一列地存入连续空间中<br><img src="blob:https://maxiang.io/b0f51717-5280-41ba-bead-40fa9c4da45d" alt="Alt text"></p>
</li>
</ul>
<hr>
<h4 id="矩阵的压缩存储："><a href="#矩阵的压缩存储：" class="headerlink" title="矩阵的压缩存储："></a>矩阵的压缩存储：</h4><hr>
<h5 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h5><ul>
<li>矩阵一般用一个二维数组A[m][n]表示，表示一个m行n列的矩阵</li>
<li>其中m n 必须为常量，或者为预先定义的宏常量，如下：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> m 5</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 6</span></span><br><span class="line"><span class="hljs-keyword">int</span> A[m][n];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h5 id="矩阵的一般操作与实现"><a href="#矩阵的一般操作与实现" class="headerlink" title="矩阵的一般操作与实现"></a>矩阵的一般操作与实现</h5><ol>
<li><p>矩阵的转置：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[][maxsize],<span class="hljs-keyword">int</span> B[][maxsize],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; ++i)&#123;</span><br><span class="line">		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n ; ++j)&#123;</span><br><span class="line">			B[j][i] = A[i][j]; <span class="hljs-comment">// 矩阵转置操作，元素关于主对角线互换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵相加:</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[][max],<span class="hljs-keyword">int</span> B[][max],<span class="hljs-keyword">int</span> C[][max],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; ++i)&#123;</span><br><span class="line">		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n)&#123;</span><br><span class="line">			c[i][j] = A[i][j] + B[i][j]; <span class="hljs-comment">//对应位置元素相加</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵相乘：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[m][n],<span class="hljs-keyword">int</span> B[n][k],<span class="hljs-keyword">int</span> C[m][k],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;k;++j)&#123;</span><br><span class="line">			C[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;h&lt;n;++h)&#123;</span><br><span class="line">				C[i][j] += A[i][h] * B[h][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="特殊矩阵和稀疏矩阵"><a href="#特殊矩阵和稀疏矩阵" class="headerlink" title="特殊矩阵和稀疏矩阵"></a>特殊矩阵和稀疏矩阵</h4><hr>
<ul>
<li>矩阵中绝大多数元素都是0的矩阵称为稀疏矩阵(国外教材)</li>
<li>相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵(严版)</li>
</ul>
<hr>
<ol>
<li><strong>特殊矩阵</strong>：<br>a) 对称矩阵</li>
</ol>
<ul>
<li>矩阵中的元素满足A[i][j] = A[j][i] 的矩阵称为对称矩阵<br><img src="blob:https://maxiang.io/cc7aea2b-7d51-4bf6-a411-4ef43aa0f5e8" alt="Alt text"></li>
<li>如上图所示，只需要存储一半的元素就可以了，要还原出另一半只需根据A[i][j] = A[j][i]这个条件就行了。</li>
<li>将一个n×n的对称矩阵存储在一维数组中，所需的存储空间为 $ \dfrac{(1+n)*n}{2}$</li>
<li>需要保存的元素为：<br><img src="blob:https://maxiang.io/b6110f0f-2c67-4120-8da0-384cdaa8fdf0" alt="Alt text"></li>
<li>按照行优先来存储，保存在一维数组中，如下图所示：<h2 id=""><a href="#" class="headerlink" title=""></a><img src="blob:https://maxiang.io/b1bf4e3f-7bb7-4721-8cea-3f35088fe4fe" alt="Alt text"></h2>b)三角阵</li>
<li><em>上三角矩阵</em> 为矩阵下三角部分(不包括对角线)元素全为零</li>
<li><em>下三角矩阵</em> 为矩阵上三角部分(不包括对角线)元素全为零</li>
<li>三角矩阵的存储方式与对称矩阵类似，以下三角矩阵的存储为例，只需存储对角线及其以下部分的元素和其上三角中的一个元素C即可，如下图：<br><img src="blob:https://maxiang.io/854aafc6-5bb6-4610-8b84-f5f3c416c561" alt="Alt text"></li>
</ul>
<hr>
<p>c)对角矩阵</p>
<ul>
<li>如下图所示的对角矩阵，其特点为除了主对角线以及其上下两条带状区域的元素外，其余元素都为C ( C可以为0)：<br><img src="blob:https://maxiang.io/03fe9945-aa56-4720-ad0c-7ccdf9369a0a" alt="Alt text"></li>
<li>下面介绍如何求出第i行带状区域内的第一个元素在一维数组中的下标，假设c存在数组的最后一位：</li>
<li>当i=1时，带状区域内的第一个元素为矩阵当中的第一个元素，其在一维数组中的下标为0；</li>
<li><p>当i&gt;1时，第i行之前的元素个数为 $2+(i-2)×3$，则带状区域的第一个元素在一维数组中的下标为 $2+(i-2)×3$<br>2.<strong>稀疏矩阵</strong></p>
</li>
<li><p>稀疏矩阵中的相同元素c不像特殊矩阵中的相同元素的位置分布那么有规律可循，故必须为其设计一些特殊的存储结构</p>
</li>
<li><strong>稀疏矩阵的顺序存储及其相关操作：</strong><br>常用的稀疏矩阵顺序存储方法有三元组表示法，和伪地址表示法。</li>
</ul>
<hr>
<ol>
<li>三元组表示法：<br>三元组数据结构为一个长度为n，表内每个元素都有三个分量的线性表，其三个分量分别为：“值”、“行下标”、“列下标”。<br>元素结构体定义如下：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trimat</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> val; <span class="hljs-comment">// 值</span></span><br><span class="line">	<span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 行下标</span></span><br><span class="line">	<span class="hljs-keyword">int</span> j; <span class="hljs-comment">// 列下标</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>结构体示意图：<br><img src="blob:https://maxiang.io/ae02ef60-6923-4ef1-b205-d4b6a5b7625f" alt="Alt text"><br>结构题数组的定义：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trimat trimat[maxterms + 1]; // maxterms + 1;因为从第 1 行才开始存储元素</span><br></pre></td></tr></table></figure></p>
<p>但是，为了方便起见，一般不用上诉结构体来定义三元组，直接申请一个二维数组就可以了：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> trimat[maxterms + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-comment">// 如要求其他类型，可将int替换掉</span></span><br><span class="line"><span class="hljs-comment">// 需要注意的是，如果矩阵是float型的（或者其他非整型的数据类型）</span></span><br><span class="line"><span class="hljs-comment">// 则此时用一个数组来表示三元组应该写成如下形式：</span></span><br><span class="line"><span class="hljs-keyword">float</span> trimat[maxterms + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-comment">// 这个时候若要取当前非零元素的所在位置应该这么做：</span></span><br><span class="line">	(<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">1</span>];</span><br><span class="line">	(<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-comment">// 就是将float 型的元素造型成int型，这样就可以避免很多不必要的问题的发生</span></span><br></pre></td></tr></table></figure></p>
<p>上诉定义方式中：trimat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值<br>trimat[k][1]、trimat[k][2]表示第k个非零元素在矩阵中的位置。事实上，trimat此时就是一个maxterms 行 3 列的二维数组，我们规定第0行的三个元素分别用来存储原矩阵中的非零元素个数，以及矩阵的行数与列数。<br>示意图如下：<br><img src="blob:https://maxiang.io/851fce65-e98e-44b2-9527-1e07974c6f5b" alt="Alt text"></p>
<hr>
<ul>
<li>给定一个二维数组存储的矩阵，要求设计算法将其转化为三元组存储：</li>
<li><p>算法分析：<br>建立一个三元组的核心问题在于求矩阵的非零元素个数以及非零元素的值，还有其在矩阵（原数组）中的位置，故只需扫描所给矩阵的二维数组即可得到相关数据，进而建立三元组。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 建立三元组时，结点间的次序行按元素在矩阵中的行优先顺序排列</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creattrimat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> A[][max],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">float</span> B[][<span class="hljs-number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="hljs-comment">// m,n 表示所给矩阵的规模为m×n</span></span><br><span class="line">	<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;++j)&#123; <span class="hljs-comment">// 双重循环扫描矩阵</span></span><br><span class="line">			<span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 若矩阵的[i][j] 上的元素不为零，将该元素连同其位置信息存入三元组中</span></span><br><span class="line">				B[k][<span class="hljs-number">0</span>] = A[i][j];</span><br><span class="line">				B[k][<span class="hljs-number">1</span>] = i;</span><br><span class="line">				B[k][<span class="hljs-number">2</span>] = j;</span><br><span class="line">				k++; <span class="hljs-comment">// k 指向三元组的下一个空间</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	B[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = k<span class="hljs-number">-1</span>; <span class="hljs-comment">// 将矩阵的基本信息存入三元组的第0行</span></span><br><span class="line">	B[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = m;</span><br><span class="line">	B[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计算法打印出所给三元组存储的矩阵：</p>
</li>
<li>算法分析：<br>读取三元组的第0行，得到矩阵的相关信息<br>循环按行打印，若下标与三元组中的非零元素下标信息匹配则打印该非零元素，否则，打印0；<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">float</span> trimat[][<span class="hljs-number">3</span>])</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">int</span> m = trimat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];</span><br><span class="line">	<span class="hljs-keyword">int</span> n = trimat[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];</span><br><span class="line">	<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; <span class="hljs-comment">// 非零元素从第一行开始存储</span></span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123; <span class="hljs-comment">// 双重循环打印矩阵</span></span><br><span class="line">		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123; <span class="hljs-comment">// 循环过程中检查第[i][j]下标是否与三元组中的非零元素相同，若相同打印该非零元素，若不同打印 0 ；</span></span><br><span class="line">			<span class="hljs-keyword">if</span>(i = (<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">1</span>] &amp;&amp; j == (<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">2</span>])&#123;</span><br><span class="line">				<span class="hljs-built_in">cout</span> &lt;&lt; trimat[k][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line">				++k; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0 "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ol start="2">
<li>伪地址表示法：<br>伪地址表示法与三元组表示法在本质上并无差别，只不过是三元组表示法的每一行用两个存储单元来存放原矩阵非零元素的位置标记，而伪地址表示法可以只用一个存储单元来存放位置标记，原因是因为对于一个$ m×n $的矩阵，伪地址表示法将元素位置下标的两个整数用一个公式映射( $ n×(i-1) +j $)到了一个整数上，同样利用该公式也可还原原i和j的值。<br>我们来看一个例子：<br><img src="blob:https://maxiang.io/e32e77b6-4192-456e-a6da-59730d73919d" alt="Alt text"></li>
</ol>
<hr>
<ul>
<li><strong>稀疏矩阵的链式存储及相关操作：</strong></li>
</ul>
<hr>
<ol>
<li>邻接表表示法：<br>邻接表表示法将矩阵中每一行的非零元素串联成一个单链表，链表结点中有三个分量：元素值、所在列、指针域<br>结点的定义如下：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listmat</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> data;</span><br><span class="line">	<span class="hljs-keyword">int</span> col;</span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listmat</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示意图如下：<br><img src="blob:https://maxiang.io/6629f2e7-af7d-4a8a-a7ee-79c06744638a" alt="Alt text"><br>上图中最左端为一个指针数组，用来存储指向每一行非零元素单链表的头指针，数组下标为表示行标号。</p>
<ol start="2">
<li>十字链表表示法：<br>在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点有 5 个分量：行分量、列分量、数据域、指向下方结点的指针域、指向右方结点的指针域；结构图如下：<br><img src="blob:https://maxiang.io/f890bb79-2bc4-4043-a097-65e2b5bf5e45" alt="Alt text"><br>普通结点定义：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> row;</span><br><span class="line">	<span class="hljs-keyword">int</span> col;</span><br><span class="line">	<span class="hljs-keyword">int</span> data;</span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">down</span>;</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>头结点定义:<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CrossList</span>&#123;</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">rhead</span>,*<span class="hljs-title">cheard</span>;</span> <span class="hljs-comment">// 指向两头结点数组的指针</span></span><br><span class="line">	<span class="hljs-keyword">int</span> m,n,k; <span class="hljs-comment">// 矩阵行数、列数、非零结点总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于十字链表存储结构比较复杂，我们将通过其结构图例来深入了解它，图中附有详细的注释：</p>
<p><img src="blob:https://maxiang.io/0d5bfaa7-1eda-43fd-900c-a8d61081d6bf" alt="Alt text"><br>上图中，银灰色的结点为行头结点数组与列头结点数组，他们的定义如下：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 其中的m n 为矩阵的行数和列数</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rhead</span>&#123;</span> <span class="hljs-comment">// 行头结点数组</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> <span class="hljs-title">Rhead</span>[<span class="hljs-title">m</span>];</span>  <span class="hljs-comment">// 元素为matNode结点的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chead</span>&#123;</span> <span class="hljs-comment">// 列头结点数组</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> <span class="hljs-title">Chead</span>[<span class="hljs-title">n</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>在理解了十字链表存储结构后，我们来看一个实际的应用：<br>给定一个float型二维数组存储的稀疏矩阵，建立其对应的十字链表结构。<br><strong>算法分析</strong>：<br>首先应该建立整体框架，也就是十字链表头结点以及行、列头结点数组。然后，按行优先顺序遍历矩阵数组，若发现不为零的元素，分配一个结点空间将其值存入，调整行、列头结点的指针域指向该结点，如此直到结束遍历<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">creatCrossListmat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> A[][maxsize],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k,CrossList &amp;M)</span></span>&#123;</span><br><span class="line">	<span class="hljs-comment">//============================================</span></span><br><span class="line">	<span class="hljs-comment">// 搭建基本框架操作</span></span><br><span class="line">	<span class="hljs-comment">//============================================</span></span><br><span class="line">	<span class="hljs-comment">// 清空处理：</span></span><br><span class="line">	<span class="hljs-keyword">if</span> (M.rhead) <span class="hljs-built_in">free</span>(M.rhead);</span><br><span class="line">	<span class="hljs-keyword">if</span> (M.chead) <span class="hljs-built_in">free</span>(M.chead);</span><br><span class="line">	<span class="hljs-comment">// 将矩阵信息存入十字链表头结点：</span></span><br><span class="line">	M.m = m;</span><br><span class="line">	M.n = n;</span><br><span class="line">	M.k = k;</span><br><span class="line">	<span class="hljs-comment">// 申请行、列头结点数组空间：</span></span><br><span class="line">	<span class="hljs-keyword">if</span> (!(M.rhead = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode)*m)))</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">	<span class="hljs-keyword">if</span> (!(M.chead = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode)*n)))</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">	<span class="hljs-comment">// 将行、列头结点数组的right和down指针置空：</span></span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m ; ++i)&#123;</span><br><span class="line">		M.rhead[i].right = <span class="hljs-literal">NULL</span>;</span><br><span class="line">		M.rhead[i].down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n ;++i)&#123;</span><br><span class="line">		M.chead[i].right = <span class="hljs-literal">NULL</span>;</span><br><span class="line">		M.chead[i].down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-comment">//===================================================</span></span><br><span class="line">	<span class="hljs-comment">// 核心算法</span></span><br><span class="line">	<span class="hljs-comment">//===================================================</span></span><br><span class="line">	<span class="hljs-comment">// 建立链表的辅助指向列头结点的指针数组：</span></span><br><span class="line">	matNode *temp_r[maxsize];</span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		temp_r[i] = &amp;(M.chead[i]); <span class="hljs-comment">// 引用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-comment">// 行优先顺序遍历矩阵数组构建十字链表：</span></span><br><span class="line">	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m ;++i)&#123;</span><br><span class="line">		matNode *c = &amp;(M.rhead[i]);</span><br><span class="line">		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">			<span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>)&#123;</span><br><span class="line">				matNode *p = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode));</span><br><span class="line">				p -&gt; row = i;</span><br><span class="line">				p -&gt; col = j;</span><br><span class="line">				p -&gt; val = A[i][j];</span><br><span class="line">				p -&gt; down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">				p -&gt; right = <span class="hljs-literal">NULL</span>;</span><br><span class="line">				<span class="hljs-comment">// 如果某行（列）中已经连接了元素，那么就让这个元素充当该行（列）的头部，这样能使十字链表的行（列）头结点数组中的结点避免重复指向，覆盖；所以下面的代码所要做的事情很重要。</span></span><br><span class="line">				c -&gt; right = p; </span><br><span class="line">				c = p;</span><br><span class="line">				temp_r[j] -&gt; down = p;</span><br><span class="line">				temp_r[j] = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul>
<li>表元素可以是原子类型的元素，也可以是广义表的一种线性表</li>
</ul>
<hr>
<h5 id="三个重要概念："><a href="#三个重要概念：" class="headerlink" title="三个重要概念："></a>三个重要概念：</h5><ul>
<li><strong>广义表的长度</strong>：表中最上层元素的个数</li>
<li><strong>广义表的深度</strong>：表中括号的最大层数，求解时应将所有的子表展开在分析</li>
<li><strong>表头(Head)和表尾(Tail)</strong>：当表非空时，第一个元素为广义表的表头，其余元素组成广义表的表尾<h5 id="两种存储结构："><a href="#两种存储结构：" class="headerlink" title="两种存储结构："></a>两种存储结构：</h5></li>
<li><strong>头尾链表存储结构</strong>：<br>这种存储结构有两种结点，即原子结点和广义表结点。原子结点有两个域：标记域、数据域。广义表结点有三个域：标记域、头指针域、尾指针域<br>其中头指针指向一个原子结点或广义表结点，尾指针为空或者指向 <strong>本层中</strong> 的下一个广义表结点，而标记域用来区分广义表结点(1)与原子结点(0);<br><strong>示意图入下：</strong><br><img src="blob:https://maxiang.io/2c7b821a-b29a-46fa-928d-d2a5245d41e4" alt="Alt text"></li>
<li><strong>扩展线性表结构</strong>：<br>该种存储结构同样有两种结点，与头尾链表存储结构不同的是这里的原子结点有三个域：标记域、数据域、尾指针域。<br><strong>示意图如下：</strong><br><img src="blob:https://maxiang.io/37609f61-c449-4de6-a486-ff879009b310" alt="Alt text"></li>
</ul>
<hr>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/QueueStack/" class="image is-7by1">
            <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548581470072&amp;di=ee7f02ae4ffa2ccc6257101f77c6b5d9&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170627%2Fa3e6109615584b62a5eb86fe79243270_th.jpg" alt="Queue and Stack">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T06:30:48.907Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 minutes read (About 2391 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/QueueStack/">Queue and Stack</a>
            
        </h1>
        <div class="content">
            <a id="more"></a>    
<hr>
<h3 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h3><hr>
<h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><ol>
<li><em>栈的定义</em></li>
</ol>
<ul>
<li>只能在一端（栈顶Top）进行插入和删除操作的线性表</li>
<li>栈顶由一个称为栈顶指针的位置指示器top来指示，它是动态变化的</li>
<li>表的另一端栈底是固定不变的</li>
</ul>
<ol>
<li><em>栈的特点</em></li>
</ol>
<ul>
<li>先进先出（ＦＩＬＯ）</li>
<li>栈就如同一个狭窄的死胡同，最先进去的人（元素）只能够最后出来</li>
</ul>
<ol start="3">
<li><em>栈的存储结构</em></li>
</ol>
<ul>
<li>可以用顺序表或者链表来存储栈：<br>  a) 顺序栈<br>  b) 链式栈</li>
</ul>
<ol start="4">
<li><em>栈的数学性质</em></li>
</ol>
<ul>
<li>当ｎ个元素以某种顺序进栈，并且可以在任何时候出栈（在满足先进后出的前提下）时，所获得的元素排列的数目Ｎ恰好满足函数 Catalan() 的计算，即：<pre><code>$$N = {\dfrac{1}{n+1}}×C\binom{n}{2n}$$ 
</code></pre></li>
</ul>
<hr>
<h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><hr>
<ol>
<li><em>队列的定义</em></li>
</ol>
<ul>
<li>是一种操作受限的线性表，且只允许在表的一端进行插入，在另一端进行删除操作。</li>
<li>可以插入的一端称为队尾（ｒｅａｒ），可以删除的一端称为队头（ｆｒｏｎｔ）</li>
<li>插入元素称为进队，删除元素称为出队</li>
</ul>
<ol start="2">
<li><em>队列的特点</em></li>
</ol>
<ul>
<li>先进先出（ＦＩＦＯ），就像食堂打饭要排队一样，先来的人先有饭吃</li>
</ul>
<ol start="3">
<li><em>队列的存储结构</em></li>
</ol>
<ul>
<li>可用线性表或者链表来存储队列：<br>  a) 顺序队<br>  b) 链队</li>
</ul>
<hr>
<h3 id="栈和队列的存储结构、算法与应用"><a href="#栈和队列的存储结构、算法与应用" class="headerlink" title="栈和队列的存储结构、算法与应用"></a>栈和队列的存储结构、算法与应用</h3><hr>
<ol>
<li><p><strong>顺序栈的定义</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data[Maxsize]; <span class="hljs-comment">//一维数组用来存储数据</span></span><br><span class="line">  <span class="hljs-keyword">int</span> top;　<span class="hljs-comment">// ｔｏｐ指针用来指向栈顶元素,规定top=-1　为栈空，top=Maxsize-1 为栈满</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链栈结点的定义</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">// 数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">// 指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>顺序队列的定义</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqQueue</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data[Maxsize]; <span class="hljs-comment">//数组存放数据</span></span><br><span class="line">  <span class="hljs-keyword">int</span> front;　　<span class="hljs-comment">// 队首指针</span></span><br><span class="line">  <span class="hljs-keyword">int</span> rear;　　<span class="hljs-comment">// 队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链队的定义</strong><br>a) 链队结点定义：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span>&#123;</span></span><br><span class="line">      <span class="hljs-keyword">int</span> date; <span class="hljs-comment">//数据域</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指针域</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>b) 链队类型定义：   </p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 定义一个只包含两个指针域的结点来存放队头与队尾指针</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LiQueue</span>&#123;</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">front</span>;</span> <span class="hljs-comment">// 队首指针</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">rear</span>;</span>  <span class="hljs-comment">//　队尾指针</span></span><br><span class="line">    &#125;　<span class="hljs-comment">// 链队类型定义</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><hr>
<h5 id="顺序栈的几个关键要素："><a href="#顺序栈的几个关键要素：" class="headerlink" title="顺序栈的几个关键要素："></a>顺序栈的几个关键要素：</h5><ol>
<li><strong>三个状态</strong><ul>
<li>栈空状态：<strong>st.top = -1</strong>;</li>
<li>栈满状态：<strong>st.top = Maxsize - 1</strong>;</li>
<li>非法状态：栈满却继续入栈发生<strong>上溢</strong>；栈空继续出栈发生<strong>下溢</strong>；</li>
</ul>
</li>
<li><strong>两个操作</strong><ul>
<li>元素进栈：++(st.top); st.data[st.top]=x;</li>
<li>元素出栈：x=st.data[st.top]; –(st.top);</li>
</ul>
</li>
</ol>
<hr>
<h5 id="初始化栈："><a href="#初始化栈：" class="headerlink" title="初始化栈："></a>初始化栈：</h5><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 初始化一个栈，只需将栈顶指针置为－１即可</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断栈空代码："><a href="#判断栈空代码：" class="headerlink" title="判断栈空代码："></a>判断栈空代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EmptyStack</span><span class="hljs-params">(SqStack ss)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>)</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 栈空返回１；</span></span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">// 栈非空返回０；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="进栈代码："><a href="#进栈代码：" class="headerlink" title="进栈代码："></a>进栈代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#defined Error 0</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(SqStack &amp;ss, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error; <span class="hljs-comment">// 栈满时返回错误，无法入栈</span></span><br><span class="line">  ss.top++;</span><br><span class="line">  ss.data[ss.top] = x;</span><br><span class="line">  <span class="hljs-comment">// 也可一句话解决：　ss.data[++ss.top] = x;</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;　<span class="hljs-comment">//入栈成功返回１</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="出栈代码："><a href="#出栈代码：" class="headerlink" title="出栈代码："></a>出栈代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(SqStack &amp;ss,<span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error; <span class="hljs-comment">// 栈空不能出栈</span></span><br><span class="line">  e = ss.data[ss.top];</span><br><span class="line">  --ss.top;</span><br><span class="line">  <span class="hljs-comment">//　也可一句话解决：　e = ss.data[ss.top--];</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注】:<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于自增操作，入++a;总是比a++;的执行效率要高一些，因此在使用二者都可以的情况下优先选择++a;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><hr>
<h6 id="以下链栈都由带头结点的链表表示"><a href="#以下链栈都由带头结点的链表表示" class="headerlink" title="以下链栈都由带头结点的链表表示"></a>以下链栈都由带头结点的链表表示</h6><hr>
<h5 id="顺序栈的几个关键要素：-1"><a href="#顺序栈的几个关键要素：-1" class="headerlink" title="顺序栈的几个关键要素："></a>顺序栈的几个关键要素：</h5><ol>
<li>两个状态<ul>
<li>栈空状态：lst –&gt; next = NULL;</li>
<li>栈满状态：不存在栈满状态，因为单链表的内存空间是动态分配的</li>
</ul>
</li>
<li>两个操作<ul>
<li>元素（由指针ｐ所指）的进栈操作：p -&gt; next = lst -&gt; next; lst -&gt; next = p;//其实     就是头插法建立单链表的操作</li>
<li>出栈操作：s = lst -&gt; next; x = s -&gt; data; lst -&gt; next = s -&gt; next;           free(s); //其实就是单链表的删除操作</li>
</ul>
</li>
</ol>
<hr>
<h4 id="链栈的初始化代码："><a href="#链栈的初始化代码：" class="headerlink" title="链栈的初始化代码："></a>链栈的初始化代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 实际上，链栈的初始化与单链表的初始化并无不同</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initLStack</span><span class="hljs-params">(LNode *&amp;lst)</span></span>&#123;</span><br><span class="line">  lst = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode)); <span class="hljs-comment">//制造一个头结点</span></span><br><span class="line">  lst -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">// 将链栈滞空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断栈空代码：-1"><a href="#判断栈空代码：-1" class="headerlink" title="判断栈空代码："></a>判断栈空代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LNode lst)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (lst -&gt; next == <span class="hljs-literal">NULL</span>) </span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//栈空返回１；</span></span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">// 栈不空返回０；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进栈代码：-1"><a href="#进栈代码：-1" class="headerlink" title="进栈代码："></a>进栈代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(LNode &amp;lst,<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  LNode s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">  s -&gt; data = x;</span><br><span class="line">  s -&gt; next = lst -&gt; next;</span><br><span class="line">  lst -&gt; next = s;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈代码：-1"><a href="#出栈代码：-1" class="headerlink" title="出栈代码："></a>出栈代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(LNode &amp;lst, <span class="hljs-keyword">int</span> &amp;e)</span></span>&#123; <span class="hljs-comment">// 用e返回出栈元素的值</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (lst -&gt; next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  e = lst -&gt; next -&gt; data;</span><br><span class="line">  LNode *s = lst -&gt; next;</span><br><span class="line">  lst -&gt; next = s -&gt; next;</span><br><span class="line">  <span class="hljs-built_in">free</span>(s);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><hr>
<h6 id="栈的主要应用有："><a href="#栈的主要应用有：" class="headerlink" title="栈的主要应用有："></a>栈的主要应用有：</h6><ol>
<li>括号匹配</li>
<li>表达式求值</li>
<li>逆波兰转换算法</li>
</ol>
<hr>
<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><hr>
<h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><ul>
<li>扫描整个表达式，判断当前符号是否为括号</li>
<li>如果不是，继续扫描下一个字符</li>
<li>如果是，判断是左括号还是右括号，是左括号将其入栈，是右括号就判断栈是否为空</li>
<li>若栈为空，说明此表达式的右括号多与左夸号</li>
<li>若栈不空则判断当前操作符是否和栈顶操作符匹配，若不匹配说明左右括号不匹配，若匹配则继续判断     下一个操作符。最后，判断栈是否为空，若不空则说明左括号多余右括     号，栈为空说明匹配成功。</li>
</ul>
<hr>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">initStack(Stack <span class="hljs-built_in">stack</span>)&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i ;i&lt;<span class="hljs-built_in">strlen</span>(str);i++)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'&#123;'</span> || str[i]==<span class="hljs-string">'['</span> || str[i]==<span class="hljs-string">'('</span>)&#123;</span><br><span class="line">      push(<span class="hljs-built_in">stack</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'&#123;'</span> &amp;&amp; getTopStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">'&#125;'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'['</span> &amp;&amp; getToPStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">']'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'('</span> &amp;&amp; getTopStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">')'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 最后，若栈空则匹配成功，否则失败</span></span><br><span class="line">  <span class="hljs-keyword">if</span>(isEmpty() == <span class="hljs-literal">true</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"括号匹配成功　！！！"</span>　&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"匹配失败　！！！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><hr>
<h5 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h5><ul>
<li>扫描表达式，当扫描到数时将其推入栈中，当扫描到一个运算符时，将该运算符作用于位于栈顶的两个数上，并将所得结果推入栈中</li>
<li>以下将给出后缀表达式的求值程序</li>
</ul>
<hr>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calcExp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-built_in">exp</span> , Stack s)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span>[i] != <span class="hljs-string">'\0'</span>)&#123; <span class="hljs-comment">//</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; <span class="hljs-built_in">exp</span>[i]&lt;=<span class="hljs-string">'9'</span>)&#123;</span><br><span class="line">        s.push(s , <span class="hljs-built_in">exp</span>[i]-<span class="hljs-string">'0'</span>); <span class="hljs-comment">//　若为数字，推入栈中</span></span><br><span class="line">      &#125;</span><br><span class="line">      else if(exp[i] == '运算符')&#123;</span><br><span class="line">          <span class="hljs-keyword">int</span> m = s.gettop(); <span class="hljs-comment">//　取栈顶元素后将其出栈</span></span><br><span class="line">          s.pop();</span><br><span class="line">          <span class="hljs-keyword">int</span> n = s.gettop(); <span class="hljs-comment">//　取栈顶元素后将其出栈</span></span><br><span class="line">          s.pop;</span><br><span class="line">          s.push(s, n[运算符]m); <span class="hljs-comment">//　将运算结果推入栈中</span></span><br><span class="line">      &#125; </span><br><span class="line">      i++; <span class="hljs-comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> s.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="逆波兰转换算法"><a href="#逆波兰转换算法" class="headerlink" title="逆波兰转换算法"></a>逆波兰转换算法</h4><hr>
<h5 id="算法思想：-2"><a href="#算法思想：-2" class="headerlink" title="算法思想："></a>算法思想：</h5><ul>
<li>设立一个栈，存放运算符，初始栈为空，编译程序从左往右扫描中缀表达式，若遇到数字，直接输出，并输出一个空格为两个操作数之间的分隔符；</li>
<li>若遇到运算符，则与栈顶比较，若运算符级别比栈顶级别高则进栈，否则退出栈顶元素并输出，之后输出一个空额作分隔符</li>
<li>所遇到左括号，紧张；</li>
<li>若遇到右括号，则一直退栈粗出知道退出第一个左括号为止</li>
<li>当栈为空时，输出的结果即为<strong>后缀表达式</strong></li>
</ul>
<hr>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tranfExp</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-built_in">exp</span> , Stack s)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span>[i] != <span class="hljs-string">'\0'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; <span class="hljs-built_in">exp</span>[i] &lt;= <span class="hljs-string">'9'</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为数字，直接输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] == <span class="hljs-string">'('</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为左括号，进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] == <span class="hljs-string">')'</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为右括号，出栈直至第一个左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">        else if (exp[i] == '运算符')&#123;</span><br><span class="line">            <span class="hljs-comment">//　判断与栈顶元素的优先级大小</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] &gt; s.gettop())</span><br><span class="line">                s.push(<span class="hljs-built_in">exp</span>[i]);  <span class="hljs-comment">// 优先级大于栈顶运算符，将该运算符进栈</span></span><br><span class="line">            <span class="hljs-keyword">else</span>  <span class="hljs-comment">//　优先级小于栈顶运算符，退出栈顶元素并且输出</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (s.isEmpty() == <span class="hljs-literal">false</span>)</span><br><span class="line">        pop();<span class="hljs-comment">//　把栈中剩余元素全部退出并输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="顺序队"><a href="#顺序队" class="headerlink" title="顺序队"></a>顺序队</h3><hr>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><hr>
<h5 id="循环队列的基本要素"><a href="#循环队列的基本要素" class="headerlink" title="循环队列的基本要素"></a>循环队列的基本要素</h5><ol>
<li>两个状态：<ul>
<li>队空状态：qu.rear = qu.front;</li>
<li>队满状态：(qu.rear+1)%front == qu.front ;</li>
</ul>
</li>
<li>两个操作：<ul>
<li>元素x进队操作：qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x;</li>
<li>出队操作：qu.front = (qu.front+1)%MaxSize; elem = qu.data[qu.front];//elem 保     存出队的元素</li>
</ul>
</li>
</ol>
<hr>
<h4 id="循环队列的基本操作实现"><a href="#循环队列的基本操作实现" class="headerlink" title="循环队列的基本操作实现"></a>循环队列的基本操作实现</h4><ol>
<li><p>初始化队列算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(Queue &amp;qu)</span></span>&#123;</span><br><span class="line">  qu.front = <span class="hljs-number">0</span>; </span><br><span class="line">  qu.rear = <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断队空算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isQEmpty</span><span class="hljs-params">(Queue qu)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (qu.front == qu.rear)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进队算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enterQueue</span><span class="hljs-params">(Queue &amp;qu , <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> ((qu.rear+<span class="hljs-number">1</span>)%MaxSize == front)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队列已满"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qu.rear = (qu.rear+<span class="hljs-number">1</span>)%MaxSize;</span><br><span class="line">  qu.data[qu.rear] = x;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">outQueue</span><span class="hljs-params">(Queue &amp;qu , <span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (qu.rear == qu.front)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队空无法出队"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qu.front = (qu.front+<span class="hljs-number">1</span>)%MaxSize;</span><br><span class="line">  e = qu.data[qu.front];</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<hr>
<h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><h6 id="采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限"><a href="#采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限" class="headerlink" title="采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限"></a>采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限</h6><hr>
<h5 id="链队的基本要素"><a href="#链队的基本要素" class="headerlink" title="链队的基本要素"></a>链队的基本要素</h5><ol>
<li>两个状态：<ul>
<li>队满状态： 不存在队满状态</li>
<li>队空状态：que.rear = NULL || que.front = NULL (两个满足一个即可)</li>
</ul>
</li>
<li>两个操作：<ul>
<li>元素q进队操作：　分两种情况<pre><code>1. 当前队为空：que --&gt; rear = que --&gt; front = q;
2. 当前队不空：que --&gt; rear --&gt; next = p;que --&gt; rear = p;
</code></pre></li>
<li>元素出队操作： s = que –&gt; front;  que –&gt; front = s –&gt; next;elem = s –&gt;                      data; free(s);</li>
</ul>
</li>
</ol>
<hr>
<h4 id="链队的基本操作实现"><a href="#链队的基本操作实现" class="headerlink" title="链队的基本操作实现"></a>链队的基本操作实现</h4><p>1.初始化链队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initLiQueue</span><span class="hljs-params">(LiQueue *&amp;que)</span></span>&#123;</span><br><span class="line">    que = (LiQueue*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LiQueue));</span><br><span class="line">    que -&gt; rear = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    que -&gt; front = <span class="hljs-literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.判断队空算法：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LiQueue que)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (que.rear = <span class="hljs-literal">NULL</span> || que.front = <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队列为空"</span>　&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.入队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enterLiQueue</span><span class="hljs-params">(LiQueue &amp;que ， <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LQNode* s = (LQNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LQNode));</span><br><span class="line">    <span class="hljs-keyword">if</span> (isEmpty(que))&#123;  <span class="hljs-comment">// 若队列为空，进队操作比较特别</span></span><br><span class="line">        que -&gt; front = que -&gt; rear = s;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        que -&gt; rear -&gt; next = s;</span><br><span class="line">        que -&gt; rear = s;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.出队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">outLiQueue</span><span class="hljs-params">(LiQueue &amp;que , <span class="hljs-keyword">int</span> &amp;elem)</span></span>&#123;</span><br><span class="line">    LQNode* s = que -&gt; front;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队为空，无法出队"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (que -&gt; front == que -&gt; rear)&#123; <span class="hljs-comment">// 若队列只有一个元素，出队操作比较特别</span></span><br><span class="line">        que -&gt; front = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        que -&gt; rear = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    que -&gt; front = s -&gt; next;</span><br><span class="line">    elem = s -&gt; data;</span><br><span class="line">    <span class="hljs-built_in">free</span>(s);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/String/" class="image is-7by1">
            <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580675099&amp;di=6efdd9be8a2394de553173ab69c0bb70&amp;imgtype=0&amp;src=http%3A%2F%2Fs1.knowsky.com%2F20170206%2Fp3rqnw1kmbl32.png" alt="String">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T06:27:40.068Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3435 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/String/">String</a>
            
        </h1>
        <div class="content">
            <a id="more"></a>
<h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 通常用一个字符数组来表示</span></span><br><span class="line"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">"hello"</span>;</span><br><span class="line"><span class="hljs-comment">// 数组str内存储的字符为&#123;'h','e','l','l','o','\0'&#125; ,故有6个数组元素，其中'\0'是串的结束标志，告知编译器串结束了。</span></span><br><span class="line"><span class="hljs-comment">// 但是串str的长度为5，“hello”，</span></span><br></pre></td></tr></table></figure>
<ul>
<li>【注】以上定义方式一般不用，因为用该方式单纯以 ‘\0’ 结尾的串如果要得到字符串的长度较为麻烦（需要遍历整个串，时间复杂度为O(n)，故一般情况下我们用自己定义的结构体来定义串，下面会谈到。</li>
</ul>
<hr>
<ul>
<li>【注】空格也是串中的元素，由一个或多个空格组成的串称为空格串，空格串不是“空串”。</li>
</ul>
<hr>
<ul>
<li>串的逻辑结构与线性表类似，串是限定了元素为字符的线性表。但从操作对象上来说，串与线性表有着很大的不同：线性表的主要操作对象是单个元素，而串的主要操作对象是该串的一个“<strong>子串</strong>”。</li>
</ul>
<hr>
<h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4><hr>
<p><strong>1. 定长顺序存储表示：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Str</span>&#123;</span></span><br><span class="line">  <span class="hljs-keyword">char</span> str[maxsize+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 用来存放字串的字符数组，maxsize 为字符串最大长度，maxsize+1为数组最大长度，+1 用于存储 '\0'.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> length; <span class="hljs-comment">// 字符串长度，可用Str.length方法直接访问 length &lt;= maxsize;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 动态分配存储表示：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LStr</span>&#123;</span></span><br><span class="line">  <span class="hljs-keyword">char</span> *ch; <span class="hljs-comment">// 指向malloc();动态分配存储区的首地址的指针</span></span><br><span class="line">  <span class="hljs-keyword">int</span> length; <span class="hljs-comment">// 字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h4><hr>
<p><strong>1. 赋值操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strassign</span><span class="hljs-params">(LStr&amp; str,<span class="hljs-keyword">char</span>* ch)</span></span>&#123; <span class="hljs-comment">// 需返回的变量带引用符号&amp;</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (str.ch)&#123;</span><br><span class="line">    <span class="hljs-built_in">free</span>(str.ch); <span class="hljs-comment">// 释放原有空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">char</span> *c = ch;</span><br><span class="line">  <span class="hljs-keyword">while</span>(c)&#123; <span class="hljs-comment">// 计算ch的长度</span></span><br><span class="line">    ++len;</span><br><span class="line">    ++c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> )&#123;</span><br><span class="line">    str.ch = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 如果ch为空，则直接返回一个空的串</span></span><br><span class="line">    str.len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    str.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(str.len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 用malloc函数分配一块连续的存储空间，str.len+1是为了容纳'\0'</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (str.ch == <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//分配失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      c = ch;</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len;i++)&#123; <span class="hljs-comment">//遍历并赋值</span></span><br><span class="line">        str.ch[i] = *c; <span class="hljs-comment">// *c 表示c指针所指的位置的值</span></span><br><span class="line">        ++c; <span class="hljs-comment">// c指针指向下一个位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      str.len = len; <span class="hljs-comment">// 被赋值的串长度等于ch的串长</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// successfully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 取串长度操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StrLength</span><span class="hljs-params">(LStr str)</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 有给串长度信息的情况：</span></span><br><span class="line">    <span class="hljs-keyword">return</span> str.len; <span class="hljs-comment">// 返回str串的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//在没有给出串长度信息的情况下：</span></span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">char</span> = *c;</span><br><span class="line">    c = str.ch;</span><br><span class="line">    <span class="hljs-keyword">while</span>(c)&#123;</span><br><span class="line">      ++len;</span><br><span class="line">      ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>串的比较操作</strong>：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strCompare</span><span class="hljs-params">(LStr str1,LStr str2)</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">//啰嗦版:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str1.len &amp;&amp; i &lt; str2.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(str1.ch[i] - str2.ch[i] == <span class="hljs-number">0</span>) i++;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str1.ch[i] - str2.ch[i] &gt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &gt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &lt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str1.len - str2.len &gt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &gt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str1.len - str2.len &lt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &lt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 = str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-comment">// 简洁版：</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.len &amp;&amp; i &lt; str2.len ;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str1.ch[i] != str2.ch[i])&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> str1.ch[i] - str2.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> str1.len - str2.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>4. 串的连接操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concat</span><span class="hljs-params">(LStr &amp;str,LStr str1,LStr str2)</span></span>&#123;  <span class="hljs-comment">// 将两个字符串连接并用一个新的字符串str返回</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(str.ch) &#123; <span class="hljs-comment">// 清除原有空间</span></span><br><span class="line">      <span class="hljs-built_in">free</span>(str.ch);</span><br><span class="line">      str.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      str.len = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(str1.len+str2.len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 分配连续空间，+1是为了多分配一个位置空间存放‘\0’</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(i &lt; str1.len)&#123; <span class="hljs-comment">// 插入str1;</span></span><br><span class="line">      str.ch[i] = str1.ch[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(j &lt;= str2.len)&#123; <span class="hljs-comment">// 插入str2，注意这里用"&lt;="是为了吧'\0' 也加到末尾</span></span><br><span class="line">      str.ch[i+j] = str2.ch[j];</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    str.len = str1.len + str2.len; <span class="hljs-comment">// 更新字符串长度</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 成功连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 求子串操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subStr</span><span class="hljs-params">(LStr &amp;substr,LStr str,<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pos + len &gt; str.len || pos &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || pos &gt;= str.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//判断输入是否合法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (substr.ch)&#123; <span class="hljs-comment">// 清空原空间</span></span><br><span class="line">      <span class="hljs-built_in">free</span>(substr.ch);</span><br><span class="line">      substr.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 若子串长度为0.直接返回空子串</span></span><br><span class="line">      substr.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      substr.len = <span class="hljs-number">0</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">    substr.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 分配连续的内存空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = pos;</span><br><span class="line">    <span class="hljs-keyword">while</span>(i&lt;len)&#123; <span class="hljs-comment">// 从pos处开始遍历并赋值给子串</span></span><br><span class="line">        substr.ch[i] = str.ch[j];</span><br><span class="line">        ++i;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    substr.ch[i] = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 这个千万别忘了加进去</span></span><br><span class="line">    substr.len = len; <span class="hljs-comment">// 更新子串长度</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>串的清空操作：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 串的清空操作在上诉各函数中均有用到</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clearStr</span><span class="hljs-params">(LStr &amp;str)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (str.ch)&#123;</span><br><span class="line">      <span class="hljs-built_in">free</span>(str.ch);</span><br><span class="line">      str.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str.len = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="串的模式匹配算法-重点"><a href="#串的模式匹配算法-重点" class="headerlink" title="串的模式匹配算法(重点)"></a>串的模式匹配算法(重点)</h4><h6 id="何为模式匹配："><a href="#何为模式匹配：" class="headerlink" title="何为模式匹配："></a>何为模式匹配：</h6><ul>
<li>对一个串中某子串的定位操作称为串的模式匹配，其中待匹配的子串称为“模式串”。<h6 id="串的模式匹配算法分为："><a href="#串的模式匹配算法分为：" class="headerlink" title="串的模式匹配算法分为："></a>串的模式匹配算法分为：</h6></li>
</ul>
<ol>
<li>简单模式匹配算法</li>
<li>KMP算法</li>
</ol>
<hr>
<p><strong>1. 简单模式匹配算法：</strong></p>
<ul>
<li><em>算法思想</em>：</li>
<li>从主串的第一个位置起开始遍历字符串，若该字符与模式串的第一个字符相同，则继逐一比较后续字符，   否则从主串的下一个位置开始，重复上一步操作，以此类推，直到比较完模式串的所有字符。若匹配成     功，返回模式串在主串中的位置。匹配失败 ……,随便你想咋样。<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subStr_Match</span><span class="hljs-params">(Lstr str,LStr substr)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (substr.ch == <span class="hljs-literal">NULL</span> || str.ch == <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">int</span> i ,j , pos = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> , j = <span class="hljs-number">0</span>;i &lt; str.len &amp;&amp; i &lt; substr.len; )&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str.ch[i] == substr.ch[j])&#123;</span><br><span class="line">        ++j;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 匹配失败，j 重新指向模式串起始位置</span></span><br><span class="line">      i = ++pos; <span class="hljs-comment">// pos 记录上一次匹配的起始位置，在匹配失败后将i指向上一轮匹配的初始位置pos的后面一个位置++pos开始新一轮匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (j &gt;= substr.len)&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> pos; <span class="hljs-comment">// 匹配成功，返回模式串在主串中的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ol start="2">
<li><strong><em>KMP算法</em></strong>：</li>
</ol>
<ul>
<li><em>算法思想解析</em> :</li>
<li>上述的匹配算法称为“简单模式匹配算法（BF）”，其时间复杂度为O(mn),其中m为主串长度，n为模式串长度。由此可知简单模式匹配算法虽然易于理解但是效率很低，无法满足当已知数据异常庞大时的效率要求。所以就诞生了接下来登场的KMP算法。</li>
<li>我们知道，在BF算法中每次发生不匹配i与j都要回溯到该轮匹配的初始位置，并且在回溯之后的后几次匹配同样有可能导致（不必要的）不匹配状态，这是导致算法效率低下的主要原因，那么如何直接跳过这些不必要的不匹配状态而直接到达可能解决不匹配位置的的状态呢？</li>
<li>解决办法就是利用匹配失败后的信息，那么如何利用呢？</li>
<li>为了使问题变得更加直观，我们假想匹配过程就是模式串在主串上的移动(实际上并不会移动，全是指针在变化)，如果在某一次匹配时在模式串的第j位置发生了不匹配（j位置前的所有元素都已匹配成功），如果照着BF算法来做，我们会抛弃掉j位置前的匹配“成果”直接将i与j回溯重新开始下一轮比较。但现在我们不这么做，因为我们完全可以将j之前的匹配成果利用起来</li>
<li>不不妨假设模式串为“ABABABB”，并且该模式串在与主串的一次匹配流程中第4个元素B与主串发生了不匹配，很显然这个时候主串i位置前的三个元素跟模式串是完全匹配的，为了利用这个成果，就是在模式串向后移动后尽可能地保留这些匹配成果，我们观察这三个元素“ABA”的特点，发现他的前缀与后缀出现了相同的字符序列“A”，这时候我们应该意识到，要时上一次的成果得到最大限度的保留，我们只能将模式串移动到前缀与后缀重合的状态，这样子就保留了一个匹配成果“A“，同时i根本就不需要回溯（原地不动就好），因为i无需从模式串头部重新开始与其匹配，而只需从保留的成果后开始匹配也就是模式串的第二个位置（A的后一个位置）开始匹配。</li>
<li>但问题又来了，怎么知道模式串该怎么移动呢，从上面的分析我们发现，对于模式串移动的分析完全没有涉及到主串，那我们是怎么做到视主串而不见的呢(它可是”主“串啊给点面子好不好)。事实上，我们用到他了，因为我们的假设是”j位置前的元素与主串完全匹配“，竟然这样那么不就说明j位置前的模式串部分与主串的那一部分完全一样吗，所以我们可以用一个所谓”假模式串“来代替主串，而模式串只要在这个”傀儡身上移动就好了。所以，模式串在哪个位置与主串发生不匹配后模式串应该怎么移动，这个问题就可以脱离主串而背单独拿出来分析了，这就是后面要谈到的next数组（用与存放当j位置发生不匹配时，j指针应该重新调整到那个位置上）。有了next数组，我们就可以知道当模式串在J处与主串发生不匹配之后，为了最大限度地保留之前的匹配成果，模式串该怎么移动（指针该怎么变化）。</li>
</ul>
<hr>
<p><strong>KMP算法代码</strong>：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span> <span class="hljs-params">(LStr str,LStr substr,<span class="hljs-keyword">int</span> next[])</span></span>&#123; <span class="hljs-comment">// 函数接受主串，模式串，next数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ,j = <span class="hljs-number">1</span>; <span class="hljs-comment">// i 扫描主串，j 扫描模式串</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (i &lt; str.len &amp;&amp; i &lt; substr.len)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || str.ch[i] == substr.ch[j])&#123;  </span><br><span class="line"><span class="hljs-comment">// j=0;的情况就是模式串中的第一个字符与主串中的第i个字符不匹配，应从</span></span><br><span class="line"><span class="hljs-comment">// 主串的下一个位置与模式串的第一个位置继续比较，故++i(主串的下一个位置);</span></span><br><span class="line"><span class="hljs-comment">// ++j(模式串第一个位置0+1=1(很强))</span></span><br><span class="line">        ++j;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      j = next[j]; <span class="hljs-comment">// j 被调整到合适位置，这里的i不需要回朔，这也是KMP算法的一大特点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (j &gt;= substr.len)&#123; <span class="hljs-comment">// j 的长度超过了模式串，显然匹配成功</span></span><br><span class="line">    <span class="hljs-keyword">return</span> i - substr.len; <span class="hljs-comment">// 匹配成功，返回模式串在主串中的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>next数组的求法</strong>:</p>
<ul>
<li>经过前面的分析我们知道，只需要模式串本身我们就可以求出next数组，并不需要主串的参与。所以我们可以定义一个函数将next数组一次性求出，从此一劳永逸……</li>
<li>这里我们要用到一个算法思想，那就是<strong>递推</strong>,我们知道数列就是一种有着递推关系的数的序列。现在假设等差数列{An},给你一个递推公式(实际上就是前一个元素与后一个元素的关系)：A(n+1) = An + 1;其中n={1,2,3,…}然后告诉你第一个元素A1 = 0(实际上告诉你任何一个位置上的元素值都可以); 有了这两个已知条件你可以知道这个数列的所有元素就是非负整数集{0,1,2,3, …}。</li>
<li>那我们如何在求解next数组上面应用这个思想呢？ 首先看看我们有什么已知条件？</li>
<li>显然我们需要知道两个相邻状态Sk与Sk+1之间的关系，假设模式串为p1～pm，问题转化为两个模式串之间的匹配问题。如果在Sk时，已经求得了next[j] = t；若要求得Sk+1状态的next[j+1]，我们需要分两种状态来考虑：</li>
</ul>
<ol>
<li>若Pj = Pt；则next[j+1] = t+1;</li>
<li>若Pj != pt;这时候就又回到了我们讨论模式串与主串匹配出现匹配失败的经典情形了，不匹配发生在t处，我们应该去查next数组看看t应该怎样调整位置了，显然next[t]我们已经求得了，所以令t = next[t],继续比较pj与pt，若不相等重复第二种情况，直到t = 0;或者pj = pt 满足第一种情况，从而求得next[j+i];</li>
</ol>
<hr>
<p><strong>next求数组代码</strong>:<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(LStr substr,<span class="hljs-keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 特殊情况，模式串的第一个位置发生不匹配</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(i &lt; substr.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span> || substr.ch[t] == substr.ch[j])&#123; <span class="hljs-comment">// t=0;是因为next数组中可能有0元素,也说明没有重合的前后缀</span></span><br><span class="line">            next[j+<span class="hljs-number">1</span>] = t+<span class="hljs-number">1</span>; </span><br><span class="line">            ++j;</span><br><span class="line">            ++t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            t = next[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="KMP-算法的改进"><a href="#KMP-算法的改进" class="headerlink" title="KMP 算法的改进"></a>KMP 算法的改进</h4><hr>
<ul>
<li>KMP算法就还有什么地方需要改进的？</li>
<li>为了回答这个问题我们先来看一种特殊情况：模式串为（A A A A A B）,该模式串所对应的next数组为{0,1,2,3,4,5}。可以遇见的是当在模式串第j=5个位置A处发生不匹配时，next数组指导j指向4；而4处的元素依然不匹配（因为4处元素与5处相等），j来到了3（同样不匹配），紧接着来到了2（不匹配），来到1（依然不匹配），最后j=0(++i,++j)到此才结束了之前陷入的“尴尬”局面。</li>
<li>由上分析我们不难想到，如何才能让j直接跳到0；而免去从1-4的多余的比较呢？这就是KMP算法需要改进的地方</li>
<li>也就是说，对KMP算法的改进主要就是对求next数组的方法的改进，于是就有了改进版的next数组，我们称之为 <strong>nextval 数组</strong></li>
</ul>
<hr>
<h5 id="getNextval-算法核心思想："><a href="#getNextval-算法核心思想：" class="headerlink" title="getNextval() 算法核心思想："></a>getNextval() 算法核心思想：</h5><hr>
<ul>
<li>通过上面那个特殊情况，我们知道当j处发生不匹配时，若next数组指导的下一个位置的值与j处的值是相等的，那么显然这次比较就是多余的（因为显然还是会不匹配），所以我们应该跳过next数组所指向的那个位置，换一种思路就是我们应该让next[j] 所指向的位置与Pj不相等，就是改变next[j] 的值；改变后的next数组就是nextval数组.</li>
<li>求解nextval数组的一般步骤：</li>
</ul>
<ol>
<li>当j等于1时，nextval[j]赋值为 0 ，作为特殊标记；</li>
<li>当j大于1 时：<br>   若Pj不等于P(next[j]),则nextval[j] 等于 next[j];<br>   若Pj等于P(next[j]),则nextval[j] 等于 nextval[next[j]];</li>
</ol>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNextval</span><span class="hljs-params">(LStr substr,<span class="hljs-keyword">int</span> nextval[])</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line">  nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span>(i&lt;substr.len)&#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || substr.sh[j] == substr.ch[t])&#123;</span><br><span class="line">          <span class="hljs-keyword">if</span>(substr.ch[j+i] != substr.ch[t+<span class="hljs-number">1</span>])</span><br><span class="line">              nextval[j+<span class="hljs-number">1</span>] = t+<span class="hljs-number">1</span>;</span><br><span class="line">          <span class="hljs-keyword">else</span></span><br><span class="line">              nextval[j+<span class="hljs-number">1</span>] = nextval[t+<span class="hljs-number">1</span>];</span><br><span class="line">              </span><br><span class="line">              ++j;</span><br><span class="line">              ++t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">else</span> </span><br><span class="line">          t = nextval[t];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/linearList/" class="image is-7by1">
            <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580411500&amp;di=d3bc8a8fb160d662bf3ef1d14ff4ae37&amp;imgtype=0&amp;src=http%3A%2F%2Fs2.cdn.deahu.com%2Fshow%2Flfile%2F7E73DBAD83122DAF20DFDD33CF1E9C8D.jpg" alt="Linear List">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T06:20:02.356Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 minutes read (About 1598 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/linearList/">Linear List</a>
            
        </h1>
        <div class="content">
            <a id="more"></a>
<hr>
<h3 id="线性表的基本概念与实现"><a href="#线性表的基本概念与实现" class="headerlink" title="线性表的基本概念与实现"></a>线性表的基本概念与实现</h3><p>1.　<strong>线性表的定义:</strong><br>    线性表是具有相同特性数据元素的一个有限序列，重点在“<strong>有限序列</strong>”。线性表可以是有序的，也可以是无序的。<br>2.　<strong>线性表的逻辑特性:</strong><br>    除了表头和表尾的数据元素“结点”，所有元素都有一个<em>直接前驱</em>与一个<em>直接后继</em>。表头无前驱，表尾无后继。</p>
<ol>
<li><strong>线性表的存储结构：</strong></li>
</ol>
<pre><code>* 顺序存储结构：（顺序表）
    1. 存储空间连续（空间为*一次性*分配的）
    2. 可以随机存取，也可以顺序存取
    3. 插入删除时平均需要移动近一半的元素，时间复杂度为:__O((n-1)/2)=O(n)__
    4. 存储密度为１
* 链式存储结构：（链表）
    1. 存储空间可以不连续（存储空间是*动态*分配的）
    2. 每一个结点不仅包含数据还包含指向下一个结点的指针
    3. 只能够进行顺序存储
    4. 存储密度&lt;1
    5. 插入删除时不需要移动元素，只需修改*指针*即可,时间复杂度为:__O(1)__
</code></pre><ol>
<li><strong>线性表的定义与实现：</strong><br>a) <em>顺序表的定义：</em></li>
</ol>
<p><em>结构体定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#defined MaxSize 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> sturct Sqlist &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> data[MaxSize]; <span class="hljs-comment">//线性表最多能容纳的元素个数，即分配的空间大小</span></span><br><span class="line">    <span class="hljs-keyword">int</span> length ;　<span class="hljs-comment">//元素的个数</span></span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure></p>
<p><em>用的最多的简单定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> A[MaxSize]; <span class="hljs-comment">//直接利用数组就是顺序表的一种这一特性</span></span><br><span class="line"><span class="hljs-keyword">int</span> length;</span><br></pre></td></tr></table></figure></p>
<hr>
<p> 　  <em>b) 单链表的结点定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">//指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>  <em>c) 双链表结点定义：</em></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNOde</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNOde</span> *<span class="hljs-title">prior</span>;</span>　<span class="hljs-comment">// 指向前驱结点的指针</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">//　指向后继结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>【注】　为结点分配存储空间：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LNode *A = (LNOde*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="hljs-comment">//malloc 函数返回一个空间的地址，让指针Ａ来指向它</span></span><br></pre></td></tr></table></figure></p>
<h3 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h3><hr>
<ul>
<li><p>查找操作：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findElem</span> <span class="hljs-params">(Sqlist a, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;l.length;++i)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//找到了，返回所在的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">//　没找到，返回０</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入操作：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">insertElem</span><span class="hljs-params">(Sqlist &amp;L,<span class="hljs-keyword">int</span> i ,<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || i &gt; L.length)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//如果插入位置不合法，返回－１</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (L.length == MaxSize)&#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> newL[L.length+MaxSize]</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;L.length;++j)&#123;</span><br><span class="line">          newL[j] = L[j]; <span class="hljs-comment">//如果发现顺序表已经满了，就构造一个更大的顺序表并把原顺序表的元素放进去</span></span><br><span class="line">      &#125;</span><br><span class="line">  L = newL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = L.length<span class="hljs-number">-1</span>; k&gt;=i; --k)&#123;</span><br><span class="line">      L[k+<span class="hljs-number">1</span>] = L[k];　<span class="hljs-comment">//从某位开始将插入位置至末尾的元素向后移动一个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  L[i] = x;　<span class="hljs-comment">// 插入ｘ到ｉ处</span></span><br><span class="line">  L.length++; <span class="hljs-comment">// 插入后该表表的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除操作：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//　通过索引下标删除元素，并返回所删元素的值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteElem_by_index</span> <span class="hljs-params">(Sqlist &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> q = L[i];　<span class="hljs-comment">// 保留ｉ位置的元素</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;L.length;++j)&#123;</span><br><span class="line">        L[j<span class="hljs-number">-1</span>] = L[j]; <span class="hljs-comment">//　从待删除元素的右边开始每个元素向左移动一个位置，覆盖掉ｉ位置的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length--; <span class="hljs-comment">//　顺序表长度减一，完成删除操作</span></span><br><span class="line">    <span class="hljs-keyword">return</span> q; <span class="hljs-comment">//　返回被删除元素的值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 通过值来删除元素，并返回所删元素的下标</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteElem_by_value</span> <span class="hljs-params">(Sqlist &amp;L, <span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> index = findElem(L,e); <span class="hljs-comment">//利用findELem() 函数找到要删除元素的下标</span></span><br><span class="line">    <span class="hljs-keyword">int</span> value = L[index]; </span><br><span class="line">    deliteElem_by_index (L,index);　<span class="hljs-comment">// 用下标索引法删除元素</span></span><br><span class="line">    <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化顺序表：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initList</span> <span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;</span><br><span class="line">    L.length = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求指定位置元素：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getElem</span> <span class="hljs-params">(Sqlist L , <span class="hljs-keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; L.length<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error;</span><br><span class="line">    rerurn L[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="单链表的相关操作"><a href="#单链表的相关操作" class="headerlink" title="单链表的相关操作"></a>单链表的相关操作</h3><hr>
<h6 id="以下所有的算法用的都是带头结点的单链表"><a href="#以下所有的算法用的都是带头结点的单链表" class="headerlink" title="以下所有的算法用的都是带头结点的单链表"></a>以下所有的算法用的都是带头结点的单链表</h6><hr>
<ul>
<li><p>尾插法建立单链表：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 给定数组ａ[] 为数据源，建立单链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatListR</span><span class="hljs-params">(LNode *&amp;C , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    LNode *s,*r; <span class="hljs-comment">//用ｓ指向新建的结点，ｒ始终指向链表的尾部结点</span></span><br><span class="line">    C = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">// 建立链表头结点</span></span><br><span class="line">    C -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//　将链表滞空</span></span><br><span class="line">    r = C;　<span class="hljs-comment">// r 指向头结点，也就是空链表的头结点</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;length ; ++i)&#123;</span><br><span class="line">        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">//　用malloc函数循环分配结点空间</span></span><br><span class="line">        s -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">//　尾插法的核心算法：</span></span><br><span class="line">        r -&gt; next = s;</span><br><span class="line">        </span><br><span class="line">        r = r -&gt; next; <span class="hljs-comment">//r 指向当前尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// r -&gt; next ==　NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>头插法建立单链表：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatListH</span><span class="hljs-params">(LNode *&amp;C ,<span class="hljs-keyword">int</span> a[] ,<span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">// 建立链表头结点</span></span><br><span class="line">    C -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//　将链表滞空</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; length ; ++i)&#123;</span><br><span class="line">        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">// 头插法的核心算法：</span></span><br><span class="line">        s -&gt; next = C --&gt; next;</span><br><span class="line">        C -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除结点：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 按值索引删除链表结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(LNode &amp;L , <span class="hljs-keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="hljs-keyword">if</span> (L -&gt; next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//如果链表为空，返回０；</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (p -&gt; next != <span class="hljs-literal">NULL</span>)&#123;　<span class="hljs-comment">// 循环遍历链表结点</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (p -&gt; next -&gt; data == elem)&#123;　<span class="hljs-comment">// 如果ｐ指向的结点的下一个结点的数据域与带删除数据相等，删除该下一个结点，释放空间</span></span><br><span class="line">           <span class="hljs-comment">// 删除操作的核心算法：</span></span><br><span class="line">            q = p -&gt; next;</span><br><span class="line">            p -&gt; next = p -&gt; next -&gt; next;</span><br><span class="line">          　</span><br><span class="line">            <span class="hljs-built_in">free</span>(q);　<span class="hljs-comment">// 释放内存</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;　<span class="hljs-comment">//删除成功，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;　<span class="hljs-comment">//该节点不是待删除结点，令ｐ指向下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入结点：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 在链表的指定元素前插入结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(LNode &amp;L , <span class="hljs-keyword">int</span> we,<span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    LNode *r;</span><br><span class="line">    r = L;</span><br><span class="line">    LNode *s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">    q -&gt; data = we;</span><br><span class="line">    q -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (r -&gt; next != <span class="hljs-literal">NULL</span> )&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (r -&gt; next -&gt; data == e)&#123;</span><br><span class="line">        <span class="hljs-comment">//插入操作的核心算法：</span></span><br><span class="line">            s -&gt; next = r -&gt; next;</span><br><span class="line">            r -&gt; next = s;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="双链表的相关操作"><a href="#双链表的相关操作" class="headerlink" title="双链表的相关操作"></a>双链表的相关操作</h3><hr>
<ul>
<li><p>尾插法建立双链表：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//　给定数据源数组，建立双链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatDListR</span> <span class="hljs-params">(DLNode ＆L , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    DLNode *s,*r; <span class="hljs-comment">//用ｒ始终指向链表末尾结点，ｓ接受新分配的结点</span></span><br><span class="line">    L = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));　<span class="hljs-comment">// 申请头结点空间，并将链表滞空</span></span><br><span class="line">    L -&gt; prior = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    r = L;　<span class="hljs-comment">//r 指向头结点</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        s = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">// 尾插发的关键步骤：</span></span><br><span class="line">        s -&gt; prior = r;</span><br><span class="line">        r -&gt; next = s;</span><br><span class="line">        r = r -&gt; next; <span class="hljs-comment">// r = s;　令ｒ　指向下一个结点</span></span><br><span class="line">        r -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//滞空末尾结点的ｎｅｘｔ指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>头插法建立双链表：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatDListH</span> <span class="hljs-params">(DLNode ＆L , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    DLNode *s ;</span><br><span class="line">    L = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));　<span class="hljs-comment">// 申请头结点空间，并将链表滞空</span></span><br><span class="line">    L -&gt; prior = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;length; ++i)&#123;</span><br><span class="line">        s = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">//关键步骤：</span></span><br><span class="line">        s -&gt; next = L -&gt; next;</span><br><span class="line">        L -&gt; next -&gt; prior = s;</span><br><span class="line">        s -&gt; prior = L;</span><br><span class="line">        L -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找结点的算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 在双链表中查找第一个值为ｘ的结点，从第一个结点开始，边扫描边比较，若找到返回该结点的指针，没找到返回　ＮＵＬＬ</span></span><br><span class="line"><span class="hljs-function">DLNode* <span class="hljs-title">findNode</span><span class="hljs-params">(DLNode *L, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    DLNode *p;</span><br><span class="line">    p = L -&gt; next;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p -&gt; data == x)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入结点的算法：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在双链表中ｐ所指结点后插入新的结点ｓ</span></span><br><span class="line"><span class="hljs-comment">//关键步骤如下：</span></span><br><span class="line">              s -&gt; next = p -&gt; next;</span><br><span class="line">              s -&gt; prior = p;</span><br><span class="line">              p -&gt; next -&gt; prior = s;</span><br><span class="line">              p -&gt; next = s;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除结点：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在双链表中的删除指针ｐ所指结点的后继结点,并用ｓ指针返回被删除的结点</span></span><br><span class="line"><span class="hljs-comment">//关键步骤如下：</span></span><br><span class="line">              s = p -&gt; next ;</span><br><span class="line">              s -&gt; next -&gt; prior = p;</span><br><span class="line">              p -&gt; next = s -&gt; next;</span><br><span class="line">              <span class="hljs-built_in">free</span>(s);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2019/01/27/BinaryTree/" class="image is-7by1">
            <img class="thumbnail" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRBLDbFr6CW_eRLtMdxvN1k9RSobzPNrCVdZsQQUEx8ZBqb5p2Q" alt="BinaryTree">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T04:09:06.265Z">2019-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 7444 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/BinaryTree/">BinaryTree</a>
            
        </h1>
        <div class="content">
            <a id="more"></a>
<h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><hr>
<p><strong>树的定义：</strong><br>前面所提到的线性结构的元素是一种一对一的关系，而树是一种一对多的非线性结构，下面将通过一个具体的树的例子讲解到底什么样的结构才是树以 及树的一些相关术语：</p>
<p><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/f5a9f8e9-28f2-43bd-b130-68ae6fd1ce6e?size=11364&amp;format=image.png" alt="Alt text"></p>
<p>上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵<strong>空树</strong>。<br><strong>结点：</strong>上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；<br><strong>结点的度：</strong>该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；<br><strong>树的度：</strong>树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；<br><strong>叶子结点：</strong>又称为<em>终端结点</em>，指的是度为零的结点<br><strong>非终端结点：</strong>又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为<em>内部结点</em>。<br><strong>祖先：</strong>从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：<br>A和B，因为路径为：A–B–E；<br><strong>层次：</strong>根处为第一层，以此类推……，如上图树的层次为4层；<br><strong>结点的深度和高度：</strong>联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；<br><strong>有序树：</strong>树中结点的子树从左到右都是有次序的不能交换<br><strong>无序树：</strong>树中结点的子树没有次序，可以任意交换<br><strong>丰满树：</strong>理想的平衡树，要求除了最底层外，其他层都是满的<br><strong>森林：</strong>若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林</p>
<hr>
<h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul>
<li>顺序存储：<br>双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法)</li>
<li>链式存储：<br>孩子存储结构（孩子表示法）<br>孩子兄弟存储结构（孩子兄弟表示法）</li>
</ul>
<hr>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>二叉树的五种基本形式</li>
<li>满二叉树的概念</li>
<li>完全二叉树的概念<h4 id="二叉树的几个重要性质"><a href="#二叉树的几个重要性质" class="headerlink" title="二叉树的几个重要性质"></a>二叉树的几个重要性质</h4></li>
<li><strong>性质一：</strong>非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$；</li>
<li><strong>性质二：</strong>二叉树的第$i$层上最多有$2^{i-1}$;</li>
<li><strong>性质三：</strong>高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$.</li>
<li><strong>性质四：</strong>该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述；</li>
<li><strong>性质五：</strong>函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\frac{1}{n+1}×C_{2n}^n$ ;</li>
<li><strong>性质六：</strong>具有$n$个结点的完全二叉树的高度（或深度）为$[\log_2{n}]+1$(向下取整)；</li>
</ul>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul>
<li><strong>顺序存储结构：</strong><br>用一个数组来存储<em>完全二叉树</em>，将完全二叉树的结点值按编号依次存入一个一维数组中。<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/129c6471-292f-45fa-b88b-f9b131a9519b?size=9145&amp;format=image.png" alt="Alt text"></li>
</ul>
<p>如果要从一维数组中还原二叉树的本来结构，按照以下规则：<br>$i$ 为某结点的编号，若$i\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；<br>如果$2i\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；<br>如果$2i+1 \leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；<br>下面给出将数组还原成二叉链树的代码：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatBTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> BT[],<span class="hljs-keyword">int</span> n,BTNode *&amp;e)</span></span>&#123;</span><br><span class="line">  BTNode *BTNode_array[maxsize];</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i )&#123;</span><br><span class="line">    BTNode_array[i] = (BTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));</span><br><span class="line">    BTNode_array[i] -&gt; data = BT[i];</span><br><span class="line">    BTNode_array[i] -&gt; lchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    BTNode_array[i] -&gt; rchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= n )&#123;</span><br><span class="line">      BTNode_array[i] -&gt; lchild = BTNode_array[<span class="hljs-number">2</span>*i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>((<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>) &lt;= n)&#123;</span><br><span class="line">      BTNode_array[i] -&gt; rchild = BTNode_array[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  e = BTNode_array[<span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>链式存储结构：</strong><br>为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">lchild</span>;</span><span class="hljs-comment">//指向左孩子的指针</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//指向右孩子的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="二叉树的遍历算法-递归实现-："><a href="#二叉树的遍历算法-递归实现-：" class="headerlink" title="二叉树的遍历算法(递归实现)："></a>二叉树的遍历算法(递归实现)：</h4><p><strong>深度优先遍历：</strong></p>
<ul>
<li><p>前序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">		preorder(p -&gt; lchild);</span><br><span class="line">		preorder(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		inorder(p -&gt; lchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">		inorder(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		postorder(p -&gt; lchild);</span><br><span class="line">		postorder(p -&gt; rchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>广度优先遍历：</strong></p>
<ul>
<li>算法流程图解：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/d2feaa54-c857-460c-b488-68b1a22f1b48?size=23837&amp;format=image.png" alt="Alt text"><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">level</span> <span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode *que[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;</span><br><span class="line">		<span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;</span><br><span class="line">		BTNode *q;</span><br><span class="line">		rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">		que[rear] = p;</span><br><span class="line">		<span class="hljs-keyword">while</span>(front != rear)&#123;</span><br><span class="line">			front = (front + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">			q = que[front];</span><br><span class="line">			Visit(q);</span><br><span class="line">			<span class="hljs-keyword">if</span>(q -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">				que[rear] = q -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(q -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">				que[rear] = q -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="二叉树的遍历算法-非递归实现"><a href="#二叉树的遍历算法-非递归实现" class="headerlink" title="二叉树的遍历算法(非递归实现)"></a>二叉树的遍历算法(非递归实现)</h4><p><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/129c6471-292f-45fa-b88b-f9b131a9519b?size=9145&amp;format=image.png" alt="Alt text"></p>
<h6 id="上图而查处将作为例子方便讲解下面的算法"><a href="#上图而查处将作为例子方便讲解下面的算法" class="headerlink" title="上图而查处将作为例子方便讲解下面的算法"></a>上图而查处将作为例子方便讲解下面的算法</h6><hr>
<p><strong>深度优先遍历算法：</strong></p>
<ul>
<li><p>先序遍历：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/ae13d363-fcc2-483d-a71e-7d2da008f155?size=23289&amp;format=image.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	BTNode *Stack[maxsize];</span><br><span class="line">	<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">	BTNode *p;</span><br><span class="line">	Stack[++top] = bt;</span><br><span class="line">	<span class="hljs-keyword">while</span>(top != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	    p = Stack[top--];</span><br><span class="line">	    Visit(p);</span><br><span class="line">	    <span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	        Stack[++top] = p -&gt; rchild;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	        Stack[++top] = p -&gt; lchild;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：<br>先序遍历算法遍历例子二叉树将得到：A B D E C F G<br>后序遍历例子二叉树：D E B F G C A<br>将后序遍历序列逆置：A C G F B E D<br>可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/d648d949-fe95-4ccc-8907-136e5fd7aceb?size=18144&amp;format=image.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode Stack1[maxsize];</span><br><span class="line">		BTNode Stack2[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> top1 = <span class="hljs-number">-1</span>;</span><br><span class="line">		<span class="hljs-keyword">int</span> top2 = <span class="hljs-number">-1</span>;</span><br><span class="line">		BTNode *p = <span class="hljs-literal">NULL</span>;</span><br><span class="line">		Stack1[++top1] = bt;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top1 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">			p = Stack1[top--];</span><br><span class="line">			Stack2[++top] = p;</span><br><span class="line">			<span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack1[++top] = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack1[++top] = p -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top2 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">			p = Stack2[top--];</span><br><span class="line">			Visit(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/5fe9fc62-5e0a-42e3-94a6-95592557b418?size=25276&amp;format=image.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode *Stack[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">		BTNode *p;</span><br><span class="line">		p = bt;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top != <span class="hljs-number">-1</span> || p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			<span class="hljs-keyword">while</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack[++top] = p;</span><br><span class="line">				p = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(top != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">				p = Stack[top--];</span><br><span class="line">				Visit(p);</span><br><span class="line">				p = p -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><hr>
<p>对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。</p>
<ul>
<li><p>线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。<br><strong>线索二叉树的构造：</strong><br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/528c734a-926a-4fad-a78c-2ec01046f3bb?size=34684&amp;format=image.png" alt="Alt text"><br><strong>结点定义：</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> data; <span class="hljs-comment">// 数据域</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">lchild</span>;</span> <span class="hljs-comment">// 左孩子（前驱结点）指针</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">// 右孩子（后继结点）指针</span></span><br><span class="line">	<span class="hljs-keyword">int</span> ltag , rtag; <span class="hljs-comment">//线索标记</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。<br><strong>通过中序遍历对二叉树线索化代码：</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		InThread(p -&gt; lchild,pre); <span class="hljs-comment">// 递归地线索化左子树</span></span><br><span class="line">		<span class="hljs-keyword">if</span>(p -&gt; lchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立当前结点前驱线索</span></span><br><span class="line">			p -&gt; lchild = pre;</span><br><span class="line">			p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立前驱结点的后继线索</span></span><br><span class="line">			pre -&gt; rchild = p;</span><br><span class="line">			pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p; <span class="hljs-comment">// pre 跟上 p，之后p会指向下一个结点</span></span><br><span class="line">		InThread(p -&gt; rchild,pre); <span class="hljs-comment">// 递归地线索化右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>通过中序遍历线索二叉树的主程序如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatTBTNode</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	TBTNode *pre = <span class="hljs-literal">NULL</span>;</span><br><span class="line">	<span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		InThread(root,pre); <span class="hljs-comment">//递归建立线索二叉树</span></span><br><span class="line">		pre -&gt; rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处理最后一个结点</span></span><br><span class="line">		pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历中序线索二叉树：</strong><br><em>寻找中序线索二叉树 root 的第一个遍历结点：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">First</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">while</span>( root -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">		root = root -&gt; lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>在中序线索二叉树中，求结点p在中序下的后继结点的算法：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">Next</span><span class="hljs-params">(TBTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> First(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">else</span></span><br><span class="line">		<span class="hljs-keyword">return</span> p -&gt; rchild;  <span class="hljs-comment">// rtag = 1; 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>在中序线索二叉树上执行中序遍历：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inoreder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span> (TBTNode *p = First(root);p != <span class="hljs-literal">NULL</span>;p = Next(p))&#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通过前序遍历对二叉树线索化</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preInThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		<span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			p -&gt; lchild = pre;</span><br><span class="line">			p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			pre -&gt; rchild = p;</span><br><span class="line">			pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="hljs-keyword">if</span> (p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">			preThread(p -&gt; lchild,pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">			preThread(p -&gt; rchild,pre);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历前序线索二叉树算法：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		TBTNode *p = root;</span><br><span class="line">		<span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			<span class="hljs-keyword">while</span>(p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">				Visit(p);</span><br><span class="line">				p = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			Visit(p);</span><br><span class="line">			p = p -&gt; rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="树与森林的互相转换"><a href="#树与森林的互相转换" class="headerlink" title="树与森林的互相转换"></a>树与森林的互相转换</h4><hr>
<hr>
<h4 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h4><hr>
<h5 id="二叉排序树与二叉平衡树"><a href="#二叉排序树与二叉平衡树" class="headerlink" title="二叉排序树与二叉平衡树"></a>二叉排序树与二叉平衡树</h5><hr>
<h5 id="赫夫曼树与赫夫曼编码"><a href="#赫夫曼树与赫夫曼编码" class="headerlink" title="赫夫曼树与赫夫曼编码"></a>赫夫曼树与赫夫曼编码</h5><hr>
<p><strong>赫夫曼树的相关概念及介绍：</strong><br>赫夫曼树又被称为最优二叉树，它的特点是<strong>带权路径最短</strong>。下面介绍几个相关概念：</p>
<ul>
<li><strong>路径：</strong>指从树中一个结点到另一个结点的分支所构成的路线</li>
<li><strong>路径长度：</strong>路径上的分支数目</li>
<li><strong>树的路径长度：</strong>从根到<strong>每个结点</strong>的路径长度之和</li>
<li><strong>带权路径长度：</strong>结点具有<strong>权值</strong>，从该结点到<strong>根结点</strong>的路径长度乘于该结点的权值就是该结点的带权路径长度</li>
<li><strong>树的带权路径长度（WPL）：</strong>树中所有<strong>叶子结点</strong>的带权路径长度之和</li>
</ul>
<p><strong>赫夫曼树的构造方法：</strong><br>给定$n$个权值，用这些个权值来构造赫夫曼树：<br>首先了解一下赫夫曼树的一些特点：</p>
<ul>
<li>权值越大的结点距离根节点越近</li>
<li>树中没有度为1的结点</li>
<li>树的带权路径长度最短</li>
</ul>
<p>根据上述特点反推我们是如何来构造一个赫夫曼树：</p>
<ul>
<li>从最底层开始构造</li>
<li>最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点</li>
<li>权值最大的结点离根节点最近</li>
</ul>
<p>有了上述导论我们就可以开始构造一棵赫夫曼树了：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/afd4566a-363f-4871-b428-07fc779d80e8?size=29491&amp;format=image.png" alt="Alt text"><br>上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。</p>
<h5 id="赫夫曼编码："><a href="#赫夫曼编码：" class="headerlink" title="赫夫曼编码："></a>赫夫曼编码：</h5><hr>
<h6 id="利用赫夫曼树的特点来对文件进行压缩存储"><a href="#利用赫夫曼树的特点来对文件进行压缩存储" class="headerlink" title="* 利用赫夫曼树的特点来对文件进行压缩存储"></a>* 利用赫夫曼树的特点来对文件进行压缩存储</h6><hr>
<p>看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$<br>选三位长度的二进制数为A到E编码：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/f6ccda15-e512-4a7e-a694-7b088f29ec28?size=2693&amp;format=image.png" alt="Alt text"><br>根据上表我们可以将该字符串编码为：<br>$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$<br>解码时每三位一个字符解码<br>总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？</p>
<p>答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/593360db-1c5d-4667-b0f8-a3d0b2bed605?size=2741&amp;format=image.png" alt="Alt text"><br>利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/6f3c291d-0e1e-40d7-8897-ca6daefcc7be?size=13337&amp;format=image.png" alt="Alt text"><br>到此我们得到了对A到E的霍夫曼编码规则：<br><img src="https://maxiang.io/evernote/res/https://app.yinxiang.com/shard/s67/res/185200e4-f98e-4f20-b5bf-693bb3537c49?size=2947&amp;format=image.png" alt="Alt text"><br>根据上表的编码规则可将字符串编码为：<br>$1110010101101011110011110101010110111000011001011111111110110$<br>只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。</p>
<p><strong>解码霍夫曼编码：</strong><br>解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。</p>
<hr>
<ul>
<li>[注] <em>对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的</em></li>
</ul>
<h5 id="霍夫曼-n-叉树"><a href="#霍夫曼-n-叉树" class="headerlink" title="霍夫曼$n$叉树"></a>霍夫曼$n$叉树</h5><ul>
<li><em>霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例</em></li>
</ul>
<hr>
<p>构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。<br><img src="blob:https://maxiang.io/5b1c5cbf-db46-46e3-9f5c-608a7261a893" alt="Alt text"></p>
<p>)</p>
<p>上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵<strong>空树</strong>。<br><strong>结点：</strong>上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；<br><strong>结点的度：</strong>该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；<br><strong>树的度：</strong>树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；<br><strong>叶子结点：</strong>又称为<em>终端结点</em>，指的是度为零的结点<br><strong>非终端结点：</strong>又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为<em>内部结点</em>。<br><strong>祖先：</strong>从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：<br>A和B，因为路径为：A–B–E；<br><strong>层次：</strong>根处为第一层，以此类推……，如上图树的层次为4层；<br><strong>结点的深度和高度：</strong>联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；<br><strong>有序树：</strong>树中结点的子树从左到右都是有次序的不能交换<br><strong>无序树：</strong>树中结点的子树没有次序，可以任意交换<br><strong>丰满树：</strong>理想的平衡树，要求除了最底层外，其他层都是满的<br><strong>森林：</strong>若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林</p>
<hr>
<h4 id="树的存储结构-1"><a href="#树的存储结构-1" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul>
<li>顺序存储：<br>双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法)</li>
<li>链式存储：<br>孩子存储结构（孩子表示法）<br>孩子兄弟存储结构（孩子兄弟表示法）</li>
</ul>
<hr>
<h4 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>二叉树的五种基本形式</li>
<li>满二叉树的概念</li>
<li>完全二叉树的概念<h4 id="二叉树的几个重要性质-1"><a href="#二叉树的几个重要性质-1" class="headerlink" title="二叉树的几个重要性质"></a>二叉树的几个重要性质</h4></li>
<li><strong>性质一：</strong>非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$；</li>
<li><strong>性质二：</strong>二叉树的第$i$层上最多有$2^{i-1}$;</li>
<li><strong>性质三：</strong>高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$.</li>
<li><strong>性质四：</strong>该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述；</li>
<li><strong>性质五：</strong>函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\frac{1}{n+1}×C_{2n}^n$ ;</li>
<li><strong>性质六：</strong>具有$n$个结点的完全二叉树的高度（或深度）为$[\log_2{n}]+1$(向下取整)；</li>
</ul>
<h4 id="二叉树的存储结构-1"><a href="#二叉树的存储结构-1" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul>
<li><strong>顺序存储结构：</strong><br>用一个数组来存储<em>完全二叉树</em>，将完全二叉树的结点值按编号依次存入一个一维数组中。<br><img src="./深度截图_选择区域_20180802200457.png" alt="Alt text"></li>
</ul>
<p>如果要从一维数组中还原二叉树的本来结构，按照以下规则：<br>$i$ 为某结点的编号，若$i\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；<br>如果$2i\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；<br>如果$2i+1 \leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；<br>下面给出将数组还原成二叉链树的代码：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatBTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> BT[],<span class="hljs-keyword">int</span> n,BTNode *&amp;e)</span></span>&#123;</span><br><span class="line">  BTNode *BTNode_array[maxsize];</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i )&#123;</span><br><span class="line">    BTNode_array[i] = (BTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));</span><br><span class="line">    BTNode_array[i] -&gt; data = BT[i];</span><br><span class="line">    BTNode_array[i] -&gt; lchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    BTNode_array[i] -&gt; rchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= n )&#123;</span><br><span class="line">      BTNode_array[i] -&gt; lchild = BTNode_array[<span class="hljs-number">2</span>*i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>((<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>) &lt;= n)&#123;</span><br><span class="line">      BTNode_array[i] -&gt; rchild = BTNode_array[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  e = BTNode_array[<span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>链式存储结构：</strong><br>为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">lchild</span>;</span><span class="hljs-comment">//指向左孩子的指针</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//指向右孩子的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="二叉树的遍历算法-递归实现-：-1"><a href="#二叉树的遍历算法-递归实现-：-1" class="headerlink" title="二叉树的遍历算法(递归实现)："></a>二叉树的遍历算法(递归实现)：</h4><p><strong>深度优先遍历：</strong></p>
<ul>
<li><p>前序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">		preorder(p -&gt; lchild);</span><br><span class="line">		preorder(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		inorder(p -&gt; lchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">		inorder(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		postorder(p -&gt; lchild);</span><br><span class="line">		postorder(p -&gt; rchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>广度优先遍历：</strong></p>
<ul>
<li>算法流程图解：<br><img src="./深度截图_选择区域_20180804221455.png" alt="Alt text"><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">level</span> <span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode *que[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;</span><br><span class="line">		<span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;</span><br><span class="line">		BTNode *q;</span><br><span class="line">		rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">		que[rear] = p;</span><br><span class="line">		<span class="hljs-keyword">while</span>(front != rear)&#123;</span><br><span class="line">			front = (front + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">			q = que[front];</span><br><span class="line">			Visit(q);</span><br><span class="line">			<span class="hljs-keyword">if</span>(q -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">				que[rear] = q -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(q -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">				que[rear] = q -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="二叉树的遍历算法-非递归实现-1"><a href="#二叉树的遍历算法-非递归实现-1" class="headerlink" title="二叉树的遍历算法(非递归实现)"></a>二叉树的遍历算法(非递归实现)</h4><p><img src="./深度截图_选择区域_20180802200457.png" alt="Alt text"></p>
<h6 id="上图而查处将作为例子方便讲解下面的算法-1"><a href="#上图而查处将作为例子方便讲解下面的算法-1" class="headerlink" title="上图而查处将作为例子方便讲解下面的算法"></a>上图而查处将作为例子方便讲解下面的算法</h6><hr>
<p><strong>深度优先遍历算法：</strong></p>
<ul>
<li><p>先序遍历：<br><img src="./深度截图_选择区域_20180804215929.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	BTNode *Stack[maxsize];</span><br><span class="line">	<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">	BTNode *p;</span><br><span class="line">	Stack[++top] = bt;</span><br><span class="line">	<span class="hljs-keyword">while</span>(top != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	    p = Stack[top--];</span><br><span class="line">	    Visit(p);</span><br><span class="line">	    <span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	        Stack[++top] = p -&gt; rchild;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">	        Stack[++top] = p -&gt; lchild;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：<br>先序遍历算法遍历例子二叉树将得到：A B D E C F G<br>后序遍历例子二叉树：D E B F G C A<br>将后序遍历序列逆置：A C G F B E D<br>可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。<br><img src="./深度截图_选择区域_20180804230700.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode Stack1[maxsize];</span><br><span class="line">		BTNode Stack2[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> top1 = <span class="hljs-number">-1</span>;</span><br><span class="line">		<span class="hljs-keyword">int</span> top2 = <span class="hljs-number">-1</span>;</span><br><span class="line">		BTNode *p = <span class="hljs-literal">NULL</span>;</span><br><span class="line">		Stack1[++top1] = bt;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top1 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">			p = Stack1[top--];</span><br><span class="line">			Stack2[++top] = p;</span><br><span class="line">			<span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack1[++top] = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack1[++top] = p -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top2 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">			p = Stack2[top--];</span><br><span class="line">			Visit(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：<br><img src="./深度截图_选择区域_20180804235730.png" alt="Alt text"></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		BTNode *Stack[maxsize];</span><br><span class="line">		<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">		BTNode *p;</span><br><span class="line">		p = bt;</span><br><span class="line">		<span class="hljs-keyword">while</span>(top != <span class="hljs-number">-1</span> || p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			<span class="hljs-keyword">while</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">				Stack[++top] = p;</span><br><span class="line">				p = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span>(top != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">				p = Stack[top--];</span><br><span class="line">				Visit(p);</span><br><span class="line">				p = p -&gt; rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><hr>
<p>对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。</p>
<ul>
<li><p>线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。<br><strong>线索二叉树的构造：</strong><br><img src="./深度截图_选择区域_20180807215755.png" alt="Alt text"><br><strong>结点定义：</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span>&#123;</span></span><br><span class="line">	<span class="hljs-keyword">int</span> data; <span class="hljs-comment">// 数据域</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">lchild</span>;</span> <span class="hljs-comment">// 左孩子（前驱结点）指针</span></span><br><span class="line">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">// 右孩子（后继结点）指针</span></span><br><span class="line">	<span class="hljs-keyword">int</span> ltag , rtag; <span class="hljs-comment">//线索标记</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。<br><strong>通过中序遍历对二叉树线索化代码：</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		InThread(p -&gt; lchild,pre); <span class="hljs-comment">// 递归地线索化左子树</span></span><br><span class="line">		<span class="hljs-keyword">if</span>(p -&gt; lchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立当前结点前驱线索</span></span><br><span class="line">			p -&gt; lchild = pre;</span><br><span class="line">			p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立前驱结点的后继线索</span></span><br><span class="line">			pre -&gt; rchild = p;</span><br><span class="line">			pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p; <span class="hljs-comment">// pre 跟上 p，之后p会指向下一个结点</span></span><br><span class="line">		InThread(p -&gt; rchild,pre); <span class="hljs-comment">// 递归地线索化右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>通过中序遍历线索二叉树的主程序如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatTBTNode</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	TBTNode *pre = <span class="hljs-literal">NULL</span>;</span><br><span class="line">	<span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		InThread(root,pre); <span class="hljs-comment">//递归建立线索二叉树</span></span><br><span class="line">		pre -&gt; rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处理最后一个结点</span></span><br><span class="line">		pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历中序线索二叉树：</strong><br><em>寻找中序线索二叉树 root 的第一个遍历结点：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">First</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">while</span>( root -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">		root = root -&gt; lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>在中序线索二叉树中，求结点p在中序下的后继结点的算法：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">Next</span><span class="hljs-params">(TBTNode *p)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> First(p -&gt; rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">else</span></span><br><span class="line">		<span class="hljs-keyword">return</span> p -&gt; rchild;  <span class="hljs-comment">// rtag = 1; 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>在中序线索二叉树上执行中序遍历：</em><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inoreder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span> (TBTNode *p = First(root);p != <span class="hljs-literal">NULL</span>;p = Next(p))&#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通过前序遍历对二叉树线索化</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preInThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		<span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			p -&gt; lchild = pre;</span><br><span class="line">			p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			pre -&gt; rchild = p;</span><br><span class="line">			pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;</span><br><span class="line">		<span class="hljs-keyword">if</span> (p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">			preThread(p -&gt; lchild,pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">			preThread(p -&gt; rchild,pre);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历前序线索二叉树算法：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">		TBTNode *p = root;</span><br><span class="line">		<span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">			<span class="hljs-keyword">while</span>(p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">				Visit(p);</span><br><span class="line">				p = p -&gt; lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			Visit(p);</span><br><span class="line">			p = p -&gt; rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="树与森林的互相转换-1"><a href="#树与森林的互相转换-1" class="headerlink" title="树与森林的互相转换"></a>树与森林的互相转换</h4><hr>
<hr>
<h4 id="树与二叉树的应用-1"><a href="#树与二叉树的应用-1" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h4><hr>
<h5 id="二叉排序树与二叉平衡树-1"><a href="#二叉排序树与二叉平衡树-1" class="headerlink" title="二叉排序树与二叉平衡树"></a>二叉排序树与二叉平衡树</h5><hr>
<h5 id="赫夫曼树与赫夫曼编码-1"><a href="#赫夫曼树与赫夫曼编码-1" class="headerlink" title="赫夫曼树与赫夫曼编码"></a>赫夫曼树与赫夫曼编码</h5><hr>
<p><strong>赫夫曼树的相关概念及介绍：</strong><br>赫夫曼树又被称为最优二叉树，它的特点是<strong>带权路径最短</strong>。下面介绍几个相关概念：</p>
<ul>
<li><strong>路径：</strong>指从树中一个结点到另一个结点的分支所构成的路线</li>
<li><strong>路径长度：</strong>路径上的分支数目</li>
<li><strong>树的路径长度：</strong>从根到<strong>每个结点</strong>的路径长度之和</li>
<li><strong>带权路径长度：</strong>结点具有<strong>权值</strong>，从该结点到<strong>根结点</strong>的路径长度乘于该结点的权值就是该结点的带权路径长度</li>
<li><strong>树的带权路径长度（WPL）：</strong>树中所有<strong>叶子结点</strong>的带权路径长度之和</li>
</ul>
<p><strong>赫夫曼树的构造方法：</strong><br>给定$n$个权值，用这些个权值来构造赫夫曼树：<br>首先了解一下赫夫曼树的一些特点：</p>
<ul>
<li>权值越大的结点距离根节点越近</li>
<li>树中没有度为1的结点</li>
<li>树的带权路径长度最短</li>
</ul>
<p>根据上述特点反推我们是如何来构造一个赫夫曼树：</p>
<ul>
<li>从最底层开始构造</li>
<li>最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点</li>
<li>权值最大的结点离根节点最近</li>
</ul>
<p>有了上述导论我们就可以开始构造一棵赫夫曼树了：<br><img src="./深度截图_选择区域_20180809202210.png" alt="Alt text"><br>上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。</p>
<h5 id="赫夫曼编码：-1"><a href="#赫夫曼编码：-1" class="headerlink" title="赫夫曼编码："></a>赫夫曼编码：</h5><hr>
<h6 id="利用赫夫曼树的特点来对文件进行压缩存储-1"><a href="#利用赫夫曼树的特点来对文件进行压缩存储-1" class="headerlink" title="* 利用赫夫曼树的特点来对文件进行压缩存储"></a>* 利用赫夫曼树的特点来对文件进行压缩存储</h6><hr>
<p>看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$<br>选三位长度的二进制数为A到E编码：<br><img src="./深度截图_选择区域_20180809204213.png" alt="Alt text"><br>根据上表我们可以将该字符串编码为：<br>$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$<br>解码时每三位一个字符解码<br>总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？</p>
<p>答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：<br><img src="./深度截图_选择区域_20180809204958.png" alt="Alt text"><br>利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：<br><img src="./深度截图_选择区域_20180809205410.png" alt="Alt text"><br>到此我们得到了对A到E的霍夫曼编码规则：<br><img src="./深度截图_选择区域_20180809205718.png" alt="Alt text"><br>根据上表的编码规则可将字符串编码为：<br>$1110010101101011110011110101010110111000011001011111111110110$<br>只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。</p>
<p><strong>解码霍夫曼编码：</strong><br>解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。</p>
<hr>
<ul>
<li>[注] <em>对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的</em></li>
</ul>
<h5 id="霍夫曼-n-叉树-1"><a href="#霍夫曼-n-叉树-1" class="headerlink" title="霍夫曼$n$叉树"></a>霍夫曼$n$叉树</h5><ul>
<li><em>霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例</em></li>
</ul>
<hr>
<p>构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。<br><img src="./深度截图_选择区域_20180809213107.png" alt="Alt text"></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-27T03:36:36.750Z">2019-01-27</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    a minute read (About 122 words)
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/01/27/hello-world/">Hello Friend</a>
            
        </h1>
        <div class="content">
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2019/01/27/hello-world/#more">Read More</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>








</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="image is-128x128 has-mb-6" src="https://avatars1.githubusercontent.com/u/30885631?s=460&amp;v=4" alt="Aoki Lin">
                    
                    <p class="is-size-4 is-block">
                        Aoki Lin
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        C/C++ Software Developer
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Earth,Solar System</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <p class="title has-text-weight-normal">
                        7
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="http://github.com/YHCClin">
                Follow</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="http://github.com/YHCClin">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Facebook" href="http://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Twitter" href="https://twitter.com/echo_scottlin">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Dribbble" href="http://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Links
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://hexo.io" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hexo.io</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.google.com" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Google</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.google.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.stackoverflow.com" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Stackoverflow</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.stackoverflow.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Course/">
            <span class="level-start">
                <span class="level-item">Course</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/DataStructs/">
            <span class="level-start">
                <span class="level-item">DataStructs</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Tag Cloud
        </h3>
        <a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/List/" style="font-size: 20px;">List</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2019/01/27/HexoEditor/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/icons/HexoEditor.svg?sanitize=true" alt="HexoEditor">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T13:09:02.000Z">2019-01-27</time></div>
                    <a href="/2019/01/27/HexoEditor/" class="has-link-black-ter is-size-6">HexoEditor</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Course/">Course</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/arrayandlist/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549179243&amp;di=d0595deef1085246079f16279e96f2ba&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fsource.aliog.com%2Fwp-content%2Fuploads%2F2015%2F05%2F20150521_555d7178d1052.png" alt="Array Marix GeneralList">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T07:07:54.237Z">2019-01-27</time></div>
                    <a href="/2019/01/27/arrayandlist/" class="has-link-black-ter is-size-6">Array Marix GeneralList</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/QueueStack/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548581470072&amp;di=ee7f02ae4ffa2ccc6257101f77c6b5d9&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170627%2Fa3e6109615584b62a5eb86fe79243270_th.jpg" alt="Queue and Stack">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:30:48.907Z">2019-01-27</time></div>
                    <a href="/2019/01/27/QueueStack/" class="has-link-black-ter is-size-6">Queue and Stack</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/String/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580675099&amp;di=6efdd9be8a2394de553173ab69c0bb70&amp;imgtype=0&amp;src=http%3A%2F%2Fs1.knowsky.com%2F20170206%2Fp3rqnw1kmbl32.png" alt="String">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:27:40.068Z">2019-01-27</time></div>
                    <a href="/2019/01/27/String/" class="has-link-black-ter is-size-6">String</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/linearList/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580411500&amp;di=d3bc8a8fb160d662bf3ef1d14ff4ae37&amp;imgtype=0&amp;src=http%3A%2F%2Fs2.cdn.deahu.com%2Fshow%2Flfile%2F7E73DBAD83122DAF20DFDD33CF1E9C8D.jpg" alt="Linear List">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:20:02.356Z">2019-01-27</time></div>
                    <a href="/2019/01/27/linearList/" class="has-link-black-ter is-size-6">Linear List</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">7</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Array/">
                        <span class="tag">Array</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/List/">
                        <span class="tag">List</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/String/">
                        <span class="tag">String</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tools/">
                        <span class="tag">Tools</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right is-sticky">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2019/01/27/HexoEditor/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/icons/HexoEditor.svg?sanitize=true" alt="HexoEditor">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T13:09:02.000Z">2019-01-27</time></div>
                    <a href="/2019/01/27/HexoEditor/" class="has-link-black-ter is-size-6">HexoEditor</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Course/">Course</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/arrayandlist/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549179243&amp;di=d0595deef1085246079f16279e96f2ba&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fsource.aliog.com%2Fwp-content%2Fuploads%2F2015%2F05%2F20150521_555d7178d1052.png" alt="Array Marix GeneralList">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T07:07:54.237Z">2019-01-27</time></div>
                    <a href="/2019/01/27/arrayandlist/" class="has-link-black-ter is-size-6">Array Marix GeneralList</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/QueueStack/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548581470072&amp;di=ee7f02ae4ffa2ccc6257101f77c6b5d9&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170627%2Fa3e6109615584b62a5eb86fe79243270_th.jpg" alt="Queue and Stack">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:30:48.907Z">2019-01-27</time></div>
                    <a href="/2019/01/27/QueueStack/" class="has-link-black-ter is-size-6">Queue and Stack</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/String/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580675099&amp;di=6efdd9be8a2394de553173ab69c0bb70&amp;imgtype=0&amp;src=http%3A%2F%2Fs1.knowsky.com%2F20170206%2Fp3rqnw1kmbl32.png" alt="String">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:27:40.068Z">2019-01-27</time></div>
                    <a href="/2019/01/27/String/" class="has-link-black-ter is-size-6">String</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/01/27/linearList/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1548580411500&amp;di=d3bc8a8fb160d662bf3ef1d14ff4ae37&amp;imgtype=0&amp;src=http%3A%2F%2Fs2.cdn.deahu.com%2Fshow%2Flfile%2F7E73DBAD83122DAF20DFDD33CF1E9C8D.jpg" alt="Linear List">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-01-27T06:20:02.356Z">2019-01-27</time></div>
                    <a href="/2019/01/27/linearList/" class="has-link-black-ter is-size-6">Linear List</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/DataStructs/">DataStructs</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">7</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Array/">
                        <span class="tag">Array</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/List/">
                        <span class="tag">List</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/String/">
                        <span class="tag">String</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tools/">
                        <span class="tag">Tools</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Tree/">
                        <span class="tag">Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/gen.svg" alt="Aoki&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 AokiLin&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-icarus">Icarus</a>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="http://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>