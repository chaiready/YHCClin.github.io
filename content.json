{"pages":[{"title":"","text":"1cv9HsU1kD","link":"/baidu_verify_1cv9HsU1kD.html"},{"title":"404 Not Found：呀！迷路了......","text":"&lt;!DOCTYPE html&gt; 万恶の 404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"admin\":{\"username\":\"aokilin\",\"password_hash\":\"$2a$10$Ftok/UgFv5olradmR40PM.w57gZ.QOp2uXQlpSZevsU.pMi0KPHla\",\"secret\":\"my super secret phrase\"},\"kramed\":{\"gfm\":true,\"pedantic\":false,\"sanitize\":false,\"tables\":true,\"breaks\":true,\"smartLists\":true,\"smartypants\":true},\"feed\":{\"type\":\"atom\",\"path\":\"atom.xml\",\"limit\":20}});","link":"/404.html"},{"title":"About Me","text":"","link":"/about/index.html"},{"title":"","text":"#mainDiv{ width:100%; height:100% } #code{ float:left; width:440px; height:400px; color:#333; font-family:\"Consolas\",\"Monaco\",\"Bitstream Vera Sans Mono\",\"Courier New\",\"sans-serif\"; font-size:12px } #code .string{ color:#2a36ff } #code .keyword{ color:#7f0055; font-weight:bold } #code .placeholder{ margin-left:15px } #code .space{ margin-left:7px } #code .comments{ color:#3f7f5f }","link":"/about/css/default.css"},{"title":"","text":"body { margin: 0; padding: 0; background: #FFFFEE; font-size: 12px; overflow: auto; } #mainDiv{ width: 100%; height: 100%; } #loveHeart { float: left; width:670px; height:625px; } #garden { width: 100%; height: 100%; } #elapseClock { text-align: right; font-size: 18px; margin-top: 10px; margin-bottom: 10px; } #words { font-family: \"sans-serif\"; width: 500px; font-size: 24px; color:#666; } #messages{ display: none; } #elapseClock .digit{ font-family: \"digit\"; font-size: 36px; } #loveu{ padding: 5px; font-size: 22px; margin-top: 80px; margin-right: 120px; text-align: right; display: none; } #loveu .signature{ margin-top: 10px; font-size: 20px; font-style: italic; } #clickSound{ display:none; } #code { float: left; width: 440px; height: 400px; color: #333; font-family: \"Consolas\", \"Monaco\", \"Bitstream Vera Sans Mono\", \"Courier New\", \"sans-serif\"; font-size: 12px; } #code .string{ color: #2a36ff; } #code .keyword{ color: #7f0055; font-weight:bold; } #code .placeholder{ margin-left:15px; } #code .space{ margin-left:7px; } #code .comments{ color: #3f7f5f; } #copyright{ margin-top: 10px; text-align: center; width:100%; color:#666; } #errorMsg{ width: 100%; text-align: center; font-size: 24px; position: absolute; top: 100px; left:0px; } #copyright a{ color:#666; }","link":"/about/css/default_dev.css"},{"title":"","text":"var $window=$(window),gardenCtx,gardenCanvas,$garden,garden;var clientWidth=$(window).width();var clientHeight=$(window).height();$(function(){$loveHeart=$(\"#loveHeart\");var a=$loveHeart.width()/2;var b=$loveHeart.height()/2-55;$garden=$(\"#garden\");gardenCanvas=$garden[0];gardenCanvas.width=$(\"#loveHeart\").width();gardenCanvas.height=$(\"#loveHeart\").height();gardenCtx=gardenCanvas.getContext(\"2d\");gardenCtx.globalCompositeOperation=\"lighter\";garden=new Garden(gardenCtx,gardenCanvas);$(\"#content\").css(\"width\",$loveHeart.width()+$(\"#code\").width());$(\"#content\").css(\"height\",Math.max($loveHeart.height(),$(\"#code\").height()));$(\"#content\").css(\"margin-top\",Math.max(($window.height()-$(\"#content\").height())/2,10));$(\"#content\").css(\"margin-left\",Math.max(($window.width()-$(\"#content\").width())/2,10));setInterval(function(){garden.render()},Garden.options.growSpeed)});$(window).resize(function(){var b=$(window).width();var a=$(window).height();if(b!=clientWidth&&a!=clientHeight){location.replace(location)}});function getHeartPoint(c){var b=c/Math.PI;var a=19.5*(16*Math.pow(Math.sin(b),3));var d=-20*(13*Math.cos(b)-5*Math.cos(2*b)-2*Math.cos(3*b)-Math.cos(4*b));return new Array(offsetX+a,offsetY+d)}function startHeartAnimation(){var c=50;var d=10;var b=new Array();var a=setInterval(function(){var h=getHeartPoint(d);var e=true;for(var f=0;f=30){clearInterval(a);showMessages()}else{d+=0.2}},c)}(function(a){a.fn.typewriter=function(){this.each(function(){var d=a(this),c=d.html(),b=0;d.html(\"\");var e=setInterval(function(){var f=c.substr(b,1);if(f==\"\",b)+1}else{b++}d.html(c.substring(0,b)+(b&1?\"_\":\"\"));if(b>=c.length){clearInterval(e)}},75)});return this}})(jQuery);function timeElapse(c){var e=Date();var f=(Date.parse(e)-Date.parse(c))/1000;var g=Math.floor(f/(3600*24));f=f%(3600*24);var b=Math.floor(f/3600);if(b","link":"/about/js/functions.js"},{"title":"","text":"// variables var $window = $(window), gardenCtx, gardenCanvas, $garden, garden; var clientWidth = $(window).width(); var clientHeight = $(window).height(); $(function () { // setup garden $loveHeart = $(\"#loveHeart\"); var offsetX = $loveHeart.width() / 2; var offsetY = $loveHeart.height() / 2 - 55; $garden = $(\"#garden\"); gardenCanvas = $garden[0]; gardenCanvas.width = $(\"#loveHeart\").width(); gardenCanvas.height = $(\"#loveHeart\").height() gardenCtx = gardenCanvas.getContext(\"2d\"); gardenCtx.globalCompositeOperation = \"lighter\"; garden = new Garden(gardenCtx, gardenCanvas); $(\"#content\").css(\"width\", $loveHeart.width() + $(\"#code\").width()); $(\"#content\").css(\"height\", Math.max($loveHeart.height(), $(\"#code\").height())); $(\"#content\").css(\"margin-top\", Math.max(($window.height() - $(\"#content\").height()) / 2, 10)); $(\"#content\").css(\"margin-left\", Math.max(($window.width() - $(\"#content\").width()) / 2, 10)); // renderLoop setInterval(function () { garden.render(); }, Garden.options.growSpeed); }); $(window).resize(function() { var newWidth = $(window).width(); var newHeight = $(window).height(); if (newWidth != clientWidth && newHeight != clientHeight) { location.replace(location); } }); function getHeartPoint(angle) { var t = angle / Math.PI; var x = 19.5 * (16 * Math.pow(Math.sin(t), 3)); var y = - 20 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)); return new Array(offsetX + x, offsetY + y); } function startHeartAnimation() { var interval = 50; var angle = 10; var heart = new Array(); var animationTimer = setInterval(function () { var bloom = getHeartPoint(angle); var draw = true; for (var i = 0; i < heart.length; i++) { var p = heart[i]; var distance = Math.sqrt(Math.pow(p[0] - bloom[0], 2) + Math.pow(p[1] - bloom[1], 2)); if (distance < Garden.options.bloomRadius.max * 1.3) { draw = false; break; } } if (draw) { heart.push(bloom); garden.createRandomBloom(bloom[0], bloom[1]); } if (angle >= 30) { clearInterval(animationTimer); showMessages(); } else { angle += 0.2; } }, interval); } (function($) { $.fn.typewriter = function() { this.each(function() { var $ele = $(this), str = $ele.html(), progress = 0; $ele.html(''); var timer = setInterval(function() { var current = str.substr(progress, 1); if (current == '","link":"/about/js/functions_dev.js"},{"title":"","text":"function Vector(a,b){this.x=a;this.y=b}Vector.prototype={rotate:function(b){var a=this.x;var c=this.y;this.x=Math.cos(b)*a-Math.sin(b)*c;this.y=Math.sin(b)*a+Math.cos(b)*c;return this},mult:function(a){this.x*=a;this.y*=a;return this},clone:function(){return new Vector(this.x,this.y)},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},subtract:function(a){this.x-=a.x;this.y-=a.y;return this},set:function(a,b){this.x=a;this.y=b;return this}};function Petal(a,f,b,e,c,d){this.stretchA=a;this.stretchB=f;this.startAngle=b;this.angle=e;this.bloom=d;this.growFactor=c;this.r=1;this.isfinished=false}Petal.prototype={draw:function(){var a=this.bloom.garden.ctx;var e,d,c,b;e=new Vector(0,this.r).rotate(Garden.degrad(this.startAngle));d=e.clone().rotate(Garden.degrad(this.angle));c=e.clone().mult(this.stretchA);b=d.clone().mult(this.stretchB);a.strokeStyle=this.bloom.c;a.beginPath();a.moveTo(e.x,e.y);a.bezierCurveTo(c.x,c.y,b.x,b.y,d.x,d.y);a.stroke()},render:function(){if(this.r","link":"/about/js/garden.js"},{"title":"","text":"function Vector(x, y) { this.x = x; this.y = y; }; Vector.prototype = { rotate: function (theta) { var x = this.x; var y = this.y; this.x = Math.cos(theta) * x - Math.sin(theta) * y; this.y = Math.sin(theta) * x + Math.cos(theta) * y; return this; }, mult: function (f) { this.x *= f; this.y *= f; return this; }, clone: function () { return new Vector(this.x, this.y); }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y); }, subtract: function (v) { this.x -= v.x; this.y -= v.y; return this; }, set: function (x, y) { this.x = x; this.y = y; return this; } }; function Petal(stretchA, stretchB, startAngle, angle, growFactor, bloom) { this.stretchA = stretchA; this.stretchB = stretchB; this.startAngle = startAngle; this.angle = angle; this.bloom = bloom; this.growFactor = growFactor; this.r = 1; this.isfinished = false; //this.tanAngleA = Garden.random(-Garden.degrad(Garden.options.tanAngle), Garden.degrad(Garden.options.tanAngle)); //this.tanAngleB = Garden.random(-Garden.degrad(Garden.options.tanAngle), Garden.degrad(Garden.options.tanAngle)); } Petal.prototype = { draw: function () { var ctx = this.bloom.garden.ctx; var v1, v2, v3, v4; v1 = new Vector(0, this.r).rotate(Garden.degrad(this.startAngle)); v2 = v1.clone().rotate(Garden.degrad(this.angle)); v3 = v1.clone().mult(this.stretchA); //.rotate(this.tanAngleA); v4 = v2.clone().mult(this.stretchB); //.rotate(this.tanAngleB); ctx.strokeStyle = this.bloom.c; ctx.beginPath(); ctx.moveTo(v1.x, v1.y); ctx.bezierCurveTo(v3.x, v3.y, v4.x, v4.y, v2.x, v2.y); ctx.stroke(); }, render: function () { if (this.r","link":"/about/js/garden_dev.js"},{"title":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(\"left\")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:\"script\"}):c.globalEval(b.text||b.textContent||b.innerHTML||\"\");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===\"object\"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o\\s]+\\/)>/g,'=\"$1\">').replace(V,\"\")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find(\"*\"),b.find(\"*\"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja, \"\"):null;else if(typeof a===\"string\"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]); return this}else{e=0;for(var j=d.length;e0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement===\"undefined\")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i===\"number\")i+=\"\";if(i){if(typeof i===\"string\"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i===\"string\"){i=i.replace(Ka,Ma);var o=(La.exec(i)||[\"\", \"\"])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement(\"div\");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o===\"table\"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]===\"\"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],\"tbody\")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e= c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],\"script\")&&(!e[j].type||e[j].type.toLowerCase()===\"text/javascript\"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName(\"script\"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]? c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\\([^)]*\\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\\d+(?:px)?$/i,nb=/^-?\\d/,ob={position:\"absolute\",visibility:\"hidden\",display:\"block\"},pb=[\"Left\",\"Right\"],qb=[\"Top\",\"Bottom\"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?\"cssFloat\":\"styleFloat\",ja= function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e===\"number\"&&!kb.test(f))e+=\"px\";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b===\"width\"||b===\"height\")&&parseFloat(d)=0?parseFloat(Oa.exec(f.filter)[1])/100+\" \":\"\"}if(ha.test(b))b=\"Pa;b=b.replace(ia,ja);if(e)f[b]=d;return\" f[b]},css:function(a,b,d,f){if(b=\"==\" width\"||b=\"==\"height\"){var\"\" e,j=\"b===\" width\"?pb:qb;function\"=\"\" i(){e=\"b===\" width\"?a.offsetwidth:a.offsetheight;f!=\"=\"border\"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,\"padding\"+this,true))||0);if(f===\"margin\")e+=parseFloat(c.curCSS(a,\"margin\"+this,true))||0;else\"\" e-=\"parseFloat(c.curCSS(a,\" \"border\"+this+\"width\",true))||0})}a.offsetwidth!=\"=0?i():c.swap(a,ob,i);return\" math.max(0,math.round(e))}return=\"\" c.curcss(a,b,d)},curcss:function(a,b,d){var=\"\" f,e=\"a.style;if(!c.support.opacity&&b===\" opacity\"&&a.currentstyle){f=\"Oa.test(a.currentStyle.filter||\"\")?parseFloat(RegExp.$1)/100+\"\":\"\";return\"\" if(rb){if(ha.test(b))b=\"float\" ;b=\"b.replace(lb,\" -$1\").tolowercase();e=\"a.ownerDocument.defaultView;if(!e)return\"\" null;if(a=\"e.getComputedStyle(a,null))f=\" a.getpropertyvalue(b);if(b=\"==\" opacity\"&&f=\"==\"\")f=\"1\"}else\"\" if(a.currentstyle){d=\"b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var\" j=\"a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d===\" fontsize\"?\"1em\":f||0;f=\"e.pixelLeft+\"px\";e.left=b;a.runtimeStyle.left=j}}return\"\" f},swap:function(a,b,d){var=\"\" e=\"\" in=\"\" b){f[e]=\"a.style[e];a.style[e]=b[e]}d.call(a);for(e\" b)a.style[e]=\"f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var\" b=\"a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()===\" tr\";return\"=\"\">0&&d>0&&!f?false:c.curCSS(a,\"display\")===\"none\"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=//gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\\?(&|$)/,ka=/\\?/,wb=/(\\?|&)_=.*?(&|$)/,xb=/^(\\w+:)?\\/\\/([^\\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!== \"string\")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(\" \");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f=\"GET\";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===\"object\"){b=c.param(b,c.ajaxSettings.traditional);f=\"POST\"}var j=this;c.ajax({url:a,type:f,dataType:\"html\",data:b,complete:function(i,o){if(o===\"success\"||o===\"notmodified\")j.html(e?c(\"\").append(i.responseText.replace(tb,\"\")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this}, serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:\"GET\",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,\"script\")},getJSON:function(a,b,d){return c.get(a,b,d,\"json\")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:\"POST\",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href, global:true,type:\"GET\",contentType:\"application/x-www-form-urlencoded\",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!==\"file:\"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(a){}},accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",script:\"text/javascript, application/javascript\",json:\"application/json, text/javascript\",text:\"text/plain\",_default:\"*/*\"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&& e.success.call(k,o,i,x);e.global&&f(\"ajaxSuccess\",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f(\"ajaxComplete\",[x,e]);e.global&&!--c.active&&c.event.trigger(\"ajaxStop\")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!==\"string\")e.data=c.param(e.data,e.traditional);if(e.dataType===\"jsonp\"){if(n===\"GET\")N.test(e.url)||(e.url+=(ka.test(e.url)? \"&\":\"?\")+(e.jsonp||\"callback\")+\"=?\");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+\"&\":\"\")+(e.jsonp||\"callback\")+\"=?\";e.dataType=\"json\"}if(e.dataType===\"json\"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||\"jsonp\"+sb++;if(e.data)e.data=(e.data+\"\").replace(N,\"=\"+j+\"$1\");e.url=e.url.replace(N,\"=\"+j+\"$1\");e.dataType=\"script\";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType===\"script\"&&e.cache===null)e.cache=false;if(e.cache=== false&&n===\"GET\"){var r=J(),u=e.url.replace(wb,\"$1_=\"+r+\"$2\");e.url=u+(u===e.url?(ka.test(e.url)?\"&\":\"?\")+\"_=\"+r:\"\")}if(e.data&&n===\"GET\")e.url+=(ka.test(e.url)?\"&\":\"?\")+e.data;e.global&&!c.active++&&c.event.trigger(\"ajaxStart\");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType===\"script\"&&n===\"GET\"&&r){var z=s.getElementsByTagName(\"head\")[0]||s.documentElement,C=s.createElement(\"script\");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B= false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState===\"loaded\"||this.readyState===\"complete\")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader(\"Content-Type\",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader(\"If-Modified-Since\", c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader(\"If-None-Match\",c.etag[e.url])}r||x.setRequestHeader(\"X-Requested-With\",\"XMLHttpRequest\");x.setRequestHeader(\"Accept\",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+\", */*\":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger(\"ajaxStop\");x.abort();return false}e.global&&f(\"ajaxSend\",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q===\"abort\"){E|| d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q===\"timeout\")){E=true;x.onreadystatechange=c.noop;i=q===\"timeout\"?\"timeout\":!c.httpSuccess(x)?\"error\":e.ifModified&&c.httpNotModified(x,e.url)?\"notmodified\":\"success\";var p;if(i===\"success\")try{o=c.httpData(x,e.dataType,e)}catch(v){i=\"parsererror\";p=v}if(i===\"success\"||i===\"notmodified\")j||b();else c.handleError(e,x,i,p);d();q===\"timeout\"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x); g(\"abort\")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g(\"timeout\")},e.timeout);try{x.send(n===\"POST\"||n===\"PUT\"||n===\"DELETE\"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger(\"ajaxError\",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol===\"file:\"||a.status>=200&&a.status=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName===\"parsererror\"&&c.error(\"parsererror\");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a===\"string\")if(b=== \"json\"||!b&&f.indexOf(\"json\")>=0)a=c.parseJSON(a);else if(b===\"script\"||!b&&f.indexOf(\"javascript\")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\\[\\]$/.test(i)?f(i,n):d(i+\"[\"+(typeof n===\"object\"||c.isArray(n)?k:\"\")+\"]\",n)});else!b&&o!=null&&typeof o===\"object\"?c.each(o,function(k,n){d(i+\"[\"+k+\"]\",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+\"=\"+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional; if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join(\"&\").replace(yb,\"+\")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\\d+-.]+)(.*)$/,W,va=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K(\"show\",3),a,b);else{a=0;for(b=this.length;a-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||\"px\";this.now=this.start; this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop===\"width\"||this.prop===\"height\"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now= this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,\"olddisplay\");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,\"display\")===\"none\")this.elem.style.display=\"block\"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem, e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?\"swing\":\"linear\");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b\"; a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position=\"fixed\";f.style.top=\"20px\";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top=\"\";d.style.overflow=\"hidden\";d.style.position=\"relative\";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b); c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,\"marginTop\",true))||0;d+=parseFloat(c.curCSS(a,\"marginLeft\",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,\"position\")))a.style.position=\"relative\";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,\"top\",true),10)||0,i=parseInt(c.curCSS(a,\"left\",true),10)||0;if(c.isFunction(b))b=b.call(a, d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};\"using\"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,\"marginTop\",true))||0;d.left-=parseFloat(c.curCSS(a,\"marginLeft\",true))||0;f.top+=parseFloat(c.curCSS(b[0],\"borderTopWidth\",true))||0;f.left+=parseFloat(c.curCSS(b[0],\"borderLeftWidth\",true))||0;return{top:d.top- f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,\"position\")===\"static\";)a=a.offsetParent;return a})}});c.each([\"Left\",\"Top\"],function(a,b){var d=\"scroll\"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?\"pageXOffset\"in j?j[a?\"pageYOffset\": \"pageXOffset\"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each([\"Height\",\"Width\"],function(a,b){var d=b.toLowerCase();c.fn[\"inner\"+b]=function(){return this[0]?c.css(this[0],d,false,\"padding\"):null};c.fn[\"outer\"+b]=function(f){return this[0]?c.css(this[0],d,false,f?\"margin\":\"border\"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return\"scrollTo\"in e&&e.document?e.document.compatMode===\"CSS1Compat\"&&e.document.documentElement[\"client\"+b]||e.document.body[\"client\"+b]:e.nodeType===9?Math.max(e.documentElement[\"client\"+b],e.body[\"scroll\"+b],e.documentElement[\"scroll\"+b],e.body[\"offset\"+b],e.documentElement[\"offset\"+b]):f===w?c.css(e,d):this.css(d,typeof f===\"string\"?f:f+\"px\")}});A.jQuery=A.$=c})(window);","link":"/about/js/jquery.js"}],"posts":[{"title":"90后的他月薪4000，存款百万！，为什么？","text":"他叫阿彪（化名），来自河南某十八线小县城。2014年，大专毕业的他独自来到北京开始了北漂生涯。 住的是空气中都透着霉味的狭窄到只能容纳一张板床的小破房 干过销售，送过快递，受过白眼，尝尽疾苦与无奈。 这不是他想要的生活，他觉得他的人生应当有更多可能。 于是 他回到了熟悉的小县城 继承了他爸的百万遗产 ![](https://img.116s.com/2016-08/28/14723594920005.jpg)","link":"/2019/01/30/90后的他月薪4000，存款百万！，为什么？/"},{"title":"【数据结构】树","text":"树的基本概念树的定义：前面所提到的线性结构的元素是一种一对一的关系，而树是一种一对多的非线性结构，下面将通过一个具体的树的例子讲解到底什么样的结构才是树以 及树的一些相关术语： 上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵空树。结点：上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；结点的度：该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；树的度：树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；叶子结点：又称为终端结点，指的是度为零的结点非终端结点：又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为内部结点。祖先：从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：A和B，因为路径为：A—B—E；层次：根处为第一层，以此类推……，如上图树的层次为4层；结点的深度和高度：联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；有序树：树中结点的子树从左到右都是有次序的不能交换无序树：树中结点的子树没有次序，可以任意交换丰满树：理想的平衡树，要求除了最底层外，其他层都是满的森林：若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林 树的存储结构 顺序存储：双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法) 链式存储：孩子存储结构（孩子表示法）孩子兄弟存储结构（孩子兄弟表示法） 二叉树 二叉树的五种基本形式 满二叉树的概念 完全二叉树的概念二叉树的几个重要性质 性质一：非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$； 性质二：二叉树的第$i$层上最多有$2^{i-1}$; 性质三：高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$. 性质四：该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述； 性质五：函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\\frac{1}{n+1}×C_{2n}^n$ ; 性质六：具有$n$个结点的完全二叉树的高度（或深度）为$[\\log_2{n}]+1$(向下取整)； 二叉树的存储结构 顺序存储结构：用一个数组来存储完全二叉树，将完全二叉树的结点值按编号依次存入一个一维数组中。 如果要从一维数组中还原二叉树的本来结构，按照以下规则：$i$ 为某结点的编号，若$i\\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；如果$2i\\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；如果$2i+1 \\leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；下面给出将数组还原成二叉链树的代码：void creatBTree(int BT[],int n,BTNode *&amp;e){ BTNode *BTNode_array[maxsize]; for(int i = 1;i &lt;= n;++i ){ BTNode_array[i] = (BTNode*)malloc(sizeof(BTNode)); BTNode_array[i] -&gt; data = BT[i]; BTNode_array[i] -&gt; lchild = NULL; BTNode_array[i] -&gt; rchild = NULL; } for (int i = 1;i &lt;= n;++i){ if(2*i &lt;= n ){ BTNode_array[i] -&gt; lchild = BTNode_array[2*i]; } if((2*i+1) &lt;= n){ BTNode_array[i] -&gt; rchild = BTNode_array[2*i+1]; } } e = BTNode_array[1];} 链式存储结构：为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：typedef struct BTNode{ int data; //数据域 struct BTNode *lchild;//指向左孩子的指针 struct BTNode *rchild;//指向右孩子的指针}; 二叉树的遍历算法(递归实现)：深度优先遍历： 前序遍历： void preorder(BTNode *p){ if(p != NULL){ Visit(p); preorder(p -&gt; lchild); preorder(p -&gt; rchild); }} 中序遍历： void inorder(BTNode *p){ if(p != NULL){ inorder(p -&gt; lchild); Visit(p); inorder(p -&gt; rchild); }} 后序遍历： void postorder(BTNode *p){ if(p != NULL){ postorder(p -&gt; lchild); postorder(p -&gt; rchild); Visit(p); }} 广度优先遍历： 算法流程图解：void level (BTNode *p){ if(p != NULL){ BTNode *que[maxsize]; int front = 0; int rear = 0; BTNode *q; rear = (rear + 1)%maxsize; que[rear] = p; while(front != rear){ front = (front + 1)%maxsize; q = que[front]; Visit(q); if(q -&gt; lchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; lchild; } if(q -&gt; rchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; rchild; } } }} 二叉树的遍历算法(非递归实现) 上图而查处将作为例子方便讲解下面的算法 深度优先遍历算法： 先序遍历： void preorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; Stack[++top] = bt; while(top != NULL){ p = Stack[top--]; Visit(p); if(p -&gt; rchild != NULL){ Stack[++top] = p -&gt; rchild; } if(p -&gt; lchild != NULL){ Stack[++top] = p -&gt; lchild; } } }} 后序遍历：先序遍历算法遍历例子二叉树将得到：A B D E C F G后序遍历例子二叉树：D E B F G C A将后序遍历序列逆置：A C G F B E D可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。 void postorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode Stack1[maxsize]; BTNode Stack2[maxsize]; int top1 = -1; int top2 = -1; BTNode *p = NULL; Stack1[++top1] = bt; while(top1 != -1){ p = Stack1[top--]; Stack2[++top] = p; if(p -&gt; lchild != NULL){ Stack1[++top] = p -&gt; lchild; } if(p -&gt; rchild != NULL){ Stack1[++top] = p -&gt; rchild; } } while(top2 != -1){ p = Stack2[top--]; Visit(p); } }} 中序遍历： void inorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; p = bt; while(top != -1 || p != NULL){ while(p -&gt; lchild != NULL){ Stack[++top] = p; p = p -&gt; lchild; } if(top != -1){ p = Stack[top--]; Visit(p); p = p -&gt; rchild; } } }} 线索二叉树 对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。 线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。线索二叉树的构造：结点定义： typedef struct TBTNode{ int data; // 数据域 struct TBTNode *lchild; // 左孩子（前驱结点）指针 struct TBTNode *rchild; // 右孩子（后继结点）指针 int ltag , rtag; //线索标记}; 根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。通过中序遍历对二叉树线索化代码： void InThread(TBTNode *p,TBTNode *&amp;pre){ if(p != NULL){ InThread(p -&gt; lchild,pre); // 递归地线索化左子树 if(p -&gt; lchild == NULL){ // 建立当前结点前驱线索 p -&gt; lchild = pre; p -&gt; ltag = 1; } if(pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ // 建立前驱结点的后继线索 pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; // pre 跟上 p，之后p会指向下一个结点 InThread(p -&gt; rchild,pre); // 递归地线索化右子树 }} 通过中序遍历线索二叉树的主程序如下：void creatTBTNode(TBTNode *root){ TBTNode *pre = NULL; if(root != NULL){ InThread(root,pre); //递归建立线索二叉树 pre -&gt; rchild = NULL; // 处理最后一个结点 pre -&gt; rtag = 1; }} 遍历中序线索二叉树：寻找中序线索二叉树 root 的第一个遍历结点：TBTNode *First(TBTNode *root){ while( root -&gt; ltag == 0){ root = root -&gt; lchild; } return root;} 在中序线索二叉树中，求结点p在中序下的后继结点的算法：TBTNode *Next(TBTNode *p){ if(p -&gt; rtag == 0){ return First(p -&gt; rchild); } else return p -&gt; rchild; // rtag = 1; 直接返回后继线索} 在中序线索二叉树上执行中序遍历：void Inoreder(TBTNode *root){ for (TBTNode *p = First(root);p != NULL;p = Next(p)){ Visit(p); }} 通过前序遍历对二叉树线索化void preInThread(TBTNode *p,TBTNode *&amp;pre){ if (p != NULL){ if(p -&gt; lchild != NULL){ p -&gt; lchild = pre; p -&gt; ltag = 1; } if (pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; if (p -&gt; ltag == 0){ preThread(p -&gt; lchild,pre); } if (p -&gt; rtag == 0){ preThread(p -&gt; rchild,pre); } }} 遍历前序线索二叉树算法：void preorder(TBTNode *root){ if(root != NULL){ TBTNode *p = root; while(p != NULL){ while(p -&gt; ltag == 0){ Visit(p); p = p -&gt; lchild; } Visit(p); p = p -&gt; rchild; } }} 树与森林的互相转换 树与二叉树的应用 二叉排序树与二叉平衡树 赫夫曼树与赫夫曼编码 赫夫曼树的相关概念及介绍：赫夫曼树又被称为最优二叉树，它的特点是带权路径最短。下面介绍几个相关概念： 路径：指从树中一个结点到另一个结点的分支所构成的路线 路径长度：路径上的分支数目 树的路径长度：从根到每个结点的路径长度之和 带权路径长度：结点具有权值，从该结点到根结点的路径长度乘于该结点的权值就是该结点的带权路径长度 树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和 赫夫曼树的构造方法：给定$n$个权值，用这些个权值来构造赫夫曼树：首先了解一下赫夫曼树的一些特点： 权值越大的结点距离根节点越近 树中没有度为1的结点 树的带权路径长度最短 根据上述特点反推我们是如何来构造一个赫夫曼树： 从最底层开始构造 最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点 权值最大的结点离根节点最近 有了上述导论我们就可以开始构造一棵赫夫曼树了：上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。 赫夫曼编码： * 利用赫夫曼树的特点来对文件进行压缩存储 看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$选三位长度的二进制数为A到E编码：根据上表我们可以将该字符串编码为：$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$解码时每三位一个字符解码总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？ 答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：到此我们得到了对A到E的霍夫曼编码规则：根据上表的编码规则可将字符串编码为：$1110010101101011110011110101010110111000011001011111111110110$只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。 解码霍夫曼编码：解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。 [注] 对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的 霍夫曼$n$叉树 霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例 构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。","link":"/2019/03/05/BinaryTree/"},{"title":"Hexo+icarus主题配置","text":"下载icarus主题 进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面 输入： git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 打开themes文件夹，就会发现多了一个icarus文件夹，这就是主题的所有文件 配置主题 更改站点配置文件_config.yml,将主题改为icarus theme: icarus Icarus文件目录概览： $config.yml$是主题的配置文件 $/layout$ 文件夹中是主题各种模板文件 我们主要的超作就是在这两个文件中了 主题配置文件（部分）# Version of the Icarus theme that is currently usedversion: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 上述设置已经让你的博客稍微有点属于你的样子了，下面来添加一些有意思的元素。 添加雪花飘落效果 在 $\\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$目录下新建一个 snow.js 文件(若没有src/文件夹可以自己新建)，复制粘贴以下代码： 样式1：六边形雪花 (function($){ $.fn.snow = function(options){ var $flake = $('').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('❄'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = { minSize : 10, maxSize : 20, newOn : 1000, flakeColor : \"#AFDAEF\" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ }, options = $.extend({}, defaults, options); var interval= setInterval( function(){ var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css({ left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor }).animate({ top: endPositionTop, left: endPositionLeft, opacity: 0.2 },durationFall,'linear',function(){ $(this).remove() }); }, options.newOn); };})(jQuery);$(function(){ $.fn.snow({ minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ });});作者：donlex链接：http://www.imooc.com/article/272005 样式2：圆点状雪花 function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / 60); };cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){ /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)}/* 创建画布 */function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function() { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */}flakeMove.prototype.update = function() { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) { this.velY = this.speed } this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) { this.reset(canvas.width, canvas.height) }};/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) { this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;};// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) { var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, \"rgba(255, 255, 255, 0.9)\"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, \"rgba(255, 255, 255, 0.5)\"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, \"rgba(255, 255, 255, 0)\"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();};/* 创建雪花-定义形状 */function createFlakes() { var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) { flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) }}/* 画雪 */function drawSnow() { var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) { flakes[e].update(); flakes[e].render(ctx); } /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() { drawSnow.apply(that); });}/* 调用及控制方法 */var snow = new snowFall({maxFlake:60});snow.start();作者：donlex链接：http://www.imooc.com/article/272005 最后在$\\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$的$body$标签中添加代码： &lt;!-- 雪花特效 --&gt; &lt;script type=\"text/javascript\"&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) { document.write('&lt;script type=\"text/javascript\" src=\"/js/src/snow.js\"&gt;&lt;\\/script&gt;'); } &lt;/script&gt; 默认雪花为白色，可自行更改颜色，效果可见本站 网站访问量与访客量统计 不蒜子官网：http://busuanzi.ibruce.info/ 在$\\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$模板文件的中添加如下代码： &lt;span id=\"busuanzi_container_site_pv\" class=\"theme-info\"&gt; | 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;span&gt;次 span&gt; &lt;span id=\"busuanzi_container_site_uv\" class=\"theme-info\"&gt; | 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;span&gt;人次 span&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;script&gt; 在$\\color{DarkTurquoise}{/themes/icarus/_config.yml}$中添加： busuanzi: enable: true 最终效果： ![](https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429093801600.png) 网站运行时间统计 在$\\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$中添加： &lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(\"12/28/2018 12:49:00\");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = \"0\" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \"0\" + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \"0\" + snum;} document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; } setInterval(\"createtime()\",250); &lt;/script&gt; 修改自己的建站时间 最终效果： ![](https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429094726470.png) 鼠标点击特效 在 $\\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$中添加click.js文件，复制以下代码进去： !function(e,t,a){ function n(){ c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\"); requestAnimationFrame(r) } function o(){ var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(\"div\"); a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(\"style\");a.type=\"text/css\"; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(\"head\")[0].appendChild(a) } function s(){ return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 最后在$\\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$文件中的 &lt;!DOCTYPE html&gt; 的下一行添加： &lt;script src=\"/js/src/click.js\"&gt;&lt;/script&gt; 效果见本站 看板娘插件 在博客主目录下进入点击进入Git Bash Here 输入命令： npm install hexo-helper-live2d --save 在网站配置文件或主题配置文件$\\color{green}{_config.yml}$中添加： live2d: enable: true #开启看板娘 scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-z16 #指定模型任务 display: position: right #显示位置 width: 200 #模型宽度 height: 400 #模型高度 mobile: show: true #是否在移动端显示 效果：见本站 遇到的坑及解决方法 ..公式渲染问题 .. .. $\\color{green}{Waiting....for....update....}$","link":"/2019/04/29/Hexo+icarus主题配置/"},{"title":"Hexo-icarus修改文章详情页","text":"为什么修改？ 由于Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局。但是三栏布局限制了文章内容的展示，因此试图将其改为两栏布局。 通过修改源代码来达成目标打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中：&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动：&lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=\"column &lt;%= col() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码：&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt; 大功告成我这里保存的是左边栏，若要保存右边栏可以在 widget.ejs 文件中更改（已标识）。 效果见本站！","link":"/2019/05/01/Hexo-icarus修改文章详情页/"},{"title":"【工具】HexoEditor编辑器的安装配置及使用","text":"HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。GitHub：HexoEditor Step1: 安装 HexoEditor: 下载链接：Download 支持 Linux 、Windows 、MacOS Step2: 简单设置： [ ] Hexo配置文件选择网站根目录下的_config.yml文件 [ ] Tag模板目录选择网站很目录下的 /scaffolds 文件夹 [ ] 主题随意选择 [ ] 默认资源库可在网站根目录source文件夹内新建文件夹来存放文章图片资源 [ ] 云图类型可默认，SM.MS云图为免费云端，也可自选其他云端服务 Step3:撰写文章： 点击新建Post可生成新的模板文档，开始写作。 在预览试图中右键点击所插入的图片，点击上传至SM.MS可将本地图片上传至云端，之后会发现文章中的图片Path变为URL链接。 Step4:发布文章： * 右键 —&gt; Hexo —&gt; 部署网站","link":"/2018/12/27/HexoEditor/"},{"title":"【教程】Hexo+Github博客搭建","text":"开始 对于萌新来说，Hexo是一个非常容易上手的轻量级博客平台，只需简单的配置便可以打造令人满意的博客页面，下面是我自己搭建博课的流程，在此记录以备后续的需要。 Step1:前期准备: [ ] 安装Node.js : Download [ ] 安装git for win: Download [ ] 注册GitHub账号: Github.com Step2: [ ] 在GitHub中新建（New）一个库（Repositories），用来存放网站内容： Step3:连接git与GitHub账户： 在桌面点击鼠标右键，选择Git Bash Here 会跳出终端窗口输入命令并回车： ssh-keygen 根据路径找到密钥文件并打开： 打开你的GitHub账户点击右上角的头像选择setting —&gt; SSH and GPG keys: 至此，成功连接GIt与GitHub账户。 Step4:*安装Hexo： 在桌面打开Git Bash Here终端输入命令： npm install -g hexo-cli 如果许久后未能安装，说明网络太慢，可更换安装源Ctrl+C，在终端输入：npm config set registry http://registry.cnpmjs.org 安装成功后，在电脑的任意磁盘内建立文件夹以存放Hexo网站： 这是我创建的路径：blog文件夹将被用于博客 进入blog文件夹点击鼠标右键进入Git Bash Here终端，依次执行命令： hexo init //初始化文件夹为博客根目录hexo install //安装必要依赖文件 安装hexo-deployer-git插件： npm install hexo-deployer-git —save 到此，还记得之前创建的GitHub库吗？ 打开该仓库复制仓库的SSH地址： 进入网站根目录/blog,用编辑器（vs code)打开 _config.yml 网站配置文件： 修改_config.yml 配置文件保存并退出： 回到Git终端，执行命令： hexo g -d //将网站部署到GitHub上 至此，可在浏览器内输入你的博客地址查看是否成功： Step5:如何写作： 回到blog文件夹内，/source/_post/ 文件夹内的Markdown文件就是你的博文存放处 你可以新建md文档写作并用hexo g -d 命令将更新的博文部署到网站上 也可以利用HexoEdit编辑器写作并上传，详情可见我的另一篇博文HesoEditor教程 关于Markdown语法网上有许多教程可供学习Markdown中文文档 关于Hexo主题更换配置我会在以后的文章中介绍，若有错误请指明，不甚感激。Thanks for your watching !!!!!!","link":"/2018/12/26/HexoGitHub/"},{"title":"Hexo用MathJax渲染数学公式","text":"更改默认Markdown渲染引擎 Hexo的默认Markdown渲染引擎为hexo-renderer-marked，将其替换为hexo-renderer-kramed,对于这一步，网上的大部分教程是这么干的：npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 也就是先卸载掉默认引擎，再安装新引擎。但是我的npm出了问题，而且我个人觉得npm实在是不好用，因此我下载了yarn，并执行：yarn remove hexo-renderer-markedyarn add hexo-renderer-kramed 但当我执行hexo clean时却出现了类似下面的错误：Error: hexo-renderer-marked is not installed , please install .... 所以一直无法成功。后来我想干脆不卸载marked渲染引擎，直接安装kramed：yarn add hexo-renderer-kramed 安装MathJax卸载hexo-math：yarn remove hexo-math 再安装hexo-renderer-mathjax：yarn add hexo-renderer-mathjax -S 解决行内公式语义冲突在博客的根目录下找到$\\color{red}{node_modules/kramed/lib/rules/inline.js}$做如下两处更改：var inline = { //escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, 第一处 escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, //em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第二处 em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| {2,}\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,}; 更改Mathjax加载脚本找到$\\color{red}{node-modules/hexo-renderer-mathjax/mathjax.html}$将最后一句改为：&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt; 大功告成hexo g -d 将改动部署到博客","link":"/2019/04/30/Hexo用MathJax渲染数学公式/"},{"title":"【数据结构】栈与队列","text":"栈和队列的基本概念 栈的基本概念 栈的定义 只能在一端（栈顶Top）进行插入和删除操作的线性表 栈顶由一个称为栈顶指针的位置指示器top来指示，它是动态变化的 表的另一端栈底是固定不变的 栈的特点 先进先出（ＦＩＬＯ） 栈就如同一个狭窄的死胡同，最先进去的人（元素）只能够最后出来 栈的存储结构 可以用顺序表或者链表来存储栈： a) 顺序栈 b) 链式栈 栈的数学性质 当ｎ个元素以某种顺序进栈，并且可以在任何时候出栈（在满足先进后出的前提下）时，所获得的元素排列的数目Ｎ恰好满足函数 Catalan() 的计算，即： $$ N = { \\dfrac{1} {n+1} }×C\\binom{n} {2n} $$ 队列的基本概念 队列的定义 是一种操作受限的线性表，且只允许在表的一端进行插入，在另一端进行删除操作。 可以插入的一端称为队尾（ｒｅａｒ），可以删除的一端称为队头（ｆｒｏｎｔ） 插入元素称为进队，删除元素称为出队 队列的特点 先进先出（ＦＩＦＯ），就像食堂打饭要排队一样，先来的人先有饭吃 队列的存储结构 可用线性表或者链表来存储队列： a) 顺序队 b) 链队 栈和队列的存储结构、算法与应用 顺序栈的定义 typedef struct SqStack { int data[Maxsize]; //一维数组用来存储数据 int top; // ｔｏｐ指针用来指向栈顶元素,规定top=-1 为栈空，top=Maxsize-1 为栈满} 链栈结点的定义 typedef struct LNode { int data; // 数据域 struct LNode *next; // 指针域}LNode; 顺序队列的定义 typedef struct SqQueue { int data[Maxsize]; //数组存放数据 int front; // 队首指针 int rear; // 队尾指针} 链队的定义a) 链队结点定义： typedef struct LQNode{ int date; //数据域 struct LQNode *next; //指针域 } b) 链队类型定义： // 定义一个只包含两个指针域的结点来存放队头与队尾指针 typedef struct LiQueue{ struct LQNode *front; // 队首指针 struct LQNode *rear; // 队尾指针 } // 链队类型定义 顺序栈 顺序栈的几个关键要素： 三个状态 栈空状态：st.top = -1; 栈满状态：st.top = Maxsize - 1; 非法状态：栈满却继续入栈发生上溢；栈空继续出栈发生下溢； 两个操作 元素进栈：++(st.top); st.data[st.top]=x; 元素出栈：x=st.data[st.top]; —(st.top); 初始化栈：// 初始化一个栈，只需将栈顶指针置为－１即可void initStack(){ int top = -1;} 判断栈空代码：int EmptyStack(SqStack ss){ if (ss.top == -1) return 1; // 栈空返回１； else return 0; // 栈非空返回０；} 进栈代码：#defined Error 0int push(SqStack &amp;ss, int x){ if (ss.top == -1) return Error; // 栈满时返回错误，无法入栈 ss.top++; ss.data[ss.top] = x; // 也可一句话解决： ss.data[++ss.top] = x; return 1; //入栈成功返回１} 出栈代码：int pop(SqStack &amp;ss,int e){ if (ss.top == -1) return Error; // 栈空不能出栈 e = ss.data[ss.top]; --ss.top; // 也可一句话解决： e = ss.data[ss.top--]; return 1;} 【注】:对于自增操作，入++a;总是比a++;的执行效率要高一些，因此在使用二者都可以的情况下优先选择++a; 链栈 以下链栈都由带头结点的链表表示 顺序栈的几个关键要素： 两个状态 栈空状态：lst —&gt; next = NULL; 栈满状态：不存在栈满状态，因为单链表的内存空间是动态分配的 两个操作 元素（由指针ｐ所指）的进栈操作：p -&gt; next = lst -&gt; next; lst -&gt; next = p;//其实 就是头插法建立单链表的操作 出栈操作：s = lst -&gt; next; x = s -&gt; data; lst -&gt; next = s -&gt; next; free(s); //其实就是单链表的删除操作 链栈的初始化代码：// 实际上，链栈的初始化与单链表的初始化并无不同void initLStack(LNode *&amp;lst){ lst = (LNode*)malloc(sizeof(LNode)); //制造一个头结点 lst -&gt; next = NULL; // 将链栈滞空} 判断栈空代码：int isEmpty(LNode lst){ if (lst -&gt; next == NULL) return 1; //栈空返回１； else return 0; // 栈不空返回０；} 进栈代码：int push(LNode &amp;lst,int x){ LNode s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = lst -&gt; next; lst -&gt; next = s; return 1;} 出栈代码：int pop(LNode &amp;lst, int &amp;e){ // 用e返回出栈元素的值 if (lst -&gt; next == NULL) return 0; e = lst -&gt; next -&gt; data; LNode *s = lst -&gt; next; lst -&gt; next = s -&gt; next; free(s); return 1;} 栈的应用 栈的主要应用有： 括号匹配 表达式求值 逆波兰转换算法 括号匹配 算法思想： 扫描整个表达式，判断当前符号是否为括号 如果不是，继续扫描下一个字符 如果是，判断是左括号还是右括号，是左括号将其入栈，是右括号就判断栈是否为空 若栈为空，说明此表达式的右括号多与左夸号 若栈不空则判断当前操作符是否和栈顶操作符匹配，若不匹配说明左右括号不匹配，若匹配则继续判断 下一个操作符。最后，判断栈是否为空，若不空则说明左括号多余右括 号，栈为空说明匹配成功。 initStack(Stack stack){ for (int i ;i&lt;strlen(str);i++){ if (str[i]=='{' || str[i]=='[' || str[i]=='('){ push(stack,str[i]); } else { if (str[i]=='{' &amp;&amp; getTopStack(stack) == '}') pop(stack); if (str[i]=='[' &amp;&amp; getToPStack(stack) == ']') pop(stack); if (str[i]=='(' &amp;&amp; getTopStack(stack) == ')') pop(stack); } } // 最后，若栈空则匹配成功，否则失败 if(isEmpty() == true){ cout &lt;&lt; \"括号匹配成功 ！！！\" &lt;&lt; endl; } else cout &lt;&lt; \"匹配失败 ！！！\" &lt;&lt; endl;} 表达式求值 算法思想： 扫描表达式，当扫描到数时将其推入栈中，当扫描到一个运算符时，将该运算符作用于位于栈顶的两个数上，并将所得结果推入栈中 以下将给出后缀表达式的求值程序 int calcExp(char* exp , Stack s){ int i = 0; while (exp[i] != '\\0'){ // if (exp[i]&gt;='0' &amp;&amp; exp[i]&lt;='9'){ s.push(s , exp[i]-'0'); // 若为数字，推入栈中 } else if(exp[i] == '运算符'){ int m = s.gettop(); // 取栈顶元素后将其出栈 s.pop(); int n = s.gettop(); // 取栈顶元素后将其出栈 s.pop; s.push(s, n[运算符]m); // 将运算结果推入栈中 } i++; // 继续遍历 } return s.top;} 逆波兰转换算法 算法思想： 设立一个栈，存放运算符，初始栈为空，编译程序从左往右扫描中缀表达式，若遇到数字，直接输出，并输出一个空格为两个操作数之间的分隔符； 若遇到运算符，则与栈顶比较，若运算符级别比栈顶级别高则进栈，否则退出栈顶元素并输出，之后输出一个空额作分隔符 所遇到左括号，紧张； 若遇到右括号，则一直退栈粗出知道退出第一个左括号为止 当栈为空时，输出的结果即为后缀表达式 void tranfExp (char* exp , Stack s){ while (exp[i] != '\\0'){ if (exp[i] &gt;= '0' &amp;&amp; exp[i] &lt;= '9'){ // 若为数字，直接输出 } else if (exp[i] == '('){ // 若为左括号，进栈 } else if (exp[i] == ')'){ // 若为右括号，出栈直至第一个左括号 } else if (exp[i] == '运算符'){ // 判断与栈顶元素的优先级大小 if (exp[i] &gt; s.gettop()) s.push(exp[i]); // 优先级大于栈顶运算符，将该运算符进栈 else // 优先级小于栈顶运算符，退出栈顶元素并且输出 while (s.isEmpty() == false) pop();// 把栈中剩余元素全部退出并输出 } }} 顺序队 循环队列 循环队列的基本要素 两个状态： 队空状态：qu.rear = qu.front; 队满状态：(qu.rear+1)%front == qu.front ; 两个操作： 元素x进队操作：qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; 出队操作：qu.front = (qu.front+1)%MaxSize; elem = qu.data[qu.front];//elem 保 存出队的元素 循环队列的基本操作实现 初始化队列算法： void initQueue(Queue &amp;qu){ qu.front = 0; qu.rear = 0; } 判断队空算法： int isQEmpty(Queue qu){ if (qu.front == qu.rear){ return 1; // } return 0; //} 进队算法： int enterQueue(Queue &amp;qu , int x){ if ((qu.rear+1)%MaxSize == front){ cout &lt;&lt; \"队列已满\" &lt;&lt; endl; return 0; } qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; return 1;} 出队算法： int outQueue(Queue &amp;qu , int e){ if (qu.rear == qu.front){ cout &lt;&lt; \"队空无法出队\" &lt;&lt; endl; return 0; } qu.front = (qu.front+1)%MaxSize; e = qu.data[qu.front]; return 1;} 链队采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限 链队的基本要素 两个状态： 队满状态： 不存在队满状态 队空状态：que.rear = NULL || que.front = NULL (两个满足一个即可) 两个操作： 元素q进队操作： 分两种情况 1. 当前队为空：que --&gt; rear = que --&gt; front = q; 2. 当前队不空：que --&gt; rear --&gt; next = p;que --&gt; rear = p; 元素出队操作： s = que —&gt; front; que —&gt; front = s —&gt; next;elem = s —&gt; data; free(s); 链队的基本操作实现1.初始化链队算法：void initLiQueue(LiQueue *&amp;que){ que = (LiQueue*)malloc(sizeof(LiQueue)); que -&gt; rear = NULL; que -&gt; front = NULL; } 2.判断队空算法：int isEmpty(LiQueue que){ if (que.rear = NULL || que.front = NULL){ cout &lt;&lt; \"队列为空\" &lt;&lt; endl; return 1; } return 0;} 3.入队算法：int enterLiQueue(LiQueue &amp;que ， int x){ LQNode* s = (LQNode*)malloc(sizeof(LQNode)); if (isEmpty(que)){ // 若队列为空，进队操作比较特别 que -&gt; front = que -&gt; rear = s; return 1; } else{ que -&gt; rear -&gt; next = s; que -&gt; rear = s; return 1; } return 0;} 4.出队算法：int outLiQueue(LiQueue &amp;que , int &amp;elem){ LQNode* s = que -&gt; front; if (isEmpty()){ cout &lt;&lt; \"队为空，无法出队\" &lt;&lt; endl; return 0; } if (que -&gt; front == que -&gt; rear){ // 若队列只有一个元素，出队操作比较特别 que -&gt; front = NULL; que -&gt; rear = NULL; } que -&gt; front = s -&gt; next; elem = s -&gt; data; free(s); return 1;}","link":"/2019/03/10/QueueStack/"},{"title":"【数据结构】 字符串","text":"串的定义 // 通常用一个字符数组来表示char str[] = \"hello\";// 数组str内存储的字符为{'h','e','l','l','o','\\0'} ,故有6个数组元素，其中'\\0'是串的结束标志，告知编译器串结束了。// 但是串str的长度为5，“hello”， 【注】以上定义方式一般不用，因为用该方式单纯以 ‘\\0’ 结尾的串如果要得到字符串的长度较为麻烦（需要遍历整个串，时间复杂度为O(n)，故一般情况下我们用自己定义的结构体来定义串，下面会谈到。 【注】空格也是串中的元素，由一个或多个空格组成的串称为空格串，空格串不是“空串”。 串的逻辑结构与线性表类似，串是限定了元素为字符的线性表。但从操作对象上来说，串与线性表有着很大的不同：线性表的主要操作对象是单个元素，而串的主要操作对象是该串的一个“子串”。 串的存储结构 1. 定长顺序存储表示：typedef struct Str{ char str[maxsize+1]; // 用来存放字串的字符数组，maxsize 为字符串最大长度，maxsize+1为数组最大长度，+1 用于存储 '\\0'. int length; // 字符串长度，可用Str.length方法直接访问 length &lt;= maxsize;} 2. 动态分配存储表示：typedef struct LStr{ char *ch; // 指向malloc();动态分配存储区的首地址的指针 int length; // 字符串长度} 串的基本操作 1. 赋值操作：int strassign(LStr&amp; str,char* ch){ // 需返回的变量带引用符号&amp; if (str.ch){ free(str.ch); // 释放原有空间 } int len = 0; char *c = ch; while(c){ // 计算ch的长度 ++len; ++c; } if (len == 0 ){ str.ch = NULL; // 如果ch为空，则直接返回一个空的串 str.len = 0; return 1; } else { str.ch = (char*)malloc(sizeof(char)*(str.len+1)); // 用malloc函数分配一块连续的存储空间，str.len+1是为了容纳'\\0' if (str.ch == NULL) { return 0; //分配失败 } else { c = ch; for (int i = 0; i &lt;= len;i++){ //遍历并赋值 str.ch[i] = *c; // *c 表示c指针所指的位置的值 ++c; // c指针指向下一个位置 } str.len = len; // 被赋值的串长度等于ch的串长 } } return 1; // successfully} 2. 取串长度操作：int StrLength(LStr str){ // 有给串长度信息的情况： return str.len; // 返回str串的长度 //在没有给出串长度信息的情况下： int len = 0; char = *c; c = str.ch; while(c){ ++len; ++c; } return len;} 串的比较操作：int strCompare(LStr str1,LStr str2){ //啰嗦版: for (int i = 0;i &lt; str1.len &amp;&amp; i &lt; str2.len){ if(str1.ch[i] - str2.ch[i] == 0) i++; else if(str1.ch[i] - str2.ch[i] &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else { cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } } if (str1.len - str2.len &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else if (str1.len - str2.len &lt; 0){ cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } else cout &lt;&lt; \"str1 = str2\" &lt;&lt; endl; return 1; // 简洁版： for (int i = 0; i &lt; str1.len &amp;&amp; i &lt; str2.len ;i++){ if (str1.ch[i] != str2.ch[i]){ return str1.ch[i] - str2.ch[i]; } return str1.len - str2.len; }} 4. 串的连接操作：int concat(LStr &amp;str,LStr str1,LStr str2){ // 将两个字符串连接并用一个新的字符串str返回 if(str.ch) { // 清除原有空间 free(str.ch); str.ch = NULL; str.len = 0; } str.ch = (char*)malloc(sizeof(char)*(str1.len+str2.len+1)); // 分配连续空间，+1是为了多分配一个位置空间存放‘\\0’ int i = 0; while(i &lt; str1.len){ // 插入str1; str.ch[i] = str1.ch[i]; ++i; } int j = 0; while(j &lt;= str2.len){ // 插入str2，注意这里用\"&lt;=\"是为了吧'\\0' 也加到末尾 str.ch[i+j] = str2.ch[j]; ++j; } str.len = str1.len + str2.len; // 更新字符串长度 return 1; // 成功连接} 5. 求子串操作：int subStr(LStr &amp;substr,LStr str,int pos,int len){ if (pos + len &gt; str.len || pos &lt; 0 || len &lt; 0 || pos &gt;= str.len){ return 0; //判断输入是否合法 } if (substr.ch){ // 清空原空间 free(substr.ch); substr.ch = NULL; } if (len == 0){ // 若子串长度为0.直接返回空子串 substr.ch = NULL; substr.len = 0; return 1; } else{ substr.ch = (char*)malloc(sizeof(char)*(len+1)); // 分配连续的内存空间 int i = 0; int j = pos; while(i&lt;len){ // 从pos处开始遍历并赋值给子串 substr.ch[i] = str.ch[j]; ++i; ++j; } substr.ch[i] = '\\0'; // 这个千万别忘了加进去 substr.len = len; // 更新子串长度 return 1; // 成功 }} 串的清空操作：// 串的清空操作在上诉各函数中均有用到int clearStr(LStr &amp;str){ if (str.ch){ free(str.ch); str.ch = NULL; } str.len = 0; return 1;} 串的模式匹配算法(重点)何为模式匹配： 对一个串中某子串的定位操作称为串的模式匹配，其中待匹配的子串称为“模式串”。串的模式匹配算法分为： 简单模式匹配算法 KMP算法 1. 简单模式匹配算法： 算法思想： 从主串的第一个位置起开始遍历字符串，若该字符与模式串的第一个字符相同，则继逐一比较后续字符， 否则从主串的下一个位置开始，重复上一步操作，以此类推，直到比较完模式串的所有字符。若匹配成 功，返回模式串在主串中的位置。匹配失败 ……,随便你想咋样。int subStr_Match(Lstr str,LStr substr){ if (substr.ch == NULL || str.ch == NULL){ return 0; } int i ,j , pos = 0; for (i = 0 , j = 0;i &lt; str.len &amp;&amp; i &lt; substr.len; ){ if (str.ch[i] == substr.ch[j]){ ++j; ++i; } else { j = 0; // 匹配失败，j 重新指向模式串起始位置 i = ++pos; // pos 记录上一次匹配的起始位置，在匹配失败后将i指向上一轮匹配的初始位置pos的后面一个位置++pos开始新一轮匹配 } } if (j &gt;= substr.len){ return pos; // 匹配成功，返回模式串在主串中的位置 } return 0;} KMP算法： 算法思想解析 : 上述的匹配算法称为“简单模式匹配算法（BF）”，其时间复杂度为O(mn),其中m为主串长度，n为模式串长度。由此可知简单模式匹配算法虽然易于理解但是效率很低，无法满足当已知数据异常庞大时的效率要求。所以就诞生了接下来登场的KMP算法。 我们知道，在BF算法中每次发生不匹配i与j都要回溯到该轮匹配的初始位置，并且在回溯之后的后几次匹配同样有可能导致（不必要的）不匹配状态，这是导致算法效率低下的主要原因，那么如何直接跳过这些不必要的不匹配状态而直接到达可能解决不匹配位置的的状态呢？ 解决办法就是利用匹配失败后的信息，那么如何利用呢？ 为了使问题变得更加直观，我们假想匹配过程就是模式串在主串上的移动(实际上并不会移动，全是指针在变化)，如果在某一次匹配时在模式串的第j位置发生了不匹配（j位置前的所有元素都已匹配成功），如果照着BF算法来做，我们会抛弃掉j位置前的匹配“成果”直接将i与j回溯重新开始下一轮比较。但现在我们不这么做，因为我们完全可以将j之前的匹配成果利用起来 不不妨假设模式串为“ABABABB”，并且该模式串在与主串的一次匹配流程中第4个元素B与主串发生了不匹配，很显然这个时候主串i位置前的三个元素跟模式串是完全匹配的，为了利用这个成果，就是在模式串向后移动后尽可能地保留这些匹配成果，我们观察这三个元素“ABA”的特点，发现他的前缀与后缀出现了相同的字符序列“A”，这时候我们应该意识到，要时上一次的成果得到最大限度的保留，我们只能将模式串移动到前缀与后缀重合的状态，这样子就保留了一个匹配成果“A“，同时i根本就不需要回溯（原地不动就好），因为i无需从模式串头部重新开始与其匹配，而只需从保留的成果后开始匹配也就是模式串的第二个位置（A的后一个位置）开始匹配。 但问题又来了，怎么知道模式串该怎么移动呢，从上面的分析我们发现，对于模式串移动的分析完全没有涉及到主串，那我们是怎么做到视主串而不见的呢(它可是”主“串啊给点面子好不好)。事实上，我们用到他了，因为我们的假设是”j位置前的元素与主串完全匹配“，竟然这样那么不就说明j位置前的模式串部分与主串的那一部分完全一样吗，所以我们可以用一个所谓”假模式串“来代替主串，而模式串只要在这个”傀儡身上移动就好了。所以，模式串在哪个位置与主串发生不匹配后模式串应该怎么移动，这个问题就可以脱离主串而背单独拿出来分析了，这就是后面要谈到的next数组（用与存放当j位置发生不匹配时，j指针应该重新调整到那个位置上）。有了next数组，我们就可以知道当模式串在J处与主串发生不匹配之后，为了最大限度地保留之前的匹配成果，模式串该怎么移动（指针该怎么变化）。 KMP算法代码：int KMP (LStr str,LStr substr,int next[]){ // 函数接受主串，模式串，next数组 int i = 1 ,j = 1; // i 扫描主串，j 扫描模式串 for (i &lt; str.len &amp;&amp; i &lt; substr.len){ if (j == 0 || str.ch[i] == substr.ch[j]){ // j=0;的情况就是模式串中的第一个字符与主串中的第i个字符不匹配，应从// 主串的下一个位置与模式串的第一个位置继续比较，故++i(主串的下一个位置);// ++j(模式串第一个位置0+1=1(很强)) ++j; ++i; } else { j = next[j]; // j 被调整到合适位置，这里的i不需要回朔，这也是KMP算法的一大特点 } } if (j &gt;= substr.len){ // j 的长度超过了模式串，显然匹配成功 return i - substr.len; // 匹配成功，返回模式串在主串中的位置 } return 0;} next数组的求法: 经过前面的分析我们知道，只需要模式串本身我们就可以求出next数组，并不需要主串的参与。所以我们可以定义一个函数将next数组一次性求出，从此一劳永逸…… 这里我们要用到一个算法思想，那就是递推,我们知道数列就是一种有着递推关系的数的序列。现在假设等差数列{An},给你一个递推公式(实际上就是前一个元素与后一个元素的关系)：A(n+1) = An + 1;其中n={1,2,3,…}然后告诉你第一个元素A1 = 0(实际上告诉你任何一个位置上的元素值都可以); 有了这两个已知条件你可以知道这个数列的所有元素就是非负整数集{0,1,2,3, …}。 那我们如何在求解next数组上面应用这个思想呢？ 首先看看我们有什么已知条件？ 显然我们需要知道两个相邻状态Sk与Sk+1之间的关系，假设模式串为p1～pm，问题转化为两个模式串之间的匹配问题。如果在Sk时，已经求得了next[j] = t；若要求得Sk+1状态的next[j+1]，我们需要分两种状态来考虑： 若Pj = Pt；则next[j+1] = t+1; 若Pj != pt;这时候就又回到了我们讨论模式串与主串匹配出现匹配失败的经典情形了，不匹配发生在t处，我们应该去查next数组看看t应该怎样调整位置了，显然next[t]我们已经求得了，所以令t = next[t],继续比较pj与pt，若不相等重复第二种情况，直到t = 0;或者pj = pt 满足第一种情况，从而求得next[j+i]; next求数组代码:void getNext(LStr substr,int next[]){ int j = 1; int t = 0; int next[1] = 0; // 特殊情况，模式串的第一个位置发生不匹配 while(i &lt; substr.len){ if(t==0 || substr.ch[t] == substr.ch[j]){ // t=0;是因为next数组中可能有0元素,也说明没有重合的前后缀 next[j+1] = t+1; ++j; ++t; } else{ t = next[t]; } }} KMP 算法的改进 KMP算法就还有什么地方需要改进的？ 为了回答这个问题我们先来看一种特殊情况：模式串为（A A A A A B）,该模式串所对应的next数组为{0,1,2,3,4,5}。可以遇见的是当在模式串第j=5个位置A处发生不匹配时，next数组指导j指向4；而4处的元素依然不匹配（因为4处元素与5处相等），j来到了3（同样不匹配），紧接着来到了2（不匹配），来到1（依然不匹配），最后j=0(++i,++j)到此才结束了之前陷入的“尴尬”局面。 由上分析我们不难想到，如何才能让j直接跳到0；而免去从1-4的多余的比较呢？这就是KMP算法需要改进的地方 也就是说，对KMP算法的改进主要就是对求next数组的方法的改进，于是就有了改进版的next数组，我们称之为 nextval 数组 getNextval() 算法核心思想： 通过上面那个特殊情况，我们知道当j处发生不匹配时，若next数组指导的下一个位置的值与j处的值是相等的，那么显然这次比较就是多余的（因为显然还是会不匹配），所以我们应该跳过next数组所指向的那个位置，换一种思路就是我们应该让next[j] 所指向的位置与Pj不相等，就是改变next[j] 的值；改变后的next数组就是nextval数组. 求解nextval数组的一般步骤： 当j等于1时，nextval[j]赋值为 0 ，作为特殊标记； 当j大于1 时： 若Pj不等于P(next[j]),则nextval[j] 等于 next[j]; 若Pj等于P(next[j]),则nextval[j] 等于 nextval[next[j]]; void getNextval(LStr substr,int nextval[]){ int j = 1; int t = 0; nextval[1] = 0; while(i&lt;substr.len){ if (j == 0 || substr.sh[j] == substr.ch[t]){ if(substr.ch[j+i] != substr.ch[t+1]) nextval[j+1] = t+1; else nextval[j+1] = nextval[t+1]; ++j; ++t; } else t = nextval[t]; }}","link":"/2019/03/11/String/"},{"title":"【数据结构】数组、矩阵、和广义表","text":"数组： 常见的数组有一维数组和二维数组，二维数组是元素可以看成是一维数组的一维数组。对于数组主要考察元素下标计算的问题。对于一维数组较为简单，而对于二维数组的元素位置计算较为复杂，要考虑行优先和列优先两种情况。 二维数组的行优先和列优先存储： 行优先：从起始行开始一行一行地存入连续空间中 列优先：从起始列开始一列一列地存入连续空间中 矩阵的压缩存储： 矩阵的定义 矩阵一般用一个二维数组A[m][n]表示，表示一个m行n列的矩阵 其中m n 必须为常量，或者为预先定义的宏常量，如下：#define m 5#define n 6int A[m][n]; 矩阵的一般操作与实现 矩阵的转置： void transpose(int A[][maxsize],int B[][maxsize],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n ; ++j){ B[j][i] = A[i][j]; // 矩阵转置操作，元素关于主对角线互换位置 } }} 矩阵相加: void addition(int A[][max],int B[][max],int C[][max],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n){ c[i][j] = A[i][j] + B[i][j]; //对应位置元素相加 } }} 矩阵相乘： void Multiply(int A[m][n],int B[n][k],int C[m][k],int m,int n,int k){ for(int i = 0;i&lt;m;++i){ for (int j = 0;j&lt;k;++j){ C[i][j] = 0; for(int h = 0;h&lt;n;++h){ C[i][j] += A[i][h] * B[h][j]; } } }} 特殊矩阵和稀疏矩阵 矩阵中绝大多数元素都是0的矩阵称为稀疏矩阵(国外教材) 相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵(严版) 特殊矩阵：a) 对称矩阵 矩阵中的元素满足A[i][j] = A[j][i] 的矩阵称为对称矩阵 如上图所示，只需要存储一半的元素就可以了，要还原出另一半只需根据A[i][j] = A[j][i]这个条件就行了。 将一个n×n的对称矩阵存储在一维数组中，所需的存储空间为 $ \\dfrac{(1+n)·n}{2}$ 需要保存的元素为： 按照行优先来存储，保存在一维数组中，如下图所示：b)三角阵 上三角矩阵 为矩阵下三角部分(不包括对角线)元素全为零 下三角矩阵 为矩阵上三角部分(不包括对角线)元素全为零 三角矩阵的存储方式与对称矩阵类似，以下三角矩阵的存储为例，只需存储对角线及其以下部分的元素和其上三角中的一个元素C即可，如下图： c)对角矩阵 如下图所示的对角矩阵，其特点为除了主对角线以及其上下两条带状区域的元素外，其余元素都为C ( C可以为0)： 下面介绍如何求出第i行带状区域内的第一个元素在一维数组中的下标，假设c存在数组的最后一位： 当i=1时，带状区域内的第一个元素为矩阵当中的第一个元素，其在一维数组中的下标为0； 当i&gt;1时，第i行之前的元素个数为 $2+(i-2)×3$，则带状区域的第一个元素在一维数组中的下标为 $2+(i-2)×3$2.稀疏矩阵 稀疏矩阵中的相同元素c不像特殊矩阵中的相同元素的位置分布那么有规律可循，故必须为其设计一些特殊的存储结构 稀疏矩阵的顺序存储及其相关操作：常用的稀疏矩阵顺序存储方法有三元组表示法，和伪地址表示法。 三元组表示法：三元组数据结构为一个长度为n，表内每个元素都有三个分量的线性表，其三个分量分别为：“值”、“行下标”、“列下标”。元素结构体定义如下：typedef struct Trimat{ int val; // 值 int i; // 行下标 int j; // 列下标}； 结构体示意图：结构题数组的定义：Trimat trimat[maxterms + 1]; // maxterms + 1;因为从第 1 行才开始存储元素 但是，为了方便起见，一般不用上诉结构体来定义三元组，直接申请一个二维数组就可以了：int trimat[maxterms + 1][3];// 如要求其他类型，可将int替换掉// 需要注意的是，如果矩阵是float型的（或者其他非整型的数据类型）// 则此时用一个数组来表示三元组应该写成如下形式：float trimat[maxterms + 1][3];// 这个时候若要取当前非零元素的所在位置应该这么做： (int)trimat[k][1]; (int)trimat[k][2];// 就是将float 型的元素造型成int型，这样就可以避免很多不必要的问题的发生 上诉定义方式中：trimat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值trimat[k][1]、trimat[k][2]表示第k个非零元素在矩阵中的位置。事实上，trimat此时就是一个maxterms 行 3 列的二维数组，我们规定第0行的三个元素分别用来存储原矩阵中的非零元素个数，以及矩阵的行数与列数。示意图如下： 给定一个二维数组存储的矩阵，要求设计算法将其转化为三元组存储： 算法分析：建立一个三元组的核心问题在于求矩阵的非零元素个数以及非零元素的值，还有其在矩阵（原数组）中的位置，故只需扫描所给矩阵的二维数组即可得到相关数据，进而建立三元组。 // 建立三元组时，结点间的次序行按元素在矩阵中的行优先顺序排列void creattrimat(float A[][max],int m,int n,float B[][3]){// m,n 表示所给矩阵的规模为m×n int k = 1; for (int i = 0;i&lt;m;++i){ for (int j =0;j&lt;n;++j){ // 双重循环扫描矩阵 if (A[i][j] != 0){ // 若矩阵的[i][j] 上的元素不为零，将该元素连同其位置信息存入三元组中 B[k][0] = A[i][j]; B[k][1] = i; B[k][2] = j; k++; // k 指向三元组的下一个空间 } } } B[0][0] = k-1; // 将矩阵的基本信息存入三元组的第0行 B[0][1] = m; B[0][2] = n;} 设计算法打印出所给三元组存储的矩阵： 算法分析：读取三元组的第0行，得到矩阵的相关信息循环按行打印，若下标与三元组中的非零元素下标信息匹配则打印该非零元素，否则，打印0；void print(float trimat[][3]){ int m = trimat[0][1]; int n = trimat[0][2]; int k = 1; // 非零元素从第一行开始存储 for(int i = 0;i&lt;m;i++){ // 双重循环打印矩阵 for(int j = 0;j&lt;n;j++){ // 循环过程中检查第[i][j]下标是否与三元组中的非零元素相同，若相同打印该非零元素，若不同打印 0 ； if(i = (int)trimat[k][1] &amp;&amp; j == (int)trimat[k][2]){ cout &lt;&lt; trimat[k][0] &lt;&lt; \" \"; ++k; } else cout &lt;&lt; \"0 \" &lt;&lt; endl; } }} 伪地址表示法：伪地址表示法与三元组表示法在本质上并无差别，只不过是三元组表示法的每一行用两个存储单元来存放原矩阵非零元素的位置标记，而伪地址表示法可以只用一个存储单元来存放位置标记，原因是因为对于一个$ m·n $的矩阵，伪地址表示法将元素位置下标的两个整数用一个公式映射( $ n·(i-1) +j $)到了一个整数上，同样利用该公式也可还原原i和j的值。我们来看一个例子： 稀疏矩阵的链式存储及相关操作： 邻接表表示法：邻接表表示法将矩阵中每一行的非零元素串联成一个单链表，链表结点中有三个分量：元素值、所在列、指针域结点的定义如下：typedef struct Listmat{ int data; int col; struct Listmat *next;}; 示意图如下：上图中最左端为一个指针数组，用来存储指向每一行非零元素单链表的头指针，数组下标为表示行标号。 十字链表表示法：在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点有 5 个分量：行分量、列分量、数据域、指向下方结点的指针域、指向右方结点的指针域；结构图如下：普通结点定义：typedef struct matNode{ int row; int col; int data; struct matNode *down; struct matNode *right;}; 头结点定义:typedef struct CrossList{ struct matNode *rhead,*cheard; // 指向两头结点数组的指针 int m,n,k; // 矩阵行数、列数、非零结点总数} 由于十字链表存储结构比较复杂，我们将通过其结构图例来深入了解它，图中附有详细的注释： 上图中，银灰色的结点为行头结点数组与列头结点数组，他们的定义如下：// 其中的m n 为矩阵的行数和列数typedef struct Rhead{ // 行头结点数组 struct matNode Rhead[m]; // 元素为matNode结点的数组};typedef struct Chead{ // 列头结点数组 struct matNode Chead[n];} 在理解了十字链表存储结构后，我们来看一个实际的应用：给定一个float型二维数组存储的稀疏矩阵，建立其对应的十字链表结构。算法分析：首先应该建立整体框架，也就是十字链表头结点以及行、列头结点数组。然后，按行优先顺序遍历矩阵数组，若发现不为零的元素，分配一个结点空间将其值存入，调整行、列头结点的指针域指向该结点，如此直到结束遍历int creatCrossListmat(float A[][maxsize],int m,int n,int k,CrossList &amp;M){ //============================================ // 搭建基本框架操作 //============================================ // 清空处理： if (M.rhead) free(M.rhead); if (M.chead) free(M.chead); // 将矩阵信息存入十字链表头结点： M.m = m; M.n = n; M.k = k; // 申请行、列头结点数组空间： if (!(M.rhead = (matNode*)malloc(sizeof(matNode)*m))) return 0; if (!(M.chead = (matNode*)malloc(sizeof(matNode)*n))) return 0; // 将行、列头结点数组的right和down指针置空： for(int i = 0;i &lt; m ; ++i){ M.rhead[i].right = NULL; M.rhead[i].down = NULL; } for(int i = 0;i &lt; n ;++i){ M.chead[i].right = NULL; M.chead[i].down = NULL; } //=================================================== // 核心算法 //=================================================== // 建立链表的辅助指向列头结点的指针数组： matNode *temp_r[maxsize]; for(int i = 0;i&lt;n;++i){ temp_r[i] = &amp;(M.chead[i]); // 引用 } // 行优先顺序遍历矩阵数组构建十字链表： for(int i = 0;i &lt; m ;++i){ matNode *c = &amp;(M.rhead[i]); for(int j = 0;j &lt; n;++j){ if (A[i][j] != 0){ matNode *p = (matNode*)malloc(sizeof(matNode)); p -&gt; row = i; p -&gt; col = j; p -&gt; val = A[i][j]; p -&gt; down = NULL; p -&gt; right = NULL; // 如果某行（列）中已经连接了元素，那么就让这个元素充当该行（列）的头部，这样能使十字链表的行（列）头结点数组中的结点避免重复指向，覆盖；所以下面的代码所要做的事情很重要。 c -&gt; right = p; c = p; temp_r[j] -&gt; down = p; temp_r[j] = p; } } } return 1;} 广义表 表元素可以是原子类型的元素，也可以是广义表的一种线性表 三个重要概念： 广义表的长度：表中最上层元素的个数 广义表的深度：表中括号的最大层数，求解时应将所有的子表展开在分析 表头(Head)和表尾(Tail)：当表非空时，第一个元素为广义表的表头，其余元素组成广义表的表尾两种存储结构： 头尾链表存储结构：这种存储结构有两种结点，即原子结点和广义表结点。原子结点有两个域：标记域、数据域。广义表结点有三个域：标记域、头指针域、尾指针域其中头指针指向一个原子结点或广义表结点，尾指针为空或者指向 本层中 的下一个广义表结点，而标记域用来区分广义表结点(1)与原子结点(0);示意图入下： 扩展线性表结构：该种存储结构同样有两种结点，与头尾链表存储结构不同的是这里的原子结点有三个域：标记域、数据域、尾指针域。示意图如下：","link":"/2019/03/01/arrayandlist/"},{"title":"Hello Friend","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2019/02/01/hello-world/"},{"title":"【数据结构】线性表","text":"线性表的基本概念与实现 1. 线性表的定义: 线性表是具有相同特性数据元素的一个有限序列，重点在“有限序列”。线性表可以是有序的，也可以是无序的。2. 线性表的逻辑特性: 除了表头和表尾的数据元素“结点”，所有元素都有一个直接前驱与一个直接后继。表头无前驱，表尾无后继。 线性表的存储结构： * 顺序存储结构：（顺序表） 1. 存储空间连续（空间为*一次性*分配的） 2. 可以随机存取，也可以顺序存取 3. 插入删除时平均需要移动近一半的元素，时间复杂度为:__O((n-1)/2)=O(n)__ 4. 存储密度为１ * 链式存储结构：（链表） 1. 存储空间可以不连续（存储空间是*动态*分配的） 2. 每一个结点不仅包含数据还包含指向下一个结点的指针 3. 只能够进行顺序存储 4. 存储密度&lt;1 5. 插入删除时不需要移动元素，只需修改*指针*即可,时间复杂度为:__O(1)__ 线性表的定义与实现：a) 顺序表的定义： 结构体定义：#defined MaxSize 100typedef sturct Sqlist { int data[MaxSize]; //线性表最多能容纳的元素个数，即分配的空间大小 int length ; //元素的个数}Sqlist; 用的最多的简单定义：int A[MaxSize]; //直接利用数组就是顺序表的一种这一特性int length; b) 单链表的结点定义：typedef struct LNode { int data; //数据域 struct LNode *next; //指针域}LNode; c) 双链表结点定义： typedef struct DLNOde { int data; //数据域 struct DLNOde *prior; // 指向前驱结点的指针 struct DLNode *next; // 指向后继结点的指针} 【注】 为结点分配存储空间：LNode *A = (LNOde*)malloc(sizeof(LNode));//malloc 函数返回一个空间的地址，让指针Ａ来指向它 线性表的相关操作 查找操作： int findElem (Sqlist a, int x){ for (int i = 0;i&lt;l.length;++i){ if (a[i]==x){ return i; //找到了，返回所在的下标 } } return 0; // 没找到，返回０} 插入操作： int insertElem(Sqlist &amp;L,int i ,int x){ if (i&lt;0 || i &gt; L.length){ return -1; //如果插入位置不合法，返回－１ } if (L.length == MaxSize){ int newL[L.length+MaxSize] for (int j=0;j&lt;L.length;++j){ newL[j] = L[j]; //如果发现顺序表已经满了，就构造一个更大的顺序表并把原顺序表的元素放进去 } L = newL; } for (int k = L.length-1; k&gt;=i; --k){ L[k+1] = L[k]; //从某位开始将插入位置至末尾的元素向后移动一个位置 } L[i] = x; // 插入ｘ到ｉ处 L.length++; // 插入后该表表的长度} 删除操作： // 通过索引下标删除元素，并返回所删元素的值int deleteElem_by_index (Sqlist &amp;L,int i){ int q = L[i]; // 保留ｉ位置的元素 for (int j = i+1;j&lt;L.length;++j){ L[j-1] = L[j]; // 从待删除元素的右边开始每个元素向左移动一个位置，覆盖掉ｉ位置的元素 } L.length--; // 顺序表长度减一，完成删除操作 return q; // 返回被删除元素的值}// 通过值来删除元素，并返回所删元素的下标int deleteElem_by_value (Sqlist &amp;L, int e){ int index = findElem(L,e); //利用findELem() 函数找到要删除元素的下标 int value = L[index]; deliteElem_by_index (L,index); // 用下标索引法删除元素 return value;} 初始化顺序表： void initList (Sqlist &amp;L){ L.length = 0;} 求指定位置元素： int getElem (Sqlist L , int index){ if (index &lt; 0 || index &gt; L.length-1) return Error; rerurn L[index];} 单链表的相关操作 以下所有的算法用的都是带头结点的单链表 尾插法建立单链表： // 给定数组ａ[] 为数据源，建立单链表void creatListR(LNode *&amp;C , int a[], int length){ LNode *s,*r; //用ｓ指向新建的结点，ｒ始终指向链表的尾部结点 C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 r = C; // r 指向头结点，也就是空链表的头结点 for (int i = 0 ; i&lt;length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); // 用malloc函数循环分配结点空间 s -&gt; next = NULL; s -&gt; data = a[i]; // 尾插法的核心算法： r -&gt; next = s; r = r -&gt; next; //r 指向当前尾结点 } // r -&gt; next == NULL;} 头插法建立单链表： void creatListH(LNode *&amp;C ,int a[] ,int length){ LNode *s; C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 for (int i = 0 ; i &lt; length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = a[i]; // 头插法的核心算法： s -&gt; next = C --&gt; next; C -&gt; next = s; }} 删除结点： // 按值索引删除链表结点void deleteNode(LNode &amp;L , int elem){ LNode *p,*q; p = L; if (L -&gt; next == NULL) return 0; //如果链表为空，返回０； while (p -&gt; next != NULL){ // 循环遍历链表结点 if (p -&gt; next -&gt; data == elem){ // 如果ｐ指向的结点的下一个结点的数据域与带删除数据相等，删除该下一个结点，释放空间 // 删除操作的核心算法： q = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; free(q); // 释放内存 break; //删除成功，退出循环 } p = p -&gt; next; //该节点不是待删除结点，令ｐ指向下一个结点 }} 插入结点： // 在链表的指定元素前插入结点void insertNode(LNode &amp;L , int we,int e){ LNode *r; r = L; LNode *s = (LNode*)malloc(sizeof(LNode)); q -&gt; data = we; q -&gt; next = NULL; while (r -&gt; next != NULL ){ if (r -&gt; next -&gt; data == e){ //插入操作的核心算法： s -&gt; next = r -&gt; next; r -&gt; next = s; } r = r -&gt; next; }} 双链表的相关操作 尾插法建立双链表： // 给定数据源数组，建立双链表void creatDListR (DLNode ＆L , int a[], int length){ DLNode *s,*r; //用ｒ始终指向链表末尾结点，ｓ接受新分配的结点 L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; r = L; //r 指向头结点 for (int i = 0; i&lt; length;++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; // 尾插发的关键步骤： s -&gt; prior = r; r -&gt; next = s; r = r -&gt; next; // r = s; 令ｒ 指向下一个结点 r -&gt; next = NULL; //滞空末尾结点的ｎｅｘｔ指针域 }} 头插法建立双链表： void creatDListH (DLNode ＆L , int a[], int length){ DLNode *s ; L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; for (int i = 0 ; i&lt;length; ++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; //关键步骤： s -&gt; next = L -&gt; next; L -&gt; next -&gt; prior = s; s -&gt; prior = L; L -&gt; next = s; }} 查找结点的算法： // 在双链表中查找第一个值为ｘ的结点，从第一个结点开始，边扫描边比较，若找到返回该结点的指针，没找到返回 ＮＵＬＬDLNode* findNode(DLNode *L, int x){ DLNode *p; p = L -&gt; next; while (p != NULL){ if (p -&gt; data == x){ return p; } p = p -&gt; next; } return NULL;} 插入结点的算法： //在双链表中ｐ所指结点后插入新的结点ｓ//关键步骤如下： s -&gt; next = p -&gt; next; s -&gt; prior = p; p -&gt; next -&gt; prior = s; p -&gt; next = s; 删除结点： //在双链表中的删除指针ｐ所指结点的后继结点,并用ｓ指针返回被删除的结点//关键步骤如下： s = p -&gt; next ; s -&gt; next -&gt; prior = p; p -&gt; next = s -&gt; next; free(s);","link":"/2019/03/06/linearList/"},{"title":"【底层原理】浮点数在计算机中的表示","text":"一道C语言题： #include &lt;stdio.h&gt;int main(){ int num = 9; float *pFloat = &amp;num; printf(\"num 的值为：%d\\n\",num); printf(\"*pFloat 的值为：%f\\n\",*pFloat); *pFloat = 9.0; printf(\"num 的值为：%d\\n\",num); printf(\"*pFloat 的值为：%f\\n\",*pFloat); return 0;} 运行结果： 产生上述结果的原因：浮点数在计算机中的表示与整数在计算机中的表示存在差异 分析：整数在计算机中的表示：int num = 9; 上面这条语句声明并定义了一个整型int变量num为9；在普通的32位计算机中，用四个字节表示int，其二进制表示为： 00000000 00000000 00000000 00001001 浮点数在计算机中的表示：根据国际标准IEEE 754，任意一个二进制浮点数V可以表示为下面这种形式： $ V = (-1)^{s} · M · 2^{E} $ s表示符号位，s=0为正，s=1为负； M为有效数字，$1&lt;= M &lt;2$; $2^E$表示指数位； 如题例，十进制的 $ 9.0 $ ,写成二进制位$1001.0$,相当于：$ 1.001 · 2^{3} $,其中$ s=0,M=1.001,E=3 $;十进制的$ -9.0 $,写成二进制为$ -1001.0 $,相当于：$ -1.001 · 2^{3} $,其中$ s=1,M=1.001,E=3 $; 有效数字M： IEEE 745规定，对于32位的浮点数，最高的一位是符号位s，接着的8位是指数E，剩下的23位为有效数字M：对于64位的浮点数来说，最高的一位仍为符号位s，接着的11位是指数E，剩下的52位为有效数字M：另外，前面提到，$1&lt;= M &lt;2$,也就是说M可以写成$1.x_1x_2x_3x_4$的形式，其中$x_1x_2x_3x_4$表示小数部分。IEEE 754规定，在计算机内包存M时， 默认这个数的第一位为 1，因此可以被舍去，这样子就可以节省一位有效数字位，使得32（64）位浮点数可以保存24（53）位的有效数字。 指数E的情况稍微复杂一些： 首先，E是一个无符号整数（unsign int ）,着意味着当E为8位时，其取值范围为0到255；若E为11位其取值范围为0到2047。但是我们知道，科学计数法中的E可以是负数，因此，E的真实值必须减去一个中间值。对于8位的E应减去127，对于11位的E应减去1023； 比如说，$ 2^{9} $ 的E是9，所以保存成32位浮点数时，必须保存为$E = 9+127=136$,即$10001000$。 还原E的真实值时还可以分成3种情况： E不全为0或不全为1:。这时可直接用E减去127（1023）即可得到E的真实值。 E全为0。这时浮点数的指数E为1-127（1-1023），有效数字M不再加上第一位，而是还原成$0.x_1x_2x_3x_4$的小数。这样做是为了表示$\\pm0$,以及接近于0的很小的数字。 E全为1。这时如果有效数字M全为0，则表示$\\pm$无穷大（取决于符号位s）；如果有效数字M不全为0，表示这个数是一个$NaN$。 到此，回顾最初的问题。 为什么$00000000 00000000 00000000 00001001$还原成浮点数就变成了$0.000000$ 呢???首先：00000000 00000000 00000000 00001001的符号位s为0表示其为正；再者：00000000 00000000 00000000 00001001的指数位E为00000000（全为0），符合第2种情况，还原后的E的真实值为：$E=1-127=-126$；最后：00000000 00000000 00000000 00001001的有效数字位为：$000 0000 0000 0000 0000 1001$。综上：$V = (-1)^{0} · 0.00000000000000000001001 · 2^{-126} = 1.001 · 2^{-146}$可以看出这是一个很小的数，故用十进制表示为0.000000. 浮点数9.0如何用二进制表示，还原成十进制后为何是1092567616 呢？首先：浮点数9.0的二进制表示为1001.0，即为$1.001 · 2^3$；符号位s=0；再者：有效数字M=100 0000 0000 0000 0000 0000（共23位（100后加上20个0）其中最高位1默认被省略）。最后：指数E=3+127=130，即$E = 10000010_{BIN}$。综上：浮点数9.0在计算机内的表示为：$0 10000010 00100000000000000000000$，将其转化为十进制就是：1091567616","link":"/2019/02/22/【底层原理】浮点数在计算机中的表示/"},{"title":"【算法】DP最大和问题","text":"动态规划 问题描述： 给定一个整数数字序列（用数组表示），在这个数列中选择若干个互不相邻的数，使得这些数的和达到最大值。 分析： 属于01背包问题同类问题，对于每一个数，都有两种选择（选或不选）。假设给定数组set[]的长度为n，最终要求OPT(n-1)的结果,也就是从下标0到下标n-1这些数中能组成的最大和，而要求OPT(n-1)就分为两种情况：1.选择set[n-1],因为不能出现相邻选项故OPT[n-1]的结果为set[n-1]与OPT[n-3]的和。2.不选择set[n-1],则OPT[n-1]的结果就与OPT[n-2]相等。判断出口：不难看出，OPT[0] = set[0]，OPT[1] = max(set[0],set[1]); 因此其状态转移方程为： 算法实现：递归实现：int OPT(int i){ if(i == 0) return set[0]; if(i == 1) return set[0]&gt;set[1] ? set[0]:set[1]; int a = OPT(i-1); int b = OPT(i-2)+set[i]; return a&gt;b?a:b;} DP实现：int OPT_(int set[],int m){ int *opt = new int[100];//状态数组 //出口 opt[0] = set[0]; opt[1] = set[0]&gt;set[1] ? set[0]:set[1]; for(int i = 2;i &lt; m;i++) { int a = opt[i-1]; int b = opt[i-2] + set[i]; opt[i] = a&gt;b?a:b; } return opt[m-1];} 测试： 输入：{1,5,8,9,7,8,2,1,6,3}输出：","link":"/2019/03/17/【算法】DP最大和问题/"},{"title":"【算法】全排列问题","text":"算法思想： 设定一个数组p用来存放当前排列，并用一个数组Hash用来标记已填入p中的数字。按顺序将数字填入数组p中的第0位置第Max-1位，现在假设已经填好了p[0]~p[index-1]，正准备将数字填入index位置，若index位置未及Max（数组边界），则枚举0~Max-1；判断是否有数字未填入，若有则将其填入p中，同时在Hash中将该数字置为已填入。其后继续填入下一个位置index+1；当递归完成时，将Hash[i]还原为false（将i置为未填入）。 代码实现：#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define Max 10using namespace std;//列举从0到Max-1的全排列int p[Max];//保存当前排列bool Hash[Max] = {false};//标记i是否已填入p中，是为真，否为假；void generate_x(int index){ if(index == Max)//递归边界，已生成一种排列可能 { for(int i = 0;i &lt; Max;i++)//输出该排列 { cout &lt;&lt; p[i] &lt;&lt; ' '; } cout &lt;&lt; endl; return; } for(int i = 0;i &lt; Max;i++) { if(Hash[i] == false)//判断i是否还未已填入p中 { p[index] = i;//填入 Hash[i] = true;//标记已填入 generate_x(index+1);//填写下一个数 Hash[i] = false;//处理完P[index] = i 的子问题，还原状态 } }}int main(){ generate_x(0);//从0开始填入 return 0;} 输出结果：/20190313012239824.png)","link":"/2019/03/13/【算法】全排列问题(C++)/"},{"title":"【算法】String实现大数运算算法汇总","text":"大数加法: #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;stdexcept&gt;#define max 1000using namespace std;struct bign//定义一个结构体表示大数{ int dig[max];//由低位到高位存放大数的低位到高位的各位数值 int len;//保存大数的位数 bign(){//初始化函数 dig[max] = {0}; len = 0; }};void s_to_array(string &amp;s,bign &amp;d)//字符串转数组{ int s_len = (int)s.size(); for(int i = 0,j = s_len-1;j &gt;= 0 &amp;&amp; i &lt; max;i++,j--) { if(s[j]&gt;='0' &amp;&amp; s[j]&lt;='9') d.dig[i] = (int)(s[j] - '0'); else throw invalid_argument(\"无效的输入，只能由数字构成！！！\"); } d.len = s_len;}void add(bign &amp;a,bign &amp;b,bign &amp;ans)//大数加法函数{ int carry = 0;//进位 int re; for(int i = 0;i &lt; a.len || i &lt; b.len;i++) { re = a.dig[i] + b.dig[i] + carry; ans.dig[ans.len++] = re%10;//取个位 carry = re/10; } if(carry != 0) { ans.dig[ans.len++] = carry; }}int main(){ string num; string num1; while(cin &gt;&gt; num &gt;&gt; num1) { bign a,b; bign ans; try{ s_to_array(num,a); s_to_array(num1,b); }catch(invalid_argument err){ cout &lt;&lt; err.what() &lt;&lt; endl; cout &lt;&lt; \"Please Try Again\" &lt;&lt; endl; continue; } for(int i = a.len-1;i &gt;= 0;i--) { cout &lt;&lt; a.dig[i]; } cout &lt;&lt; endl; cout &lt;&lt; \"+\" &lt;&lt; endl; for(int i = b.len-1;i &gt;= 0;i--) { cout &lt;&lt; b.dig[i]; } cout &lt;&lt; endl; cout &lt;&lt; \"=\" &lt;&lt; endl; add(a,b,ans); for(int i = ans.len-1;i &gt;= 0;i--) { cout &lt;&lt; ans.dig[i]; } cout &lt;&lt; endl; } return 0;} 大数减法:#include &lt;stdio.h&gt;#include &lt;string.h&gt;void sub(char s1[],char s2[],char t[]){ int i,l1,l2,k; l1 = strlen(s1); l2 = strlen(s2); t[l1] = '\\0'; l1--; for(i=l2-1;i&gt;=0;i--,l1--) { if(s1[l1]-s2[i] &gt;= 0) { t[l1] = s1[l1] - s2[i] + '0'; } else { t[l1] = 10 + s1[l1] - s2[i] + '0'; s1[l1-1] = s1[l1-1] - 1; } } k = l1; while(s1[k]&lt;0) { s1[k] += 10; s1[k-1] -= 1; k--; } while(l1&gt;0) { t[l1] = s1[l1]; l1--; }loop: if(t[0] == '0') { l1 = strlen(s1); for(i = 0;i&lt;l1-1;i++) t[i] = t[i+1]; t[l1-1] = '\\0'; goto loop; } if(strlen(t) == 0) { t[0] = '0'; t[1] = '\\0'; }}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",c,t)) { sub(c,t,sum); printf(\"%s\\n\",sum); } return 0;} 大数乘法:#include&lt;stdio.h&gt;#include&lt;string.h&gt;void mult(char a[],char b[],char s[]){ int i,j,k=0,alen,blen,sum=0,res[65][65]={0},flag=0; char result[65]; alen = strlen(a); blen = strlen(b); for(i=0;i&lt;alen;i++) { for(j=0;j&lt;blen;j++) res[i][j] = (a[i]-'0')*(b[j]-'0'); } for(i=alen-1;i&gt;=0;i--) { for(j=blen-1;j&gt;=0;j--) { sum = sum + res[i+blen-j-1][j]; printf(\"res = %d\\n\",res[i+blen-j-1][j]); } result[k] = sum%10; k++; sum /= 10; } if(sum) { result[k] = sum; k++; } for(i=0;i&lt;k;i++) { result[i] += '0'; } for(i=k-1;i&gt;=0;i--) { s[i] = result[k-1-i]; } s[k] = '\\0'; while(1) { if(strlen(s) != strlen(a) &amp;&amp; s[0] == '0') strcpy(s,s+1); else break; }}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",c,t)) { mult(c,t,sum); printf(\"%s\\n\",sum); } return 0;} 大数除以小数:#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void StringToNum(string str,int num[]){ //字符串转int数组 int len = str.length(); for(int i = 0;i &lt; len;i++) { num[i+1] = str[i] - '0'; } num[0] = len;}int Divide(int div[],int ans[],int divisor)//得到div除于divisor的结果{ //int carry = 0; int temp = 0;//保存上一步的余数 int i; for(i = 1;i &lt;= div[0];i++) { temp = temp*10 + div[i]; if(temp &lt; divisor) ans[i] = 0;//不够除，ans[i]为0 else { //够除 ans[i] = temp/divisor;//ans[i]为商 temp = temp % divisor;//更新余数 } } ans[0] = i;//保存长度标记 return temp;//返回余数}int main(){ string str; int dividend[1001];//被除数 int ans[1001];//结果 while(cin &gt;&gt; str) { StringToNum(str,dividend); DecToBinary(dividend,ans); for(int i = ans[0];i &gt; 0;i--) { cout &lt;&lt; ans[i]; } cout &lt;&lt; endl; /* int carry = DivideTwo(dividend,ans); for(int i=1;i &lt; ans[0];i++) { cout &lt;&lt; ans[i]; } ans[1001] = {0}; cout &lt;&lt; \"..............\"&lt;&lt;carry&lt;&lt; endl; */ } return 0;} 大数阶乘:#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(){ void factorial(int n,int *); int b[10000]; int n; while(cin&gt;&gt;n) { factorial(n,b); } return 0;}void factorial(int n,int b[10000]){ long a[10000]; int i,j,l,c,m=0,w; a[0] = 1; for(i=1;i&lt;=n;i++) { c=0; for(j=0;j&lt;=m;j++) { a[j] = a[j] * i + c; c = a[j]/10000; a[j] = a[j]%10000; } if(c&gt;0) { m++; a[m] = c; } } w = m*4 + log10(a[m])+1; cout &lt;&lt; w &lt;&lt; endl; cout &lt;&lt; a[m]; for(i=m-1;i&gt;=0;i--) { cout &lt;&lt; a[i]; } cout &lt;&lt; endl;} 大整数乘以小数:#include&lt;stdio.h&gt;#include&lt;string.h&gt;void mult(char c[],int m,char t[]){ char s[100]; int len=strlen(c); for(int i=0;i&lt;len;i++) { s[len-i-1] = c[i] - '0'; } int flag,add=0; for(int i=0;i&lt;len;i++) { int k = s[i] * m + add; if(k&gt;=10) { s[i] = k % 10; add = k / 10; flag = 1; } else { s[i] = k; add = 0; flag = 0; } } while(add) { s[len++] = add % 10; add /= 10; } for(int i=0;i&lt;len;i++) t[len-i-1] = s[i] + '0'; t[len] = '\\0';}//大数加小数void addt(char a[],int b,char c[]){ int len = strlen(a); char s[100]; for(int i=0;i&lt;len;i++) s[len-i-1] = a[i] - '0'; int add = 0; for(int i=0;;i++) { if(i&gt;=len) { s[i] = 0; len++; } int k = s[i] + b % 10 + add; b /= 10; if(k&gt;=10) { s[i] = k%10; add = k/10; } else { s[i] = k; add = 0; } if(b==0 &amp;&amp; add==0) break; } for(int i=0;i&lt;len;i++) { c[len-i-1] = s[i] + '0'; } c[len] = '\\0';}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",&amp;m)) { mult(c,m,t); printf(\"%s\\n\",t); addt(c,m,sum); printf(\"%s\\n\",sum); } return 0;}","link":"/2019/02/28/【算法】大数运算算法汇总/"},{"title":"【算法】数字黑洞","text":"【PAT】B1019 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct digs{ int dig[10]; int len; digs() { dig[10] = {0}; len = 0; }};void to_array(int n,digs &amp;d){ while(n) { d.dig[d.len++] = n%10; n /= 10; }}int to_number(digs d){ int i = d.len-1; int t = 0; int result = 0; for(;i &gt;= 0;i--,t++) { result = result + d.dig[i]*((int)pow(10,t)); } return result;}bool cmp_less(int &amp;a,int &amp;b){ return a&gt;b;}int main(){ int n; while(cin &gt;&gt; n) { while(1) { digs d; to_array(n,d); sort(d.dig,d.dig+d.len); int min = to_number(d); sort(d.dig,d.dig+d.len,cmp_less); int max = to_number(d); n = max - min; printf(\"%04d - %04d = %04d\\n\",max,min,n); if(n == 0 || n == 6174) break; } }/* for(int i = 0;i &lt; d.len;i++) { cout &lt;&lt; d.dig[i]&lt;&lt; ' '; } cout &lt;&lt; endl;*/ return 0;}","link":"/2019/03/13/【算法】数字黑洞/"},{"title":"【算法】素数筛法","text":"Eratosthenes筛法 算法思想： 从小到大枚举所有数，对每一个素数，筛去其所有的倍数，剩下的就都是素数了。比如：已知2为素数，筛去2的倍数4,6,8,10……继续枚举到3，筛去3的倍数6,9,12,15……由于4已被筛去，故其不是素数，来到5，筛去5的倍数10,15…..如此下去，即可得到一个素数表 代码实现：#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;//素数筛法const int Max = 101;int prime[Max],pNum = 0;//pNum存放素数个数bool p[Max] = {false};void findPrime(){ for(int i = 2; i &lt; Max;i++)//遍历从2到100的数 { if(p[i] == false)//若i为素数 { prime[pNum++] = i;//将i添加到prime数组中 for(int j = i+i;j &lt; Max;j+=i)//筛掉i的倍数 { p[j] = true; } } }}int main(){ findPrime(); for(int i = 0;i &lt; pNum;i++) { printf(\"%d\\n\",prime[i]); } return 0;} 输出结果：","link":"/2019/03/12/【算法】素数筛法/"},{"title":"【算法】背包问题的DFS与DP解法","text":"Kanapsack Problem 问题描述： 有n件物品，每件物品重w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品总重量不超过背包限重的情况下，让背包内的物品总价值达到最大。 DFS解法：算法思想： 对于每件物品，有两种情况（选，或不选）。若选择该物品，则将更新背包内的总重与总价值量，若不选择该物品，则跳过它去判断下一件物品，当处理完n件物品后，此时记录的sumW和sumC就是所选物品的总质量和总价值。如果sumW不超过V且sumC比MaxValue还大，就更新MaxValue。 #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#define Maxn 10using namespace std;int n,V,MaxValue = 0;//n为物品的总件数，V为背包的容量，MaxValue为最大价值int w[Maxn],c[Maxn];//w[i]为每件物品的重量,c[i]为每件物品的价值void DFS_Kanapsack(int index,int sumW,int sumC){ if(index == n)//已完成对n件物品的选择 { if(sumW &lt;= V &amp;&amp; sumC &gt; MaxValue) { MaxValue = sumC;//更新最大价值 } return; } // DFS_Kanapsack(index+1,sumW,sumC);//不选择第index件物品 DFS_Kanapsack(index+1,sumW + w[index],sumC + c[index]);//选择第index件物品}int main(){ cin &gt;&gt; n &gt;&gt; V; for(int i = 0;i &lt; n;i++)//输入每件物品的重量 { cin &gt;&gt; w[i]; } for(int i = 0;i &lt; n;i++)//输入每件的价值 { cin &gt;&gt; c[i]; } DFS_Kanapsack(0,0,0);//初始时为第0件物品，重量为0，价值为0; cout &lt;&lt; MaxValue &lt;&lt; endl; return 0;} 由于每种物品有两种选择，因而易得上述算法的时间复杂度为$2^n$;这显然很是糟糕，因为在上述算法中，总是把对n件物品的选择全部确定后才去更新最大价值，但是却忽略了背包容量总是不能超过V这个点，也就是说，我们可以把选择index物品放入对上述条件的判断之中，若选择index后重量不超过V则才选择它。 改进后的算法：void DFS_Kanapsack(int index,int sumW,int sumC){ if(index == n) { return; } DFS_Kanapsack(index+1,sumW,sumC); if(sumW + w[index] &lt;= V) { if(sumC + c[index] &gt; MaxValue) { MaxValue = sumC + c[index]; } DFS_Kanapsack(index+1,sumW+w[index],sumC+c[index]); }}","link":"/2019/03/14/【算法】背包问题的DFS与DP解法/"},{"title":"【随笔】2018年终总结","text":"我的2018 9102年已经过去快一半了，一直能坐下来好好的对2018做一个总结。","link":"/2018/12/30/【随笔】2018年终总结/"},{"title":"人工神经网络学习比记（1）","text":"如何让网络可以学习上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况： 老师：1+1=？ 小明：6 老师：1+2=？ 小明：2 … 可以发现，当小明给出答案后老师并没有给于他反馈。因此小明可能某一次猜中了正确答案，但只是凑巧而已，他不具备学习能力。现在让老师给点反馈： 老师：1+5=？ 小明：4 老师：少了 小明：5 老师：少了 小明：6 老师：正确，你真棒！ 这样子，小明学会了1+5=6.我们的神经网络也需要具备这样的学习能力。也就是说，当网络输出错误的结果时要有一个改变下一次输出的机制。想要改变输出，可以改变哪些量呢？观察输出函数： O_{output}= \\left[ \\begin{matrix} Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot i_{oj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot i_{oj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot i_{oj}}) \\\\ \\end{matrix} \\right]=\\left[\\begin{matrix}o_1\\\\o_2\\\\o_3\\end{matrix}\\right]不难发现，输出值与以下参数有关： SigMoid函数 链接权重 输入值 显然，我们不可能去左右网络的输入值，因为那是网络要求解的问题，不可能以改变问题的方式改变答案。那么改变激活函数sig如何？这太麻烦了，试想那么多的神经元每一个都不同的激活函数会对运算造成大麻烦，将无法采用简洁的矩阵运算。因此，改变链接权重会是一个好办法。 学习能力的养成我们已经知道可以通过改变链接权重来改变网络的输出值，使其符合预期。那么问题又来了： 改变权重的依据是什么？ 如何改变？ 改变的幅度多大合适？ 改变的依据改变权重的目的是让输出值与期望值越接近越好（误差值越小越好），因此误差就是依据。所谓误差就是期望值与网络输出值的差： E=t-o我们知道输出层的误差为：$E_o=t_n-o_n$，但是其他层结点的误差是不知道的，因为其他层并没有一个输出期望值$t_n$。不难发现，最终输出层造成的误差是所有层共同作用的结果，所以可以将总误差分摊给其他层。 误差的反向传播 如上图误差为$e_1$，因为链接权重越大说明对该误差的影响越大，因此以链接权重来决定每条链路所分摊误差的大小： e_{w_{1,1}}=\\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\\cdot e_1 e_{w_{2,1}}=\\frac{w_{2,1}}{w_{1,1}+w_{2,1}}\\cdot e_1反向传播误差到更多层中：隐藏层结点的误差值： e_{h1}=\\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\\cdot e_{o1}+\\frac{w_{1,2}}{w_{1,2}+w_{2,2}}\\cdot e_{o2} 使用矩阵乘法简化误差反向传播 误差向量： error_{output}= \\left( \\begin{matrix} e_1 \\\\ e_2 \\end{matrix} \\right) 隐藏层误差： error_{hidden}= \\left( \\begin{matrix} \\frac{w_{1,1}}{w_{1,1}+w_{2,1}} & \\frac{w_{1,2}}{w_{1,2}+w_{2,2}} \\\\ \\\\ \\frac{w_{2,1}}{w_{1,1}+w_{2,1}} & \\frac{w_{2,2}}{w_{1,2}+w_{2,2}} \\end{matrix} \\right) \\cdot \\left(\\begin{matrix}e_1 \\\\ e_2 \\end{matrix} \\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)上述矩阵乘法太过复杂，无法通过简单的矩阵运算求解。观察上式可知，最重要的事情是输出误差链接权重$w_{j,k}$的乘法。较大的权重携带较大的误差给隐藏层，这些分数的分母是一种归一化因子。如果我们忽略掉这个因子，我们仅仅只是失去了后馈误差的真实值大小，但并没有失去其表示的真正含义（影响力）,也就是说反馈误差始终是以链接权重的强度来分配的。因此上式可以简化为： error_{hidden}= \\left( \\begin{matrix} w_{1,1} & w_{1,2} \\\\ w_{2,1} & w_{2,2} \\end{matrix} \\right)\\cdot \\left(\\begin{matrix}e_1\\\\ e_2\\end{matrix}\\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)不难发现，隐藏层至输出层的链接权重矩阵$W_{hidden\\rightarrow output}$为: W_{hidden\\rightarrow output}= \\left( \\begin{matrix} w_{1,1} & w_{2,1} \\\\ w_{1,2} & w_{2,2} \\end{matrix} \\right)=\\left( \\begin{matrix} w_{1,1} & w_{1,2} \\\\ w_{2,1} & w_{2,2} \\end{matrix} \\right)^T因此： error_{hidden}=W_{hidden\\rightarrow output}^T\\cdot error_{output}= \\left( \\begin{matrix} w_{1,1} & w_{2,1} \\\\ w_{1,2} & w_{2,2} \\end{matrix} \\right)^T\\cdot \\left(\\begin{matrix}e_1\\\\ e_2\\end{matrix}\\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)到此我们得到了用矩阵来传播误差的算法： error_{hidden}=W_{hidden\\rightarrow output}^T\\cdot error_{output} 到此，我们已经做了大量的工作了。我们计算出了所有层的误差，接下来的工作就是根据误差来调整链接权重了。","link":"/2019/06/03/人工神经网络学习比记（1）/"},{"title":"人工神经网络学习笔记（0）","text":"何为人工神经网络人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。 生物神经元关键部件： 树突 &amp; 胞体 &amp; 轴突 单个神经元的工作机制可以简单地描述为：树突接受其他神经元的神经末梢传来的电信号，信号传送到胞体并由某种机制决定是否激发下一次电信号的传递，若激发则电信号由轴突传递至神经末梢，再由神经末梢传递给其他神经元。其中，判断是否激发的机制有一大好处是可以减小神经元间微弱电信号（噪声）的干扰，使得自由足够强的电信号才能激发下一次传递。 人工神经元概览 由生物神经元得到的启发，人工神经元与其大同小异。上图中： $x_1,x_2,x_3,x_4$ 为该神经元树突所接受到的其他神经元传来的电信号。中间的圆圈为胞体，在胞体中将会由处理信号的机制，以决定输出信号y。功能 在之前的生物神经元中已经说道，神经元对是否激发信号传递有一个判断机制，这是因为神经元不希望传递微小的噪声信号，而只传递有意识的明显信号。只有信号强度达到了某一个阙值，才会激发电信号的传递。那么在人工神经元中我们如何来实现这个机制呢？ 这样的一个函数也许能够满足我们的需要：Function(x) = \\begin{cases} 0 & x \\leq T \\\\ 1 & x>T \\end{cases}显而易见，这个简单的阶跃函数在输入信号大于T（阙值）时才会产生输出信号1（被激发），而较小的输入时输出为0（被抑制）；我们称这样的函数为激活函数。当然，激活函数不会就只有这么一种。常用的还有sigmoid函数：Sigmoid(x) = \\frac{1}{1+e^{-x}}函数图像：可以发现，sigmoid函数相对于阶跃函数而言更加平滑，自然，接近现实。我们的神经网络也将采用它。如此一来，我们的单个神经元模型就成型了：参数含义： $x_1 ,x_2… x_m$为输入信号 $w_1 ,w_2… w_m$为权重值，表示各个输入信号对输出结果的影响力大小。对于为何引入权值可以做如下思考：你去相亲，你对未来对象的考量主要有身高，长相，身材，文化程度等，但遇到样样都好的概率实在是太底了，所以你决定适当放宽某些要求。比如如果学历高就可以降低身材长相的要求。这表示你比较注重伴侣的文化程度。因此，对方的文化程度对你的择偶有着重要的影响，其所占权重就会比较高。 求和函数将计算$x=\\sum_{m}{x_iw_i},i=1,2,…m$后将所得的值传给激活函数Sigmoid即：Output=Sig(x)=\\frac{1}{1+e^{-(\\sum_{m}{x_iw_i})}}观察函数图不难发现，Sigmoid函数将加权求和的输入映射到0~1的值域内输出。人工神经网络介绍完单个神经元的功能，如果把这些小部件组合起来，就成了所谓的人工神经网络。层次结构： 输入层：接受外部输入信息，可以是图片等。 隐藏层：隐藏层层数不一，可根据需求来定。 输出层：将结果输出到外部。 链接方式： 除输入层外，每一层的每个神经元都接受其上一层所有神经元传来的信号的加权值。 神经元的链接方式并不唯一，你可以创造自己的链接方式，但为了便于抽象计算编码，规则的链接方式能帮我们大忙。 一个三层神经网络示例 参数释义： $i_1,i_2,i_3$为输入信号。 $w_{j,k}$表示后层结点$j$与前一层节点$k$之间链接的权重值。 $o_1,o_2,o_3$为该网络输出的结果信号。 信号的前向传播：前面我们介绍了单个人工神经元对信号的处理。但是现在网络中有多个神经元，我们当然不愿意对每一个神经元节点都进行编码计算，因此我们将其简化为矩阵运算。 将输入看成一个多维列向量： I= \\left[ \\begin{matrix} i_1 \\\\ i_2 \\\\ i_3 \\end{matrix} \\right] 链接权重为一个$3\\times3$的矩阵： W_{input\\rightarrow hidden}= \\left[ \\begin{matrix} w_{1,1} & w_{2,1} & w_{3,1} \\\\ w_{1,2} & w_{2,2} & w_{3,2} \\\\ w_{1,3} & w_{2,3} & w_{3,3} \\end{matrix} \\right] 将两者相乘得到隐藏层的输入信号： I_{hidden}=W_{input\\rightarrow hidden}\\cdot I= \\left[ \\begin{matrix} w_{1,1}\\cdot i_1 + w_{2,1}\\cdot i_2 + w_{3,1}\\cdot i_3 \\\\ w_{1,2}\\cdot i_1 + w_{2,2}\\cdot i_2 + w_{3,2}\\cdot i_3 \\\\ w_{1,3}\\cdot i_1 + w_{2,3}\\cdot i_2 + w_{3,3}\\cdot i_3 \\end{matrix} \\right]也即： I_{hidden}= \\left[ \\begin{matrix} \\sum_{j=1}^{3}{w_{j,1}\\cdot i_j} \\\\ \\sum_{j=1}^{3}{w_{j,2}\\cdot i_j} \\\\ \\sum_{j=1}^{3}{w_{j,3}\\cdot i_j} \\end{matrix}\\right]=[i_{h1},i_{h2},i_{h3}]^T 再将加权求和的信号值经过Sigmoid激活函数处理我们可以得到最终的输出向量： O_{hidden}=Sig(W_{hidden\\rightarrow output}\\cdot I_{hidden})= \\left[ \\begin{matrix} Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot o_{hj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot o_{hj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot o_{hj}}) \\\\ \\end{matrix} \\right]=[o_{h1},o_{h2},o_{h3}]^T这里需要注意的是，输入层到隐藏层的链接权重矩阵与隐藏层到输出成的链接权重矩阵是不同的矩阵。但是计算过程是一致的，因此同理可得： I_{output}=Sig(W_{hidden\\rightarrow output}\\cdot O_{hidden})网络的最终输出为： O_{output}= \\left[ \\begin{matrix} Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot i_{oj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot i_{oj}}) \\\\ Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot i_{oj}}) \\\\ \\end{matrix} \\right]=[o_1,o_2,o_3]^T到此，我们已经了解了神经网络中信号的前向传播机制，但是目前这个网络模型远远达不到我们的要求，它除了单纯的传播信号什么事情也做不了。显然后续我们得为其添加反馈机制，使其能够具有学习能力。","link":"/2019/06/03/人工神经网络学习笔记（0）/"},{"title":"人工神经网络学习笔记（2）","text":"如何更新权重在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？ 暴力枚举：对于一个三层的神经网络，每层有3个神经元结点，有两个$3\\times 3$的链接权重矩阵，共有18个权重值。假设每个权重在1和-1之间共有1000种取值，那么我们有$1000^{18}$种权重组合，这个数字已经很大了。但是，如果是每层有500个结点呢？那么权重数将达到$2\\times 500\\times 500 = 500000$个，将会有$1000^{500000}$种组合。想要遍历这么些种可能得等到人类灭绝… 可见，暴力枚举并不能实际地解决我们的问题。 新的思路：让我们再次明确下我们的最终目的，让误差值降到最小。试着将其转化成数学上的求函数最小值问题。先前我们知道，误差是所有链接权重的函数: Error = F_{error}(w_{1,1},w_{2,1},......,w_{j,k})现在我们需要额就是找出该函数的最小值。但由于真正的误差函数的自变量太多，先举个简单的例子：假设误差函数只有一个自变量（链接权重）： E_{simple}=F_e(x)其图像为：可以将其想象成一个连绵的山脉，有山峰也有山谷。设想将一个小球至于山腰，那么在重力的作用下它必定沿着所在位置的斜率方向向下滚动直到山谷。但是很明显，我们并没有重力帮忙，因此必须人为指定“滚动方向”。不难发现，当斜率为正时应向左滚动（x—），斜率为负时应向右滚动（x++）。这种方法在数学上被称为梯度下降（gradient descent）。可能的意外情况：我们可能会碰到这种情况：当小球的起始位置为左侧山腰时，其很有可能最终会在局部最小值（左侧的山谷）停下，这可不是我们所希望的结果。因为我们的目的是把误差降到最小，那里显然不是最小的地方。为了避免上述情况，我们应从选择不同的其实位置对神经网络进行多次训练，以确保其并不总是终止于错误的地方。而不同的其实位置意味着不同的链接权重。 选择误差函数的形式可选项： $E=t_n-o_n$ (目标值 - 期望值) $E=(t_n-o_n)^2$ 方差形式 我们选用方差形式，因为其具有很多优点： 可以很容易地使用代数方法（链式法则求解偏导数）计算出梯度下降的斜率 误差函数平滑连续，这使得梯度下降算法可以很好地发挥作用 越接近最小值梯度（斜率）越小，按照斜率调整步长可以减少越过最佳位置的风险 计算梯度值（斜率） 当只有一个链接权重时，误差函数为二维曲线： k=\\frac{\\partial{E}}{\\partial{x}} 当有两个链接权重时，误差函数为一个三维曲面： k=\\frac{\\partial{E}}{\\partial{w_{j,k}}}上述表达式表示了当权重$w_{j,k}$改变时，误差$E$是如何改变的。这是误差函数的斜率，也就是我们希望使用梯度下降的方法达到最小值的方向。 计算梯度： 在开始计算前我们回顾一下网络中各个参数的意义： 展开误差函数：由于一个结点的误差只与与其相连的链接权重有关，因此误差函数可以简单地表示为： E=(t_k-o_k)^2其中：$ok=Sig(\\sum{j=1}^{n}{w{j,k}\\cdot o{hj}})$所以： E=(t_k-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))^2所以： \\frac{\\partial{E}}{\\partial{w_{j,k}}}=\\frac{\\partial{(t_k-o_k)^2}}{\\partial{w_{j,k}}} =\\frac{\\partial{E}}{\\partial{o_k}}\\cdot \\frac{\\partial{o_k}}{\\partial{w_{j,k}}}=-2(t_k-o_k)\\cdot \\frac{\\partial{o_k}}{\\partial{w_{j,k}}}其中：令$x=\\sum{j=1}^{n}{w{j,k}\\cdot o_{hj}}$ \\frac{\\partial{o_k}}{\\partial{w_{j,k}}}=\\frac{\\partial{Sig(x)}}{\\partial{w_{j,k}}}=\\frac{\\partial{Sig(x)}}{\\partial{x}}\\cdot \\frac{\\partial{x}}{\\partial{w_{j,k}}}且： \\frac{\\partial{Sig(x)}}{\\partial{x}}=Sig(x)\\cdot (1-Sig(x))因此，我们得到了以下表达式： \\frac{\\partial{E}}{\\partial{w_{j,k}}}=-2(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot \\frac{\\partial{(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}})}{\\partial{w_{j,k}}} =-2(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj}又由于我们只关心误差函数斜率的方向，因此可以将公式中的常数2省略，并不影响正负号： \\frac{\\partial{E}}{\\partial{w_{j,k}}}=-(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj} =-(e_j)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj} 改变链接权重之前提到过，权重的改变方向与梯度的方向相反。因此我们规定权重的改变方式为： w_{j,k}^{new}=w_{j,k}^{old}-\\alpha \\cdot \\frac{\\partial{E}}{\\partial{w_{j,k}}}参数释义： $\\alpha$为学习因子，可以调节这些权重变化的强度 用矩阵来简化运算： \\left( \\begin{matrix} \\vartriangle w_{1,1} & \\vartriangle w_{2,1} & \\vartriangle w_{3,1} & ...\\\\ \\vartriangle w_{1,2} & \\vartriangle w_{2,2} & \\vartriangle w_{3,2} & ...\\\\ \\vartriangle w_{1,3} & \\vartriangle w_{2,3} & \\vartriangle w_{3,3} & ...\\\\ ... & ... & ... & ... \\end{matrix} \\right)=\\alpha\\cdot \\left(\\begin{matrix}e_1\\cdot S_1\\cdot (1-S_1)\\\\ e_2\\cdot S_2\\cdot (1-S_2)\\\\ e_k\\cdot S_k\\cdot (1-S_k)\\\\ ...\\end{matrix}\\right) \\cdot (o_1,o_2,o_3,...)将Sig函数简化为输出： \\vartriangle w_{j,k} = \\alpha\\cdot E_k \\cdot O_k \\cdot (1-O_k) \\cdot O_j^T 到此，所有的前期工作都已完成。","link":"/2019/06/04/人工神经网络学习笔记（2）/"},{"title":"博客迁移后的发布测试","text":"测试文章发布是否正常 迁移过程之后会整理出来","link":"/2019/03/05/博客迁移后的发布测试/"}],"tags":[{"name":"Boring","slug":"Boring","link":"/tags/Boring/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Knapsack","slug":"Knapsack","link":"/tags/Knapsack/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"ML","slug":"ML","link":"/tags/ML/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"教程","slug":"教程","link":"/categories/教程/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"底层原理","slug":"底层原理","link":"/categories/底层原理/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"机器学习","slug":"机器学习","link":"/categories/机器学习/"}]}