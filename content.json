{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"HexoEditor","text":"HexoEditor HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。GitHub：HexoEditor Step1: 安装 HexoEditor: 下载链接：Download 支持 Linux 、Windows 、MacOS Step2: 简单设置： Hexo配置文件选择网站根目录下的_config.yml文件 Tag模板目录选择网站很目录下的 /scaffolds 文件夹 主题随意选择 默认资源库可在网站根目录source文件夹内新建文件夹来存放文章图片资源 云图类型可默认，SM.MS云图为免费云端，也可自选其他云端服务 Step3:撰写文章： 点击新建Post可生成新的模板文档，开始写作。 在预览试图中右键点击所插入的图片，点击上传至SM.MS可将本地图片上传至云端，之后会发现文章中的图片Path变为URL链接。 Step4:发布文章： 右键 –&gt; Hexo –&gt; 部署网站","link":"/2019/01/27/HexoEditor/"},{"title":"Hello Friend","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/01/27/hello-world/"},{"title":"Queue and Stack","text":"栈和队列 栈和队列的基本概念 栈的基本概念 栈的定义 只能在一端（栈顶Top）进行插入和删除操作的线性表 栈顶由一个称为栈顶指针的位置指示器top来指示，它是动态变化的 表的另一端栈底是固定不变的 栈的特点 先进先出（ＦＩＬＯ） 栈就如同一个狭窄的死胡同，最先进去的人（元素）只能够最后出来 栈的存储结构 可以用顺序表或者链表来存储栈： a) 顺序栈 b) 链式栈 栈的数学性质 当ｎ个元素以某种顺序进栈，并且可以在任何时候出栈（在满足先进后出的前提下）时，所获得的元素排列的数目Ｎ恰好满足函数 Catalan() 的计算，即：$$N = {\\dfrac{1}{n+1}}×C\\binom{n}{2n}$$ 队列的基本概念 队列的定义 是一种操作受限的线性表，且只允许在表的一端进行插入，在另一端进行删除操作。 可以插入的一端称为队尾（ｒｅａｒ），可以删除的一端称为队头（ｆｒｏｎｔ） 插入元素称为进队，删除元素称为出队 队列的特点 先进先出（ＦＩＦＯ），就像食堂打饭要排队一样，先来的人先有饭吃 队列的存储结构 可用线性表或者链表来存储队列： a) 顺序队 b) 链队 栈和队列的存储结构、算法与应用 顺序栈的定义 1234typedef struct SqStack { int data[Maxsize]; //一维数组用来存储数据 int top; // ｔｏｐ指针用来指向栈顶元素,规定top=-1 为栈空，top=Maxsize-1 为栈满} 链栈结点的定义 1234typedef struct LNode { int data; // 数据域 struct LNode *next; // 指针域}LNode; 顺序队列的定义 12345typedef struct SqQueue { int data[Maxsize]; //数组存放数据 int front; // 队首指针 int rear; // 队尾指针} 链队的定义a) 链队结点定义： 1234typedef struct LQNode{ int date; //数据域 struct LQNode *next; //指针域 } b) 链队类型定义： 12345// 定义一个只包含两个指针域的结点来存放队头与队尾指针 typedef struct LiQueue{ struct LQNode *front; // 队首指针 struct LQNode *rear; // 队尾指针 } // 链队类型定义 顺序栈 顺序栈的几个关键要素： 三个状态 栈空状态：st.top = -1; 栈满状态：st.top = Maxsize - 1; 非法状态：栈满却继续入栈发生上溢；栈空继续出栈发生下溢； 两个操作 元素进栈：++(st.top); st.data[st.top]=x; 元素出栈：x=st.data[st.top]; –(st.top); 初始化栈：1234// 初始化一个栈，只需将栈顶指针置为－１即可void initStack(){ int top = -1;} 判断栈空代码：1234567int EmptyStack(SqStack ss){ if (ss.top == -1) return 1; // 栈空返回１； else return 0; // 栈非空返回０；} 进栈代码：12345678#defined Error 0int push(SqStack &amp;ss, int x){ if (ss.top == -1) return Error; // 栈满时返回错误，无法入栈 ss.top++; ss.data[ss.top] = x; // 也可一句话解决： ss.data[++ss.top] = x; return 1; //入栈成功返回１} 出栈代码：1234567int pop(SqStack &amp;ss,int e){ if (ss.top == -1) return Error; // 栈空不能出栈 e = ss.data[ss.top]; --ss.top; // 也可一句话解决： e = ss.data[ss.top--]; return 1;} 【注】:1对于自增操作，入++a;总是比a++;的执行效率要高一些，因此在使用二者都可以的情况下优先选择++a; 链栈 以下链栈都由带头结点的链表表示 顺序栈的几个关键要素： 两个状态 栈空状态：lst –&gt; next = NULL; 栈满状态：不存在栈满状态，因为单链表的内存空间是动态分配的 两个操作 元素（由指针ｐ所指）的进栈操作：p -&gt; next = lst -&gt; next; lst -&gt; next = p;//其实 就是头插法建立单链表的操作 出栈操作：s = lst -&gt; next; x = s -&gt; data; lst -&gt; next = s -&gt; next; free(s); //其实就是单链表的删除操作 链栈的初始化代码：12345// 实际上，链栈的初始化与单链表的初始化并无不同void initLStack(LNode *&amp;lst){ lst = (LNode*)malloc(sizeof(LNode)); //制造一个头结点 lst -&gt; next = NULL; // 将链栈滞空} 判断栈空代码：123456int isEmpty(LNode lst){ if (lst -&gt; next == NULL) return 1; //栈空返回１； else return 0; // 栈不空返回０；} 进栈代码：1234567int push(LNode &amp;lst,int x){ LNode s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = lst -&gt; next; lst -&gt; next = s; return 1;} 出栈代码：12345678int pop(LNode &amp;lst, int &amp;e){ // 用e返回出栈元素的值 if (lst -&gt; next == NULL) return 0; e = lst -&gt; next -&gt; data; LNode *s = lst -&gt; next; lst -&gt; next = s -&gt; next; free(s); return 1;} 栈的应用 栈的主要应用有： 括号匹配 表达式求值 逆波兰转换算法 括号匹配 算法思想： 扫描整个表达式，判断当前符号是否为括号 如果不是，继续扫描下一个字符 如果是，判断是左括号还是右括号，是左括号将其入栈，是右括号就判断栈是否为空 若栈为空，说明此表达式的右括号多与左夸号 若栈不空则判断当前操作符是否和栈顶操作符匹配，若不匹配说明左右括号不匹配，若匹配则继续判断 下一个操作符。最后，判断栈是否为空，若不空则说明左括号多余右括 号，栈为空说明匹配成功。 123456789101112131415161718192021initStack(Stack stack){ for (int i ;i&lt;strlen(str);i++){ if (str[i]=='{' || str[i]=='[' || str[i]=='('){ push(stack,str[i]); } else { if (str[i]=='{' &amp;&amp; getTopStack(stack) == '}') pop(stack); if (str[i]=='[' &amp;&amp; getToPStack(stack) == ']') pop(stack); if (str[i]=='(' &amp;&amp; getTopStack(stack) == ')') pop(stack); } } // 最后，若栈空则匹配成功，否则失败 if(isEmpty() == true){ cout &lt;&lt; \"括号匹配成功 ！！！\" &lt;&lt; endl; } else cout &lt;&lt; \"匹配失败 ！！！\" &lt;&lt; endl;} 表达式求值 算法思想： 扫描表达式，当扫描到数时将其推入栈中，当扫描到一个运算符时，将该运算符作用于位于栈顶的两个数上，并将所得结果推入栈中 以下将给出后缀表达式的求值程序 1234567891011121314151617int calcExp(char* exp , Stack s){ int i = 0; while (exp[i] != '\\0'){ // if (exp[i]&gt;='0' &amp;&amp; exp[i]&lt;='9'){ s.push(s , exp[i]-'0'); // 若为数字，推入栈中 } else if(exp[i] == '运算符'){ int m = s.gettop(); // 取栈顶元素后将其出栈 s.pop(); int n = s.gettop(); // 取栈顶元素后将其出栈 s.pop; s.push(s, n[运算符]m); // 将运算结果推入栈中 } i++; // 继续遍历 } return s.top;} 逆波兰转换算法 算法思想： 设立一个栈，存放运算符，初始栈为空，编译程序从左往右扫描中缀表达式，若遇到数字，直接输出，并输出一个空格为两个操作数之间的分隔符； 若遇到运算符，则与栈顶比较，若运算符级别比栈顶级别高则进栈，否则退出栈顶元素并输出，之后输出一个空额作分隔符 所遇到左括号，紧张； 若遇到右括号，则一直退栈粗出知道退出第一个左括号为止 当栈为空时，输出的结果即为后缀表达式 123456789101112131415161718192021void tranfExp (char* exp , Stack s){ while (exp[i] != '\\0'){ if (exp[i] &gt;= '0' &amp;&amp; exp[i] &lt;= '9'){ // 若为数字，直接输出 } else if (exp[i] == '('){ // 若为左括号，进栈 } else if (exp[i] == ')'){ // 若为右括号，出栈直至第一个左括号 } else if (exp[i] == '运算符'){ // 判断与栈顶元素的优先级大小 if (exp[i] &gt; s.gettop()) s.push(exp[i]); // 优先级大于栈顶运算符，将该运算符进栈 else // 优先级小于栈顶运算符，退出栈顶元素并且输出 while (s.isEmpty() == false) pop();// 把栈中剩余元素全部退出并输出 } }} 顺序队 循环队列 循环队列的基本要素 两个状态： 队空状态：qu.rear = qu.front; 队满状态：(qu.rear+1)%front == qu.front ; 两个操作： 元素x进队操作：qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; 出队操作：qu.front = (qu.front+1)%MaxSize; elem = qu.data[qu.front];//elem 保 存出队的元素 循环队列的基本操作实现 初始化队列算法： 1234void initQueue(Queue &amp;qu){ qu.front = 0; qu.rear = 0; } 判断队空算法： 123456int isQEmpty(Queue qu){ if (qu.front == qu.rear){ return 1; // } return 0; //} 进队算法： 123456789int enterQueue(Queue &amp;qu , int x){ if ((qu.rear+1)%MaxSize == front){ cout &lt;&lt; \"队列已满\" &lt;&lt; endl; return 0; } qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; return 1;} 出队算法： 123456789int outQueue(Queue &amp;qu , int e){ if (qu.rear == qu.front){ cout &lt;&lt; \"队空无法出队\" &lt;&lt; endl; return 0; } qu.front = (qu.front+1)%MaxSize; e = qu.data[qu.front]; return 1;} 链队采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限 链队的基本要素 两个状态： 队满状态： 不存在队满状态 队空状态：que.rear = NULL || que.front = NULL (两个满足一个即可) 两个操作： 元素q进队操作： 分两种情况1. 当前队为空：que --&gt; rear = que --&gt; front = q; 2. 当前队不空：que --&gt; rear --&gt; next = p;que --&gt; rear = p; 元素出队操作： s = que –&gt; front; que –&gt; front = s –&gt; next;elem = s –&gt; data; free(s); 链队的基本操作实现1.初始化链队算法：12345void initLiQueue(LiQueue *&amp;que){ que = (LiQueue*)malloc(sizeof(LiQueue)); que -&gt; rear = NULL; que -&gt; front = NULL; } 2.判断队空算法：1234567int isEmpty(LiQueue que){ if (que.rear = NULL || que.front = NULL){ cout &lt;&lt; \"队列为空\" &lt;&lt; endl; return 1; } return 0;} 3.入队算法：12345678910111213int enterLiQueue(LiQueue &amp;que ， int x){ LQNode* s = (LQNode*)malloc(sizeof(LQNode)); if (isEmpty(que)){ // 若队列为空，进队操作比较特别 que -&gt; front = que -&gt; rear = s; return 1; } else{ que -&gt; rear -&gt; next = s; que -&gt; rear = s; return 1; } return 0;} 4.出队算法：123456789101112131415int outLiQueue(LiQueue &amp;que , int &amp;elem){ LQNode* s = que -&gt; front; if (isEmpty()){ cout &lt;&lt; \"队为空，无法出队\" &lt;&lt; endl; return 0; } if (que -&gt; front == que -&gt; rear){ // 若队列只有一个元素，出队操作比较特别 que -&gt; front = NULL; que -&gt; rear = NULL; } que -&gt; front = s -&gt; next; elem = s -&gt; data; free(s); return 1;}","link":"/2019/01/27/QueueStack/"},{"title":"Array Marix GeneralList","text":"数组、矩阵与广义表 数组： 常见的数组有一维数组和二维数组，二维数组是元素可以看成是一维数组的一维数组。对于数组主要考察元素下标计算的问题。对于一维数组较为简单，而对于二维数组的元素位置计算较为复杂，要考虑行优先和列优先两种情况。 二维数组的行优先和列优先存储： 行优先：从起始行开始一行一行地存入连续空间中 列优先：从起始列开始一列一列地存入连续空间中 矩阵的压缩存储： 矩阵的定义 矩阵一般用一个二维数组A[m][n]表示，表示一个m行n列的矩阵 其中m n 必须为常量，或者为预先定义的宏常量，如下：123#define m 5#define n 6int A[m][n]; 矩阵的一般操作与实现 矩阵的转置： 1234567void transpose(int A[][maxsize],int B[][maxsize],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n ; ++j){ B[j][i] = A[i][j]; // 矩阵转置操作，元素关于主对角线互换位置 } }} 矩阵相加: 1234567void addition(int A[][max],int B[][max],int C[][max],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n){ c[i][j] = A[i][j] + B[i][j]; //对应位置元素相加 } }} 矩阵相乘： 12345678910void Multiply(int A[m][n],int B[n][k],int C[m][k],int m,int n,int k){ for(int i = 0;i&lt;m;++i){ for (int j = 0;j&lt;k;++j){ C[i][j] = 0; for(int h = 0;h&lt;n;++h){ C[i][j] += A[i][h] * B[h][j]; } } }} 特殊矩阵和稀疏矩阵 矩阵中绝大多数元素都是0的矩阵称为稀疏矩阵(国外教材) 相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵(严版) 特殊矩阵：a) 对称矩阵 矩阵中的元素满足A[i][j] = A[j][i] 的矩阵称为对称矩阵 如上图所示，只需要存储一半的元素就可以了，要还原出另一半只需根据A[i][j] = A[j][i]这个条件就行了。 将一个n×n的对称矩阵存储在一维数组中，所需的存储空间为 $ \\dfrac{(1+n)*n}{2}$ 需要保存的元素为： 按照行优先来存储，保存在一维数组中，如下图所示：b)三角阵 上三角矩阵 为矩阵下三角部分(不包括对角线)元素全为零 下三角矩阵 为矩阵上三角部分(不包括对角线)元素全为零 三角矩阵的存储方式与对称矩阵类似，以下三角矩阵的存储为例，只需存储对角线及其以下部分的元素和其上三角中的一个元素C即可，如下图： c)对角矩阵 如下图所示的对角矩阵，其特点为除了主对角线以及其上下两条带状区域的元素外，其余元素都为C ( C可以为0)： 下面介绍如何求出第i行带状区域内的第一个元素在一维数组中的下标，假设c存在数组的最后一位： 当i=1时，带状区域内的第一个元素为矩阵当中的第一个元素，其在一维数组中的下标为0； 当i&gt;1时，第i行之前的元素个数为 $2+(i-2)×3$，则带状区域的第一个元素在一维数组中的下标为 $2+(i-2)×3$2.稀疏矩阵 稀疏矩阵中的相同元素c不像特殊矩阵中的相同元素的位置分布那么有规律可循，故必须为其设计一些特殊的存储结构 稀疏矩阵的顺序存储及其相关操作：常用的稀疏矩阵顺序存储方法有三元组表示法，和伪地址表示法。 三元组表示法：三元组数据结构为一个长度为n，表内每个元素都有三个分量的线性表，其三个分量分别为：“值”、“行下标”、“列下标”。元素结构体定义如下：12345typedef struct Trimat{ int val; // 值 int i; // 行下标 int j; // 列下标}； 结构体示意图：结构题数组的定义：1Trimat trimat[maxterms + 1]; // maxterms + 1;因为从第 1 行才开始存储元素 但是，为了方便起见，一般不用上诉结构体来定义三元组，直接申请一个二维数组就可以了：123456789int trimat[maxterms + 1][3];// 如要求其他类型，可将int替换掉// 需要注意的是，如果矩阵是float型的（或者其他非整型的数据类型）// 则此时用一个数组来表示三元组应该写成如下形式：float trimat[maxterms + 1][3];// 这个时候若要取当前非零元素的所在位置应该这么做： (int)trimat[k][1]; (int)trimat[k][2];// 就是将float 型的元素造型成int型，这样就可以避免很多不必要的问题的发生 上诉定义方式中：trimat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值trimat[k][1]、trimat[k][2]表示第k个非零元素在矩阵中的位置。事实上，trimat此时就是一个maxterms 行 3 列的二维数组，我们规定第0行的三个元素分别用来存储原矩阵中的非零元素个数，以及矩阵的行数与列数。示意图如下： 给定一个二维数组存储的矩阵，要求设计算法将其转化为三元组存储： 算法分析：建立一个三元组的核心问题在于求矩阵的非零元素个数以及非零元素的值，还有其在矩阵（原数组）中的位置，故只需扫描所给矩阵的二维数组即可得到相关数据，进而建立三元组。 123456789101112131415161718// 建立三元组时，结点间的次序行按元素在矩阵中的行优先顺序排列void creattrimat(float A[][max],int m,int n,float B[][3]){// m,n 表示所给矩阵的规模为m×n int k = 1; for (int i = 0;i&lt;m;++i){ for (int j =0;j&lt;n;++j){ // 双重循环扫描矩阵 if (A[i][j] != 0){ // 若矩阵的[i][j] 上的元素不为零，将该元素连同其位置信息存入三元组中 B[k][0] = A[i][j]; B[k][1] = i; B[k][2] = j; k++; // k 指向三元组的下一个空间 } } } B[0][0] = k-1; // 将矩阵的基本信息存入三元组的第0行 B[0][1] = m; B[0][2] = n;} 设计算法打印出所给三元组存储的矩阵： 算法分析：读取三元组的第0行，得到矩阵的相关信息循环按行打印，若下标与三元组中的非零元素下标信息匹配则打印该非零元素，否则，打印0；1234567891011121314void print(float trimat[][3]){ int m = trimat[0][1]; int n = trimat[0][2]; int k = 1; // 非零元素从第一行开始存储 for(int i = 0;i&lt;m;i++){ // 双重循环打印矩阵 for(int j = 0;j&lt;n;j++){ // 循环过程中检查第[i][j]下标是否与三元组中的非零元素相同，若相同打印该非零元素，若不同打印 0 ； if(i = (int)trimat[k][1] &amp;&amp; j == (int)trimat[k][2]){ cout &lt;&lt; trimat[k][0] &lt;&lt; \" \"; ++k; } else cout &lt;&lt; \"0 \" &lt;&lt; endl; } }} 伪地址表示法：伪地址表示法与三元组表示法在本质上并无差别，只不过是三元组表示法的每一行用两个存储单元来存放原矩阵非零元素的位置标记，而伪地址表示法可以只用一个存储单元来存放位置标记，原因是因为对于一个$ m×n $的矩阵，伪地址表示法将元素位置下标的两个整数用一个公式映射( $ n×(i-1) +j $)到了一个整数上，同样利用该公式也可还原原i和j的值。我们来看一个例子： 稀疏矩阵的链式存储及相关操作： 邻接表表示法：邻接表表示法将矩阵中每一行的非零元素串联成一个单链表，链表结点中有三个分量：元素值、所在列、指针域结点的定义如下：12345typedef struct Listmat{ int data; int col; struct Listmat *next;}; 示意图如下：上图中最左端为一个指针数组，用来存储指向每一行非零元素单链表的头指针，数组下标为表示行标号。 十字链表表示法：在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点有 5 个分量：行分量、列分量、数据域、指向下方结点的指针域、指向右方结点的指针域；结构图如下：普通结点定义：1234567typedef struct matNode{ int row; int col; int data; struct matNode *down; struct matNode *right;}; 头结点定义:1234typedef struct CrossList{ struct matNode *rhead,*cheard; // 指向两头结点数组的指针 int m,n,k; // 矩阵行数、列数、非零结点总数} 由于十字链表存储结构比较复杂，我们将通过其结构图例来深入了解它，图中附有详细的注释： 上图中，银灰色的结点为行头结点数组与列头结点数组，他们的定义如下：1234567// 其中的m n 为矩阵的行数和列数typedef struct Rhead{ // 行头结点数组 struct matNode Rhead[m]; // 元素为matNode结点的数组};typedef struct Chead{ // 列头结点数组 struct matNode Chead[n];} 在理解了十字链表存储结构后，我们来看一个实际的应用：给定一个float型二维数组存储的稀疏矩阵，建立其对应的十字链表结构。算法分析：首先应该建立整体框架，也就是十字链表头结点以及行、列头结点数组。然后，按行优先顺序遍历矩阵数组，若发现不为零的元素，分配一个结点空间将其值存入，调整行、列头结点的指针域指向该结点，如此直到结束遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int creatCrossListmat(float A[][maxsize],int m,int n,int k,CrossList &amp;M){ //============================================ // 搭建基本框架操作 //============================================ // 清空处理： if (M.rhead) free(M.rhead); if (M.chead) free(M.chead); // 将矩阵信息存入十字链表头结点： M.m = m; M.n = n; M.k = k; // 申请行、列头结点数组空间： if (!(M.rhead = (matNode*)malloc(sizeof(matNode)*m))) return 0; if (!(M.chead = (matNode*)malloc(sizeof(matNode)*n))) return 0; // 将行、列头结点数组的right和down指针置空： for(int i = 0;i &lt; m ; ++i){ M.rhead[i].right = NULL; M.rhead[i].down = NULL; } for(int i = 0;i &lt; n ;++i){ M.chead[i].right = NULL; M.chead[i].down = NULL; } //=================================================== // 核心算法 //=================================================== // 建立链表的辅助指向列头结点的指针数组： matNode *temp_r[maxsize]; for(int i = 0;i&lt;n;++i){ temp_r[i] = &amp;(M.chead[i]); // 引用 } // 行优先顺序遍历矩阵数组构建十字链表： for(int i = 0;i &lt; m ;++i){ matNode *c = &amp;(M.rhead[i]); for(int j = 0;j &lt; n;++j){ if (A[i][j] != 0){ matNode *p = (matNode*)malloc(sizeof(matNode)); p -&gt; row = i; p -&gt; col = j; p -&gt; val = A[i][j]; p -&gt; down = NULL; p -&gt; right = NULL; // 如果某行（列）中已经连接了元素，那么就让这个元素充当该行（列）的头部，这样能使十字链表的行（列）头结点数组中的结点避免重复指向，覆盖；所以下面的代码所要做的事情很重要。 c -&gt; right = p; c = p; temp_r[j] -&gt; down = p; temp_r[j] = p; } } } return 1;} 广义表 表元素可以是原子类型的元素，也可以是广义表的一种线性表 三个重要概念： 广义表的长度：表中最上层元素的个数 广义表的深度：表中括号的最大层数，求解时应将所有的子表展开在分析 表头(Head)和表尾(Tail)：当表非空时，第一个元素为广义表的表头，其余元素组成广义表的表尾两种存储结构： 头尾链表存储结构：这种存储结构有两种结点，即原子结点和广义表结点。原子结点有两个域：标记域、数据域。广义表结点有三个域：标记域、头指针域、尾指针域其中头指针指向一个原子结点或广义表结点，尾指针为空或者指向 本层中 的下一个广义表结点，而标记域用来区分广义表结点(1)与原子结点(0);示意图入下： 扩展线性表结构：该种存储结构同样有两种结点，与头尾链表存储结构不同的是这里的原子结点有三个域：标记域、数据域、尾指针域。示意图如下：","link":"/2019/01/27/arrayandlist/"},{"title":"String","text":"串的定义1234// 通常用一个字符数组来表示char str[] = \"hello\";// 数组str内存储的字符为{'h','e','l','l','o','\\0'} ,故有6个数组元素，其中'\\0'是串的结束标志，告知编译器串结束了。// 但是串str的长度为5，“hello”， 【注】以上定义方式一般不用，因为用该方式单纯以 ‘\\0’ 结尾的串如果要得到字符串的长度较为麻烦（需要遍历整个串，时间复杂度为O(n)，故一般情况下我们用自己定义的结构体来定义串，下面会谈到。 【注】空格也是串中的元素，由一个或多个空格组成的串称为空格串，空格串不是“空串”。 串的逻辑结构与线性表类似，串是限定了元素为字符的线性表。但从操作对象上来说，串与线性表有着很大的不同：线性表的主要操作对象是单个元素，而串的主要操作对象是该串的一个“子串”。 串的存储结构 1. 定长顺序存储表示：1234typedef struct Str{ char str[maxsize+1]; // 用来存放字串的字符数组，maxsize 为字符串最大长度，maxsize+1为数组最大长度，+1 用于存储 '\\0'. int length; // 字符串长度，可用Str.length方法直接访问 length &lt;= maxsize;} 2. 动态分配存储表示：1234typedef struct LStr{ char *ch; // 指向malloc();动态分配存储区的首地址的指针 int length; // 字符串长度} 串的基本操作 1. 赋值操作：12345678910111213141516171819202122232425262728293031int strassign(LStr&amp; str,char* ch){ // 需返回的变量带引用符号&amp; if (str.ch){ free(str.ch); // 释放原有空间 } int len = 0; char *c = ch; while(c){ // 计算ch的长度 ++len; ++c; } if (len == 0 ){ str.ch = NULL; // 如果ch为空，则直接返回一个空的串 str.len = 0; return 1; } else { str.ch = (char*)malloc(sizeof(char)*(str.len+1)); // 用malloc函数分配一块连续的存储空间，str.len+1是为了容纳'\\0' if (str.ch == NULL) { return 0; //分配失败 } else { c = ch; for (int i = 0; i &lt;= len;i++){ //遍历并赋值 str.ch[i] = *c; // *c 表示c指针所指的位置的值 ++c; // c指针指向下一个位置 } str.len = len; // 被赋值的串长度等于ch的串长 } } return 1; // successfully} 2. 取串长度操作：1234567891011121314int StrLength(LStr str){ // 有给串长度信息的情况： return str.len; // 返回str串的长度 //在没有给出串长度信息的情况下： int len = 0; char = *c; c = str.ch; while(c){ ++len; ++c; } return len;} 串的比较操作：123456789101112131415161718192021222324252627int strCompare(LStr str1,LStr str2){ //啰嗦版: for (int i = 0;i &lt; str1.len &amp;&amp; i &lt; str2.len){ if(str1.ch[i] - str2.ch[i] == 0) i++; else if(str1.ch[i] - str2.ch[i] &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else { cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } } if (str1.len - str2.len &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else if (str1.len - str2.len &lt; 0){ cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } else cout &lt;&lt; \"str1 = str2\" &lt;&lt; endl; return 1; // 简洁版： for (int i = 0; i &lt; str1.len &amp;&amp; i &lt; str2.len ;i++){ if (str1.ch[i] != str2.ch[i]){ return str1.ch[i] - str2.ch[i]; } return str1.len - str2.len; }} 4. 串的连接操作：1234567891011121314151617181920int concat(LStr &amp;str,LStr str1,LStr str2){ // 将两个字符串连接并用一个新的字符串str返回 if(str.ch) { // 清除原有空间 free(str.ch); str.ch = NULL; str.len = 0; } str.ch = (char*)malloc(sizeof(char)*(str1.len+str2.len+1)); // 分配连续空间，+1是为了多分配一个位置空间存放‘\\0’ int i = 0; while(i &lt; str1.len){ // 插入str1; str.ch[i] = str1.ch[i]; ++i; } int j = 0; while(j &lt;= str2.len){ // 插入str2，注意这里用\"&lt;=\"是为了吧'\\0' 也加到末尾 str.ch[i+j] = str2.ch[j]; ++j; } str.len = str1.len + str2.len; // 更新字符串长度 return 1; // 成功连接} 5. 求子串操作：12345678910111213141516171819202122232425262728int subStr(LStr &amp;substr,LStr str,int pos,int len){ if (pos + len &gt; str.len || pos &lt; 0 || len &lt; 0 || pos &gt;= str.len){ return 0; //判断输入是否合法 } if (substr.ch){ // 清空原空间 free(substr.ch); substr.ch = NULL; } if (len == 0){ // 若子串长度为0.直接返回空子串 substr.ch = NULL; substr.len = 0; return 1; } else{ substr.ch = (char*)malloc(sizeof(char)*(len+1)); // 分配连续的内存空间 int i = 0; int j = pos; while(i&lt;len){ // 从pos处开始遍历并赋值给子串 substr.ch[i] = str.ch[j]; ++i; ++j; } substr.ch[i] = '\\0'; // 这个千万别忘了加进去 substr.len = len; // 更新子串长度 return 1; // 成功 }} 串的清空操作：123456789// 串的清空操作在上诉各函数中均有用到int clearStr(LStr &amp;str){ if (str.ch){ free(str.ch); str.ch = NULL; } str.len = 0; return 1;} 串的模式匹配算法(重点)何为模式匹配： 对一个串中某子串的定位操作称为串的模式匹配，其中待匹配的子串称为“模式串”。串的模式匹配算法分为： 简单模式匹配算法 KMP算法 1. 简单模式匹配算法： 算法思想： 从主串的第一个位置起开始遍历字符串，若该字符与模式串的第一个字符相同，则继逐一比较后续字符， 否则从主串的下一个位置开始，重复上一步操作，以此类推，直到比较完模式串的所有字符。若匹配成 功，返回模式串在主串中的位置。匹配失败 ……,随便你想咋样。1234567891011121314151617181920int subStr_Match(Lstr str,LStr substr){ if (substr.ch == NULL || str.ch == NULL){ return 0; } int i ,j , pos = 0; for (i = 0 , j = 0;i &lt; str.len &amp;&amp; i &lt; substr.len; ){ if (str.ch[i] == substr.ch[j]){ ++j; ++i; } else { j = 0; // 匹配失败，j 重新指向模式串起始位置 i = ++pos; // pos 记录上一次匹配的起始位置，在匹配失败后将i指向上一轮匹配的初始位置pos的后面一个位置++pos开始新一轮匹配 } } if (j &gt;= substr.len){ return pos; // 匹配成功，返回模式串在主串中的位置 } return 0;} KMP算法： 算法思想解析 : 上述的匹配算法称为“简单模式匹配算法（BF）”，其时间复杂度为O(mn),其中m为主串长度，n为模式串长度。由此可知简单模式匹配算法虽然易于理解但是效率很低，无法满足当已知数据异常庞大时的效率要求。所以就诞生了接下来登场的KMP算法。 我们知道，在BF算法中每次发生不匹配i与j都要回溯到该轮匹配的初始位置，并且在回溯之后的后几次匹配同样有可能导致（不必要的）不匹配状态，这是导致算法效率低下的主要原因，那么如何直接跳过这些不必要的不匹配状态而直接到达可能解决不匹配位置的的状态呢？ 解决办法就是利用匹配失败后的信息，那么如何利用呢？ 为了使问题变得更加直观，我们假想匹配过程就是模式串在主串上的移动(实际上并不会移动，全是指针在变化)，如果在某一次匹配时在模式串的第j位置发生了不匹配（j位置前的所有元素都已匹配成功），如果照着BF算法来做，我们会抛弃掉j位置前的匹配“成果”直接将i与j回溯重新开始下一轮比较。但现在我们不这么做，因为我们完全可以将j之前的匹配成果利用起来 不不妨假设模式串为“ABABABB”，并且该模式串在与主串的一次匹配流程中第4个元素B与主串发生了不匹配，很显然这个时候主串i位置前的三个元素跟模式串是完全匹配的，为了利用这个成果，就是在模式串向后移动后尽可能地保留这些匹配成果，我们观察这三个元素“ABA”的特点，发现他的前缀与后缀出现了相同的字符序列“A”，这时候我们应该意识到，要时上一次的成果得到最大限度的保留，我们只能将模式串移动到前缀与后缀重合的状态，这样子就保留了一个匹配成果“A“，同时i根本就不需要回溯（原地不动就好），因为i无需从模式串头部重新开始与其匹配，而只需从保留的成果后开始匹配也就是模式串的第二个位置（A的后一个位置）开始匹配。 但问题又来了，怎么知道模式串该怎么移动呢，从上面的分析我们发现，对于模式串移动的分析完全没有涉及到主串，那我们是怎么做到视主串而不见的呢(它可是”主“串啊给点面子好不好)。事实上，我们用到他了，因为我们的假设是”j位置前的元素与主串完全匹配“，竟然这样那么不就说明j位置前的模式串部分与主串的那一部分完全一样吗，所以我们可以用一个所谓”假模式串“来代替主串，而模式串只要在这个”傀儡身上移动就好了。所以，模式串在哪个位置与主串发生不匹配后模式串应该怎么移动，这个问题就可以脱离主串而背单独拿出来分析了，这就是后面要谈到的next数组（用与存放当j位置发生不匹配时，j指针应该重新调整到那个位置上）。有了next数组，我们就可以知道当模式串在J处与主串发生不匹配之后，为了最大限度地保留之前的匹配成果，模式串该怎么移动（指针该怎么变化）。 KMP算法代码：1234567891011121314151617181920int KMP (LStr str,LStr substr,int next[]){ // 函数接受主串，模式串，next数组 int i = 1 ,j = 1; // i 扫描主串，j 扫描模式串 for (i &lt; str.len &amp;&amp; i &lt; substr.len){ if (j == 0 || str.ch[i] == substr.ch[j]){ // j=0;的情况就是模式串中的第一个字符与主串中的第i个字符不匹配，应从// 主串的下一个位置与模式串的第一个位置继续比较，故++i(主串的下一个位置);// ++j(模式串第一个位置0+1=1(很强)) ++j; ++i; } else { j = next[j]; // j 被调整到合适位置，这里的i不需要回朔，这也是KMP算法的一大特点 } } if (j &gt;= substr.len){ // j 的长度超过了模式串，显然匹配成功 return i - substr.len; // 匹配成功，返回模式串在主串中的位置 } return 0;} next数组的求法: 经过前面的分析我们知道，只需要模式串本身我们就可以求出next数组，并不需要主串的参与。所以我们可以定义一个函数将next数组一次性求出，从此一劳永逸…… 这里我们要用到一个算法思想，那就是递推,我们知道数列就是一种有着递推关系的数的序列。现在假设等差数列{An},给你一个递推公式(实际上就是前一个元素与后一个元素的关系)：A(n+1) = An + 1;其中n={1,2,3,…}然后告诉你第一个元素A1 = 0(实际上告诉你任何一个位置上的元素值都可以); 有了这两个已知条件你可以知道这个数列的所有元素就是非负整数集{0,1,2,3, …}。 那我们如何在求解next数组上面应用这个思想呢？ 首先看看我们有什么已知条件？ 显然我们需要知道两个相邻状态Sk与Sk+1之间的关系，假设模式串为p1～pm，问题转化为两个模式串之间的匹配问题。如果在Sk时，已经求得了next[j] = t；若要求得Sk+1状态的next[j+1]，我们需要分两种状态来考虑： 若Pj = Pt；则next[j+1] = t+1; 若Pj != pt;这时候就又回到了我们讨论模式串与主串匹配出现匹配失败的经典情形了，不匹配发生在t处，我们应该去查next数组看看t应该怎样调整位置了，显然next[t]我们已经求得了，所以令t = next[t],继续比较pj与pt，若不相等重复第二种情况，直到t = 0;或者pj = pt 满足第一种情况，从而求得next[j+i]; next求数组代码:123456789101112131415void getNext(LStr substr,int next[]){ int j = 1; int t = 0; int next[1] = 0; // 特殊情况，模式串的第一个位置发生不匹配 while(i &lt; substr.len){ if(t==0 || substr.ch[t] == substr.ch[j]){ // t=0;是因为next数组中可能有0元素,也说明没有重合的前后缀 next[j+1] = t+1; ++j; ++t; } else{ t = next[t]; } }} KMP 算法的改进 KMP算法就还有什么地方需要改进的？ 为了回答这个问题我们先来看一种特殊情况：模式串为（A A A A A B）,该模式串所对应的next数组为{0,1,2,3,4,5}。可以遇见的是当在模式串第j=5个位置A处发生不匹配时，next数组指导j指向4；而4处的元素依然不匹配（因为4处元素与5处相等），j来到了3（同样不匹配），紧接着来到了2（不匹配），来到1（依然不匹配），最后j=0(++i,++j)到此才结束了之前陷入的“尴尬”局面。 由上分析我们不难想到，如何才能让j直接跳到0；而免去从1-4的多余的比较呢？这就是KMP算法需要改进的地方 也就是说，对KMP算法的改进主要就是对求next数组的方法的改进，于是就有了改进版的next数组，我们称之为 nextval 数组 getNextval() 算法核心思想： 通过上面那个特殊情况，我们知道当j处发生不匹配时，若next数组指导的下一个位置的值与j处的值是相等的，那么显然这次比较就是多余的（因为显然还是会不匹配），所以我们应该跳过next数组所指向的那个位置，换一种思路就是我们应该让next[j] 所指向的位置与Pj不相等，就是改变next[j] 的值；改变后的next数组就是nextval数组. 求解nextval数组的一般步骤： 当j等于1时，nextval[j]赋值为 0 ，作为特殊标记； 当j大于1 时： 若Pj不等于P(next[j]),则nextval[j] 等于 next[j]; 若Pj等于P(next[j]),则nextval[j] 等于 nextval[next[j]]; 123456789101112131415161718void getNextval(LStr substr,int nextval[]){ int j = 1; int t = 0; nextval[1] = 0; while(i&lt;substr.len){ if (j == 0 || substr.sh[j] == substr.ch[t]){ if(substr.ch[j+i] != substr.ch[t+1]) nextval[j+1] = t+1; else nextval[j+1] = nextval[t+1]; ++j; ++t; } else t = nextval[t]; }}","link":"/2019/01/27/String/"},{"title":"Linear List","text":"线性表 线性表的基本概念与实现1. 线性表的定义: 线性表是具有相同特性数据元素的一个有限序列，重点在“有限序列”。线性表可以是有序的，也可以是无序的。2. 线性表的逻辑特性: 除了表头和表尾的数据元素“结点”，所有元素都有一个直接前驱与一个直接后继。表头无前驱，表尾无后继。 线性表的存储结构： 顺序存储结构：（顺序表） 存储空间连续（空间为一次性分配的） 可以随机存取，也可以顺序存取 插入删除时平均需要移动近一半的元素，时间复杂度为:O((n-1)/2)=O(n) 存储密度为１ 链式存储结构：（链表） 存储空间可以不连续（存储空间是动态分配的） 每一个结点不仅包含数据还包含指向下一个结点的指针 只能够进行顺序存储 存储密度&lt;1 插入删除时不需要移动元素，只需修改指针即可,时间复杂度为:O(1) 线性表的定义与实现：a) 顺序表的定义： 结构体定义： 12345#defined MaxSize 100typedef sturct Sqlist { int data[MaxSize]; //线性表最多能容纳的元素个数，即分配的空间大小 int length ; //元素的个数}Sqlist; 用的最多的简单定义：12int A[MaxSize]; //直接利用数组就是顺序表的一种这一特性int length; b) 单链表的结点定义：1234typedef struct LNode { int data; //数据域 struct LNode *next; //指针域}LNode; c) 双链表结点定义： 12345typedef struct DLNOde { int data; //数据域 struct DLNOde *prior; // 指向前驱结点的指针 struct DLNode *next; // 指向后继结点的指针} 【注】 为结点分配存储空间：12LNode *A = (LNOde*)malloc(sizeof(LNode));//malloc 函数返回一个空间的地址，让指针Ａ来指向它 线性表的相关操作 查找操作： 12345678int findElem (Sqlist a, int x){ for (int i = 0;i&lt;l.length;++i){ if (a[i]==x){ return i; //找到了，返回所在的下标 } } return 0; // 没找到，返回０} 插入操作： 1234567891011121314151617int insertElem(Sqlist &amp;L,int i ,int x){ if (i&lt;0 || i &gt; L.length){ return -1; //如果插入位置不合法，返回－１ } if (L.length == MaxSize){ int newL[L.length+MaxSize] for (int j=0;j&lt;L.length;++j){ newL[j] = L[j]; //如果发现顺序表已经满了，就构造一个更大的顺序表并把原顺序表的元素放进去 } L = newL; } for (int k = L.length-1; k&gt;=i; --k){ L[k+1] = L[k]; //从某位开始将插入位置至末尾的元素向后移动一个位置 } L[i] = x; // 插入ｘ到ｉ处 L.length++; // 插入后该表表的长度} 删除操作： 1234567891011121314151617// 通过索引下标删除元素，并返回所删元素的值int deleteElem_by_index (Sqlist &amp;L,int i){ int q = L[i]; // 保留ｉ位置的元素 for (int j = i+1;j&lt;L.length;++j){ L[j-1] = L[j]; // 从待删除元素的右边开始每个元素向左移动一个位置，覆盖掉ｉ位置的元素 } L.length--; // 顺序表长度减一，完成删除操作 return q; // 返回被删除元素的值}// 通过值来删除元素，并返回所删元素的下标int deleteElem_by_value (Sqlist &amp;L, int e){ int index = findElem(L,e); //利用findELem() 函数找到要删除元素的下标 int value = L[index]; deliteElem_by_index (L,index); // 用下标索引法删除元素 return value;} 初始化顺序表： 123void initList (Sqlist &amp;L){ L.length = 0;} 求指定位置元素： 1234int getElem (Sqlist L , int index){ if (index &lt; 0 || index &gt; L.length-1) return Error; rerurn L[index];} 单链表的相关操作 以下所有的算法用的都是带头结点的单链表 尾插法建立单链表： 1234567891011121314151617// 给定数组ａ[] 为数据源，建立单链表void creatListR(LNode *&amp;C , int a[], int length){ LNode *s,*r; //用ｓ指向新建的结点，ｒ始终指向链表的尾部结点 C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 r = C; // r 指向头结点，也就是空链表的头结点 for (int i = 0 ; i&lt;length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); // 用malloc函数循环分配结点空间 s -&gt; next = NULL; s -&gt; data = a[i]; // 尾插法的核心算法： r -&gt; next = s; r = r -&gt; next; //r 指向当前尾结点 } // r -&gt; next == NULL;} 头插法建立单链表： 123456789101112void creatListH(LNode *&amp;C ,int a[] ,int length){ LNode *s; C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 for (int i = 0 ; i &lt; length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = a[i]; // 头插法的核心算法： s -&gt; next = C --&gt; next; C -&gt; next = s; }} 删除结点： 1234567891011121314151617// 按值索引删除链表结点void deleteNode(LNode &amp;L , int elem){ LNode *p,*q; p = L; if (L -&gt; next == NULL) return 0; //如果链表为空，返回０； while (p -&gt; next != NULL){ // 循环遍历链表结点 if (p -&gt; next -&gt; data == elem){ // 如果ｐ指向的结点的下一个结点的数据域与带删除数据相等，删除该下一个结点，释放空间 // 删除操作的核心算法： q = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; free(q); // 释放内存 break; //删除成功，退出循环 } p = p -&gt; next; //该节点不是待删除结点，令ｐ指向下一个结点 }} 插入结点： 12345678910111213141516// 在链表的指定元素前插入结点void insertNode(LNode &amp;L , int we,int e){ LNode *r; r = L; LNode *s = (LNode*)malloc(sizeof(LNode)); q -&gt; data = we; q -&gt; next = NULL; while (r -&gt; next != NULL ){ if (r -&gt; next -&gt; data == e){ //插入操作的核心算法： s -&gt; next = r -&gt; next; r -&gt; next = s; } r = r -&gt; next; }} 双链表的相关操作 尾插法建立双链表： 1234567891011121314151617// 给定数据源数组，建立双链表void creatDListR (DLNode ＆L , int a[], int length){ DLNode *s,*r; //用ｒ始终指向链表末尾结点，ｓ接受新分配的结点 L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; r = L; //r 指向头结点 for (int i = 0; i&lt; length;++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; // 尾插发的关键步骤： s -&gt; prior = r; r -&gt; next = s; r = r -&gt; next; // r = s; 令ｒ 指向下一个结点 r -&gt; next = NULL; //滞空末尾结点的ｎｅｘｔ指针域 }} 头插法建立双链表： 123456789101112131415void creatDListH (DLNode ＆L , int a[], int length){ DLNode *s ; L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; for (int i = 0 ; i&lt;length; ++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; //关键步骤： s -&gt; next = L -&gt; next; L -&gt; next -&gt; prior = s; s -&gt; prior = L; L -&gt; next = s; }} 查找结点的算法： 123456789101112// 在双链表中查找第一个值为ｘ的结点，从第一个结点开始，边扫描边比较，若找到返回该结点的指针，没找到返回 ＮＵＬＬDLNode* findNode(DLNode *L, int x){ DLNode *p; p = L -&gt; next; while (p != NULL){ if (p -&gt; data == x){ return p; } p = p -&gt; next; } return NULL;} 插入结点的算法： 123456//在双链表中ｐ所指结点后插入新的结点ｓ//关键步骤如下： s -&gt; next = p -&gt; next; s -&gt; prior = p; p -&gt; next -&gt; prior = s; p -&gt; next = s; 删除结点： 123456//在双链表中的删除指针ｐ所指结点的后继结点,并用ｓ指针返回被删除的结点//关键步骤如下： s = p -&gt; next ; s -&gt; next -&gt; prior = p; p -&gt; next = s -&gt; next; free(s);","link":"/2019/01/27/linearList/"},{"title":"BinaryTree","text":"树的基本概念 树的定义：前面所提到的线性结构的元素是一种一对一的关系，而树是一种一对多的非线性结构，下面将通过一个具体的树的例子讲解到底什么样的结构才是树以 及树的一些相关术语：上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵空树。结点：上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；结点的度：该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；树的度：树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；叶子结点：又称为终端结点，指的是度为零的结点非终端结点：又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为内部结点。祖先：从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：A和B，因为路径为：A–B–E；层次：根处为第一层，以此类推……，如上图树的层次为4层；结点的深度和高度：联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；有序树：树中结点的子树从左到右都是有次序的不能交换无序树：树中结点的子树没有次序，可以任意交换丰满树：理想的平衡树，要求除了最底层外，其他层都是满的森林：若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林 树的存储结构 顺序存储：双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法) 链式存储：孩子存储结构（孩子表示法）孩子兄弟存储结构（孩子兄弟表示法） 二叉树 二叉树的五种基本形式 满二叉树的概念 完全二叉树的概念二叉树的几个重要性质 性质一：非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$； 性质二：二叉树的第$i$层上最多有$2^{i-1}$; 性质三：高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$. 性质四：该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述； 性质五：函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\\frac{1}{n+1}×C_{2n}^n$ ; 性质六：具有$n$个结点的完全二叉树的高度（或深度）为$[\\log_2{n}]+1$(向下取整)； 二叉树的存储结构 顺序存储结构：用一个数组来存储完全二叉树，将完全二叉树的结点值按编号依次存入一个一维数组中。 如果要从一维数组中还原二叉树的本来结构，按照以下规则：$i$ 为某结点的编号，若$i\\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；如果$2i\\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；如果$2i+1 \\leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；下面给出将数组还原成二叉链树的代码：123456789101112131415161718void creatBTree(int BT[],int n,BTNode *&amp;e){ BTNode *BTNode_array[maxsize]; for(int i = 1;i &lt;= n;++i ){ BTNode_array[i] = (BTNode*)malloc(sizeof(BTNode)); BTNode_array[i] -&gt; data = BT[i]; BTNode_array[i] -&gt; lchild = NULL; BTNode_array[i] -&gt; rchild = NULL; } for (int i = 1;i &lt;= n;++i){ if(2*i &lt;= n ){ BTNode_array[i] -&gt; lchild = BTNode_array[2*i]; } if((2*i+1) &lt;= n){ BTNode_array[i] -&gt; rchild = BTNode_array[2*i+1]; } } e = BTNode_array[1];} 链式存储结构：为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：12345typedef struct BTNode{ int data; //数据域 struct BTNode *lchild;//指向左孩子的指针 struct BTNode *rchild;//指向右孩子的指针}; 二叉树的遍历算法(递归实现)：深度优先遍历： 前序遍历： 1234567void preorder(BTNode *p){ if(p != NULL){ Visit(p); preorder(p -&gt; lchild); preorder(p -&gt; rchild); }} 中序遍历： 1234567void inorder(BTNode *p){ if(p != NULL){ inorder(p -&gt; lchild); Visit(p); inorder(p -&gt; rchild); }} 后序遍历： 1234567void postorder(BTNode *p){ if(p != NULL){ postorder(p -&gt; lchild); postorder(p -&gt; rchild); Visit(p); }} 广度优先遍历： 算法流程图解：1234567891011121314151617181920212223void level (BTNode *p){ if(p != NULL){ BTNode *que[maxsize]; int front = 0; int rear = 0; BTNode *q; rear = (rear + 1)%maxsize; que[rear] = p; while(front != rear){ front = (front + 1)%maxsize; q = que[front]; Visit(q); if(q -&gt; lchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; lchild; } if(q -&gt; rchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; rchild; } } }} 二叉树的遍历算法(非递归实现) 上图而查处将作为例子方便讲解下面的算法 深度优先遍历算法： 先序遍历： 123456789101112131415161718void preorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; Stack[++top] = bt; while(top != NULL){ p = Stack[top--]; Visit(p); if(p -&gt; rchild != NULL){ Stack[++top] = p -&gt; rchild; } if(p -&gt; lchild != NULL){ Stack[++top] = p -&gt; lchild; } } }} 后序遍历：先序遍历算法遍历例子二叉树将得到：A B D E C F G后序遍历例子二叉树：D E B F G C A将后序遍历序列逆置：A C G F B E D可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。 123456789101112131415161718192021222324void postorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode Stack1[maxsize]; BTNode Stack2[maxsize]; int top1 = -1; int top2 = -1; BTNode *p = NULL; Stack1[++top1] = bt; while(top1 != -1){ p = Stack1[top--]; Stack2[++top] = p; if(p -&gt; lchild != NULL){ Stack1[++top] = p -&gt; lchild; } if(p -&gt; rchild != NULL){ Stack1[++top] = p -&gt; rchild; } } while(top2 != -1){ p = Stack2[top--]; Visit(p); } }} 中序遍历： 12345678910111213141516171819void inorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; p = bt; while(top != -1 || p != NULL){ while(p -&gt; lchild != NULL){ Stack[++top] = p; p = p -&gt; lchild; } if(top != -1){ p = Stack[top--]; Visit(p); p = p -&gt; rchild; } } }} 线索二叉树 对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。 线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。线索二叉树的构造：结点定义： 123456typedef struct TBTNode{ int data; // 数据域 struct TBTNode *lchild; // 左孩子（前驱结点）指针 struct TBTNode *rchild; // 右孩子（后继结点）指针 int ltag , rtag; //线索标记}; 根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。通过中序遍历对二叉树线索化代码： 123456789101112131415void InThread(TBTNode *p,TBTNode *&amp;pre){ if(p != NULL){ InThread(p -&gt; lchild,pre); // 递归地线索化左子树 if(p -&gt; lchild == NULL){ // 建立当前结点前驱线索 p -&gt; lchild = pre; p -&gt; ltag = 1; } if(pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ // 建立前驱结点的后继线索 pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; // pre 跟上 p，之后p会指向下一个结点 InThread(p -&gt; rchild,pre); // 递归地线索化右子树 }} 通过中序遍历线索二叉树的主程序如下：12345678void creatTBTNode(TBTNode *root){ TBTNode *pre = NULL; if(root != NULL){ InThread(root,pre); //递归建立线索二叉树 pre -&gt; rchild = NULL; // 处理最后一个结点 pre -&gt; rtag = 1; }} 遍历中序线索二叉树：寻找中序线索二叉树 root 的第一个遍历结点：123456TBTNode *First(TBTNode *root){ while( root -&gt; ltag == 0){ root = root -&gt; lchild; } return root;} 在中序线索二叉树中，求结点p在中序下的后继结点的算法：1234567TBTNode *Next(TBTNode *p){ if(p -&gt; rtag == 0){ return First(p -&gt; rchild); } else return p -&gt; rchild; // rtag = 1; 直接返回后继线索} 在中序线索二叉树上执行中序遍历：12345void Inoreder(TBTNode *root){ for (TBTNode *p = First(root);p != NULL;p = Next(p)){ Visit(p); }} 通过前序遍历对二叉树线索化12345678910111213141516171819void preInThread(TBTNode *p,TBTNode *&amp;pre){ if (p != NULL){ if(p -&gt; lchild != NULL){ p -&gt; lchild = pre; p -&gt; ltag = 1; } if (pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; if (p -&gt; ltag == 0){ preThread(p -&gt; lchild,pre); } if (p -&gt; rtag == 0){ preThread(p -&gt; rchild,pre); } }} 遍历前序线索二叉树算法：12345678910111213void preorder(TBTNode *root){ if(root != NULL){ TBTNode *p = root; while(p != NULL){ while(p -&gt; ltag == 0){ Visit(p); p = p -&gt; lchild; } Visit(p); p = p -&gt; rchild; } }} 树与森林的互相转换 树与二叉树的应用 二叉排序树与二叉平衡树 赫夫曼树与赫夫曼编码 赫夫曼树的相关概念及介绍：赫夫曼树又被称为最优二叉树，它的特点是带权路径最短。下面介绍几个相关概念： 路径：指从树中一个结点到另一个结点的分支所构成的路线 路径长度：路径上的分支数目 树的路径长度：从根到每个结点的路径长度之和 带权路径长度：结点具有权值，从该结点到根结点的路径长度乘于该结点的权值就是该结点的带权路径长度 树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和 赫夫曼树的构造方法：给定$n$个权值，用这些个权值来构造赫夫曼树：首先了解一下赫夫曼树的一些特点： 权值越大的结点距离根节点越近 树中没有度为1的结点 树的带权路径长度最短 根据上述特点反推我们是如何来构造一个赫夫曼树： 从最底层开始构造 最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点 权值最大的结点离根节点最近 有了上述导论我们就可以开始构造一棵赫夫曼树了：上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。 赫夫曼编码： * 利用赫夫曼树的特点来对文件进行压缩存储 看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$选三位长度的二进制数为A到E编码：根据上表我们可以将该字符串编码为：$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$解码时每三位一个字符解码总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？ 答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：到此我们得到了对A到E的霍夫曼编码规则：根据上表的编码规则可将字符串编码为：$1110010101101011110011110101010110111000011001011111111110110$只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。 解码霍夫曼编码：解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。 [注] 对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的 霍夫曼$n$叉树 霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例 构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。 ) 上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵空树。结点：上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；结点的度：该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；树的度：树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；叶子结点：又称为终端结点，指的是度为零的结点非终端结点：又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为内部结点。祖先：从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：A和B，因为路径为：A–B–E；层次：根处为第一层，以此类推……，如上图树的层次为4层；结点的深度和高度：联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；有序树：树中结点的子树从左到右都是有次序的不能交换无序树：树中结点的子树没有次序，可以任意交换丰满树：理想的平衡树，要求除了最底层外，其他层都是满的森林：若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林 树的存储结构 顺序存储：双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法) 链式存储：孩子存储结构（孩子表示法）孩子兄弟存储结构（孩子兄弟表示法） 二叉树 二叉树的五种基本形式 满二叉树的概念 完全二叉树的概念二叉树的几个重要性质 性质一：非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$； 性质二：二叉树的第$i$层上最多有$2^{i-1}$; 性质三：高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$. 性质四：该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述； 性质五：函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\\frac{1}{n+1}×C_{2n}^n$ ; 性质六：具有$n$个结点的完全二叉树的高度（或深度）为$[\\log_2{n}]+1$(向下取整)； 二叉树的存储结构 顺序存储结构：用一个数组来存储完全二叉树，将完全二叉树的结点值按编号依次存入一个一维数组中。 如果要从一维数组中还原二叉树的本来结构，按照以下规则：$i$ 为某结点的编号，若$i\\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；如果$2i\\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；如果$2i+1 \\leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；下面给出将数组还原成二叉链树的代码：123456789101112131415161718void creatBTree(int BT[],int n,BTNode *&amp;e){ BTNode *BTNode_array[maxsize]; for(int i = 1;i &lt;= n;++i ){ BTNode_array[i] = (BTNode*)malloc(sizeof(BTNode)); BTNode_array[i] -&gt; data = BT[i]; BTNode_array[i] -&gt; lchild = NULL; BTNode_array[i] -&gt; rchild = NULL; } for (int i = 1;i &lt;= n;++i){ if(2*i &lt;= n ){ BTNode_array[i] -&gt; lchild = BTNode_array[2*i]; } if((2*i+1) &lt;= n){ BTNode_array[i] -&gt; rchild = BTNode_array[2*i+1]; } } e = BTNode_array[1];} 链式存储结构：为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：12345typedef struct BTNode{ int data; //数据域 struct BTNode *lchild;//指向左孩子的指针 struct BTNode *rchild;//指向右孩子的指针}; 二叉树的遍历算法(递归实现)：深度优先遍历： 前序遍历： 1234567void preorder(BTNode *p){ if(p != NULL){ Visit(p); preorder(p -&gt; lchild); preorder(p -&gt; rchild); }} 中序遍历： 1234567void inorder(BTNode *p){ if(p != NULL){ inorder(p -&gt; lchild); Visit(p); inorder(p -&gt; rchild); }} 后序遍历： 1234567void postorder(BTNode *p){ if(p != NULL){ postorder(p -&gt; lchild); postorder(p -&gt; rchild); Visit(p); }} 广度优先遍历： 算法流程图解：1234567891011121314151617181920212223void level (BTNode *p){ if(p != NULL){ BTNode *que[maxsize]; int front = 0; int rear = 0; BTNode *q; rear = (rear + 1)%maxsize; que[rear] = p; while(front != rear){ front = (front + 1)%maxsize; q = que[front]; Visit(q); if(q -&gt; lchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; lchild; } if(q -&gt; rchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; rchild; } } }} 二叉树的遍历算法(非递归实现) 上图而查处将作为例子方便讲解下面的算法 深度优先遍历算法： 先序遍历： 123456789101112131415161718void preorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; Stack[++top] = bt; while(top != NULL){ p = Stack[top--]; Visit(p); if(p -&gt; rchild != NULL){ Stack[++top] = p -&gt; rchild; } if(p -&gt; lchild != NULL){ Stack[++top] = p -&gt; lchild; } } }} 后序遍历：先序遍历算法遍历例子二叉树将得到：A B D E C F G后序遍历例子二叉树：D E B F G C A将后序遍历序列逆置：A C G F B E D可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。 123456789101112131415161718192021222324void postorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode Stack1[maxsize]; BTNode Stack2[maxsize]; int top1 = -1; int top2 = -1; BTNode *p = NULL; Stack1[++top1] = bt; while(top1 != -1){ p = Stack1[top--]; Stack2[++top] = p; if(p -&gt; lchild != NULL){ Stack1[++top] = p -&gt; lchild; } if(p -&gt; rchild != NULL){ Stack1[++top] = p -&gt; rchild; } } while(top2 != -1){ p = Stack2[top--]; Visit(p); } }} 中序遍历： 12345678910111213141516171819void inorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; p = bt; while(top != -1 || p != NULL){ while(p -&gt; lchild != NULL){ Stack[++top] = p; p = p -&gt; lchild; } if(top != -1){ p = Stack[top--]; Visit(p); p = p -&gt; rchild; } } }} 线索二叉树 对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。 线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。线索二叉树的构造：结点定义： 123456typedef struct TBTNode{ int data; // 数据域 struct TBTNode *lchild; // 左孩子（前驱结点）指针 struct TBTNode *rchild; // 右孩子（后继结点）指针 int ltag , rtag; //线索标记}; 根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。通过中序遍历对二叉树线索化代码： 123456789101112131415void InThread(TBTNode *p,TBTNode *&amp;pre){ if(p != NULL){ InThread(p -&gt; lchild,pre); // 递归地线索化左子树 if(p -&gt; lchild == NULL){ // 建立当前结点前驱线索 p -&gt; lchild = pre; p -&gt; ltag = 1; } if(pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ // 建立前驱结点的后继线索 pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; // pre 跟上 p，之后p会指向下一个结点 InThread(p -&gt; rchild,pre); // 递归地线索化右子树 }} 通过中序遍历线索二叉树的主程序如下：12345678void creatTBTNode(TBTNode *root){ TBTNode *pre = NULL; if(root != NULL){ InThread(root,pre); //递归建立线索二叉树 pre -&gt; rchild = NULL; // 处理最后一个结点 pre -&gt; rtag = 1; }} 遍历中序线索二叉树：寻找中序线索二叉树 root 的第一个遍历结点：123456TBTNode *First(TBTNode *root){ while( root -&gt; ltag == 0){ root = root -&gt; lchild; } return root;} 在中序线索二叉树中，求结点p在中序下的后继结点的算法：1234567TBTNode *Next(TBTNode *p){ if(p -&gt; rtag == 0){ return First(p -&gt; rchild); } else return p -&gt; rchild; // rtag = 1; 直接返回后继线索} 在中序线索二叉树上执行中序遍历：12345void Inoreder(TBTNode *root){ for (TBTNode *p = First(root);p != NULL;p = Next(p)){ Visit(p); }} 通过前序遍历对二叉树线索化12345678910111213141516171819void preInThread(TBTNode *p,TBTNode *&amp;pre){ if (p != NULL){ if(p -&gt; lchild != NULL){ p -&gt; lchild = pre; p -&gt; ltag = 1; } if (pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; if (p -&gt; ltag == 0){ preThread(p -&gt; lchild,pre); } if (p -&gt; rtag == 0){ preThread(p -&gt; rchild,pre); } }} 遍历前序线索二叉树算法：12345678910111213void preorder(TBTNode *root){ if(root != NULL){ TBTNode *p = root; while(p != NULL){ while(p -&gt; ltag == 0){ Visit(p); p = p -&gt; lchild; } Visit(p); p = p -&gt; rchild; } }} 树与森林的互相转换 树与二叉树的应用 二叉排序树与二叉平衡树 赫夫曼树与赫夫曼编码 赫夫曼树的相关概念及介绍：赫夫曼树又被称为最优二叉树，它的特点是带权路径最短。下面介绍几个相关概念： 路径：指从树中一个结点到另一个结点的分支所构成的路线 路径长度：路径上的分支数目 树的路径长度：从根到每个结点的路径长度之和 带权路径长度：结点具有权值，从该结点到根结点的路径长度乘于该结点的权值就是该结点的带权路径长度 树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和 赫夫曼树的构造方法：给定$n$个权值，用这些个权值来构造赫夫曼树：首先了解一下赫夫曼树的一些特点： 权值越大的结点距离根节点越近 树中没有度为1的结点 树的带权路径长度最短 根据上述特点反推我们是如何来构造一个赫夫曼树： 从最底层开始构造 最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点 权值最大的结点离根节点最近 有了上述导论我们就可以开始构造一棵赫夫曼树了：上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。 赫夫曼编码： * 利用赫夫曼树的特点来对文件进行压缩存储 看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$选三位长度的二进制数为A到E编码：根据上表我们可以将该字符串编码为：$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$解码时每三位一个字符解码总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？ 答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：到此我们得到了对A到E的霍夫曼编码规则：根据上表的编码规则可将字符串编码为：$1110010101101011110011110101010110111000011001011111111110110$只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。 解码霍夫曼编码：解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。 [注] 对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的 霍夫曼$n$叉树 霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例 构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。","link":"/2019/01/27/BinaryTree/"}],"tags":[{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"}],"categories":[{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"DataStructs","slug":"DataStructs","link":"/categories/DataStructs/"}]}