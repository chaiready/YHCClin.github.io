{"pages":[{"title":"","text":"1cv9HsU1kD","link":"/baidu_verify_1cv9HsU1kD.html"},{"title":"404 Not Found：呀！迷路了......","text":"&lt;!DOCTYPE html&gt; 看来你迷路了 Error 404 The page you are looking for might have been removed, had its name changed or is temporarily unavailable. Please try to go back or return to the homepage. Good luck. L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"admin\":{\"username\":\"aokilin\",\"password_hash\":\"$2a$10$Ftok/UgFv5olradmR40PM.w57gZ.QOp2uXQlpSZevsU.pMi0KPHla\",\"secret\":\"my super secret phrase\"},\"kramed\":{\"gfm\":true,\"pedantic\":false,\"sanitize\":false,\"tables\":true,\"breaks\":true,\"smartLists\":true,\"smartypants\":true},\"feed\":{\"type\":\"atom\",\"path\":\"atom.xml\",\"limit\":20}});","link":"/404.html"},{"title":"","text":"@import 'https://fonts.googleapis.com/css?family=Inconsolata'; html { min-height: 100%; } body { box-sizing: border-box; height: 100%; background-color: #000000; background-image: radial-gradient(#11581E, #041607), url(\"https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif\"); background-repeat: no-repeat; background-size: cover; font-family: 'Inconsolata', Helvetica, sans-serif; font-size: 1.5rem; color: rgba(128, 255, 128, 0.8); text-shadow: 0 0 1ex rgba(51, 255, 51, 1), 0 0 2px rgba(255, 255, 255, 0.8); } .noise { pointer-events: none; position: absolute; width: 100%; height: 100%; background-image: url(\"https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif\"); background-repeat: no-repeat; background-size: cover; z-index: -1; opacity: .02; } .overlay { pointer-events: none; position: absolute; width: 100%; height: 100%; background: repeating-linear-gradient( 180deg, rgba(0, 0, 0, 0) 0, rgba(0, 0, 0, 0.3) 50%, rgba(0, 0, 0, 0) 100%); background-size: auto 4px; z-index: 1; } .overlay::before { content: \"\"; pointer-events: none; position: absolute; display: block; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; background-image: linear-gradient( 0deg, transparent 0%, rgba(32, 128, 32, 0.2) 2%, rgba(32, 128, 32, 0.8) 3%, rgba(32, 128, 32, 0.2) 3%, transparent 100%); background-repeat: no-repeat; animation: scan 7.5s linear 0s infinite; } @keyframes scan { 0% { background-position: 0 -100vh; } 35%, 100% { background-position: 0 100vh; } } .terminal { box-sizing: inherit; position: absolute; height: 100%; width: 1000px; max-width: 100%; padding: 4rem; text-transform: uppercase; } .output { color: rgba(128, 255, 128, 0.8); text-shadow: 0 0 1px rgba(51, 255, 51, 0.4), 0 0 2px rgba(255, 255, 255, 0.8); } .output::before { content: \"> \"; } /* .input { color: rgba(192, 255, 192, 0.8); text-shadow: 0 0 1px rgba(51, 255, 51, 0.4), 0 0 2px rgba(255, 255, 255, 0.8); } .input::before { content: \"$ \"; } */ a { color: #fff; text-decoration: none; } a::before { content: \"[\"; } a::after { content: \"]\"; } .errorcode { color: white; }","link":"/404/style.css"},{"title":"Dont Do It","text":"Unclosable Window/Source of MainPart: Stefan MÃ¼nz, Selfhtml 7.0, tecb.htm /activ = window.setInterval(“Farbe()”,100);i = 0, farbe = 1;function Farbe() {if(farbe==1) {document.bgColor=”FFFF00”; farbe=2; }else {document.bgColor=”FF0000”; farbe=1; }i = i + 1;//if you don’t want to freeze the browser uncommend the next two lines//if(i &gt;= 50)//window.clearInterval(activ);}function erneut(){window.open(self.location,’’);}window.onload = erneut;Unclosable WindowL2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"admin\":{\"username\":\"aokilin\",\"password_hash\":\"$2a$10$Ftok/UgFv5olradmR40PM.w57gZ.QOp2uXQlpSZevsU.pMi0KPHla\",\"secret\":\"my super secret phrase\"},\"kramed\":{\"gfm\":true,\"pedantic\":false,\"sanitize\":false,\"tables\":true,\"breaks\":true,\"smartLists\":true,\"smartypants\":true},\"feed\":{\"type\":\"atom\",\"path\":\"atom.xml\",\"limit\":20}});","link":"/dontclick/index.html"},{"title":"Links","text":"互换友链如果您也有自己的博客站点，并且想要互换友链，可以给我留言,并注明贵站的类型 以下链接无先后顺序，欢迎访问！ 站名链接类型policx的博客https://policx.com/技术https://www.xxxx.xyz技术https://google.com随想https://google.comweb与硬件https://google.com摄影https://baidu.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术https://xxxx.com技术","link":"/links/index.html"},{"title":"Gallery","text":"Stay Hungry, Stay Foolish. &lt;div class=”justified-gallery”&gt;&lt;!– Need an empty line here for the following markdown to be rendered –&gt;&lt;/div&gt;","link":"/gallery/index.html"},{"title":"","text":"#mainDiv{ width:100%; height:100% } #code{ float:left; width:440px; height:400px; color:#333; font-family:\"Consolas\",\"Monaco\",\"Bitstream Vera Sans Mono\",\"Courier New\",\"sans-serif\"; font-size:12px } #code .string{ color:#2a36ff } #code .keyword{ color:#7f0055; font-weight:bold } #code .placeholder{ margin-left:15px } #code .space{ margin-left:7px } #code .comments{ color:#3f7f5f }","link":"/gallery/css/default.css"},{"title":"","text":"body { margin: 0; padding: 0; background: #FFFFEE; font-size: 12px; overflow: auto; } #mainDiv{ width: 100%; height: 100%; } #loveHeart { float: left; width:670px; height:625px; } #garden { width: 100%; height: 100%; } #elapseClock { text-align: right; font-size: 18px; margin-top: 10px; margin-bottom: 10px; } #words { font-family: \"sans-serif\"; width: 500px; font-size: 24px; color:#666; } #messages{ display: none; } #elapseClock .digit{ font-family: \"digit\"; font-size: 36px; } #loveu{ padding: 5px; font-size: 22px; margin-top: 80px; margin-right: 120px; text-align: right; display: none; } #loveu .signature{ margin-top: 10px; font-size: 20px; font-style: italic; } #clickSound{ display:none; } #code { float: left; width: 440px; height: 400px; color: #333; font-family: \"Consolas\", \"Monaco\", \"Bitstream Vera Sans Mono\", \"Courier New\", \"sans-serif\"; font-size: 12px; } #code .string{ color: #2a36ff; } #code .keyword{ color: #7f0055; font-weight:bold; } #code .placeholder{ margin-left:15px; } #code .space{ margin-left:7px; } #code .comments{ color: #3f7f5f; } #copyright{ margin-top: 10px; text-align: center; width:100%; color:#666; } #errorMsg{ width: 100%; text-align: center; font-size: 24px; position: absolute; top: 100px; left:0px; } #copyright a{ color:#666; }","link":"/gallery/css/default_dev.css"},{"title":"","text":"var $window=$(window),gardenCtx,gardenCanvas,$garden,garden;var clientWidth=$(window).width();var clientHeight=$(window).height();$(function(){$loveHeart=$(\"#loveHeart\");var a=$loveHeart.width()/2;var b=$loveHeart.height()/2-55;$garden=$(\"#garden\");gardenCanvas=$garden[0];gardenCanvas.width=$(\"#loveHeart\").width();gardenCanvas.height=$(\"#loveHeart\").height();gardenCtx=gardenCanvas.getContext(\"2d\");gardenCtx.globalCompositeOperation=\"lighter\";garden=new Garden(gardenCtx,gardenCanvas);$(\"#content\").css(\"width\",$loveHeart.width()+$(\"#code\").width());$(\"#content\").css(\"height\",Math.max($loveHeart.height(),$(\"#code\").height()));$(\"#content\").css(\"margin-top\",Math.max(($window.height()-$(\"#content\").height())/2,10));$(\"#content\").css(\"margin-left\",Math.max(($window.width()-$(\"#content\").width())/2,10));setInterval(function(){garden.render()},Garden.options.growSpeed)});$(window).resize(function(){var b=$(window).width();var a=$(window).height();if(b!=clientWidth&&a!=clientHeight){location.replace(location)}});function getHeartPoint(c){var b=c/Math.PI;var a=19.5*(16*Math.pow(Math.sin(b),3));var d=-20*(13*Math.cos(b)-5*Math.cos(2*b)-2*Math.cos(3*b)-Math.cos(4*b));return new Array(offsetX+a,offsetY+d)}function startHeartAnimation(){var c=50;var d=10;var b=new Array();var a=setInterval(function(){var h=getHeartPoint(d);var e=true;for(var f=0;f=30){clearInterval(a);showMessages()}else{d+=0.2}},c)}(function(a){a.fn.typewriter=function(){this.each(function(){var d=a(this),c=d.html(),b=0;d.html(\"\");var e=setInterval(function(){var f=c.substr(b,1);if(f==\"\",b)+1}else{b++}d.html(c.substring(0,b)+(b&1?\"_\":\"\"));if(b>=c.length){clearInterval(e)}},75)});return this}})(jQuery);function timeElapse(c){var e=Date();var f=(Date.parse(e)-Date.parse(c))/1000;var g=Math.floor(f/(3600*24));f=f%(3600*24);var b=Math.floor(f/3600);if(b","link":"/gallery/js/functions.js"},{"title":"","text":"// variables var $window = $(window), gardenCtx, gardenCanvas, $garden, garden; var clientWidth = $(window).width(); var clientHeight = $(window).height(); $(function () { // setup garden $loveHeart = $(\"#loveHeart\"); var offsetX = $loveHeart.width() / 2; var offsetY = $loveHeart.height() / 2 - 55; $garden = $(\"#garden\"); gardenCanvas = $garden[0]; gardenCanvas.width = $(\"#loveHeart\").width(); gardenCanvas.height = $(\"#loveHeart\").height() gardenCtx = gardenCanvas.getContext(\"2d\"); gardenCtx.globalCompositeOperation = \"lighter\"; garden = new Garden(gardenCtx, gardenCanvas); $(\"#content\").css(\"width\", $loveHeart.width() + $(\"#code\").width()); $(\"#content\").css(\"height\", Math.max($loveHeart.height(), $(\"#code\").height())); $(\"#content\").css(\"margin-top\", Math.max(($window.height() - $(\"#content\").height()) / 2, 10)); $(\"#content\").css(\"margin-left\", Math.max(($window.width() - $(\"#content\").width()) / 2, 10)); // renderLoop setInterval(function () { garden.render(); }, Garden.options.growSpeed); }); $(window).resize(function() { var newWidth = $(window).width(); var newHeight = $(window).height(); if (newWidth != clientWidth && newHeight != clientHeight) { location.replace(location); } }); function getHeartPoint(angle) { var t = angle / Math.PI; var x = 19.5 * (16 * Math.pow(Math.sin(t), 3)); var y = - 20 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)); return new Array(offsetX + x, offsetY + y); } function startHeartAnimation() { var interval = 50; var angle = 10; var heart = new Array(); var animationTimer = setInterval(function () { var bloom = getHeartPoint(angle); var draw = true; for (var i = 0; i < heart.length; i++) { var p = heart[i]; var distance = Math.sqrt(Math.pow(p[0] - bloom[0], 2) + Math.pow(p[1] - bloom[1], 2)); if (distance < Garden.options.bloomRadius.max * 1.3) { draw = false; break; } } if (draw) { heart.push(bloom); garden.createRandomBloom(bloom[0], bloom[1]); } if (angle >= 30) { clearInterval(animationTimer); showMessages(); } else { angle += 0.2; } }, interval); } (function($) { $.fn.typewriter = function() { this.each(function() { var $ele = $(this), str = $ele.html(), progress = 0; $ele.html(''); var timer = setInterval(function() { var current = str.substr(progress, 1); if (current == '","link":"/gallery/js/functions_dev.js"},{"title":"","text":"function Vector(a,b){this.x=a;this.y=b}Vector.prototype={rotate:function(b){var a=this.x;var c=this.y;this.x=Math.cos(b)*a-Math.sin(b)*c;this.y=Math.sin(b)*a+Math.cos(b)*c;return this},mult:function(a){this.x*=a;this.y*=a;return this},clone:function(){return new Vector(this.x,this.y)},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},subtract:function(a){this.x-=a.x;this.y-=a.y;return this},set:function(a,b){this.x=a;this.y=b;return this}};function Petal(a,f,b,e,c,d){this.stretchA=a;this.stretchB=f;this.startAngle=b;this.angle=e;this.bloom=d;this.growFactor=c;this.r=1;this.isfinished=false}Petal.prototype={draw:function(){var a=this.bloom.garden.ctx;var e,d,c,b;e=new Vector(0,this.r).rotate(Garden.degrad(this.startAngle));d=e.clone().rotate(Garden.degrad(this.angle));c=e.clone().mult(this.stretchA);b=d.clone().mult(this.stretchB);a.strokeStyle=this.bloom.c;a.beginPath();a.moveTo(e.x,e.y);a.bezierCurveTo(c.x,c.y,b.x,b.y,d.x,d.y);a.stroke()},render:function(){if(this.r","link":"/gallery/js/garden.js"},{"title":"","text":"function Vector(x, y) { this.x = x; this.y = y; }; Vector.prototype = { rotate: function (theta) { var x = this.x; var y = this.y; this.x = Math.cos(theta) * x - Math.sin(theta) * y; this.y = Math.sin(theta) * x + Math.cos(theta) * y; return this; }, mult: function (f) { this.x *= f; this.y *= f; return this; }, clone: function () { return new Vector(this.x, this.y); }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y); }, subtract: function (v) { this.x -= v.x; this.y -= v.y; return this; }, set: function (x, y) { this.x = x; this.y = y; return this; } }; function Petal(stretchA, stretchB, startAngle, angle, growFactor, bloom) { this.stretchA = stretchA; this.stretchB = stretchB; this.startAngle = startAngle; this.angle = angle; this.bloom = bloom; this.growFactor = growFactor; this.r = 1; this.isfinished = false; //this.tanAngleA = Garden.random(-Garden.degrad(Garden.options.tanAngle), Garden.degrad(Garden.options.tanAngle)); //this.tanAngleB = Garden.random(-Garden.degrad(Garden.options.tanAngle), Garden.degrad(Garden.options.tanAngle)); } Petal.prototype = { draw: function () { var ctx = this.bloom.garden.ctx; var v1, v2, v3, v4; v1 = new Vector(0, this.r).rotate(Garden.degrad(this.startAngle)); v2 = v1.clone().rotate(Garden.degrad(this.angle)); v3 = v1.clone().mult(this.stretchA); //.rotate(this.tanAngleA); v4 = v2.clone().mult(this.stretchB); //.rotate(this.tanAngleB); ctx.strokeStyle = this.bloom.c; ctx.beginPath(); ctx.moveTo(v1.x, v1.y); ctx.bezierCurveTo(v3.x, v3.y, v4.x, v4.y, v2.x, v2.y); ctx.stroke(); }, render: function () { if (this.r","link":"/gallery/js/garden_dev.js"},{"title":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(\"left\")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:\"script\"}):c.globalEval(b.text||b.textContent||b.innerHTML||\"\");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===\"object\"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o\\s]+\\/)>/g,'=\"$1\">').replace(V,\"\")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find(\"*\"),b.find(\"*\"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja, \"\"):null;else if(typeof a===\"string\"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]); return this}else{e=0;for(var j=d.length;e0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement===\"undefined\")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i===\"number\")i+=\"\";if(i){if(typeof i===\"string\"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i===\"string\"){i=i.replace(Ka,Ma);var o=(La.exec(i)||[\"\", \"\"])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement(\"div\");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o===\"table\"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]===\"\"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],\"tbody\")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e= c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],\"script\")&&(!e[j].type||e[j].type.toLowerCase()===\"text/javascript\"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName(\"script\"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]? c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\\([^)]*\\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\\d+(?:px)?$/i,nb=/^-?\\d/,ob={position:\"absolute\",visibility:\"hidden\",display:\"block\"},pb=[\"Left\",\"Right\"],qb=[\"Top\",\"Bottom\"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?\"cssFloat\":\"styleFloat\",ja= function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e===\"number\"&&!kb.test(f))e+=\"px\";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b===\"width\"||b===\"height\")&&parseFloat(d)=0?parseFloat(Oa.exec(f.filter)[1])/100+\" \":\"\"}if(ha.test(b))b=\"Pa;b=b.replace(ia,ja);if(e)f[b]=d;return\" f[b]},css:function(a,b,d,f){if(b=\"==\" width\"||b=\"==\"height\"){var\"\" e,j=\"b===\" width\"?pb:qb;function\"=\"\" i(){e=\"b===\" width\"?a.offsetwidth:a.offsetheight;f!=\"=\"border\"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,\"padding\"+this,true))||0);if(f===\"margin\")e+=parseFloat(c.curCSS(a,\"margin\"+this,true))||0;else\"\" e-=\"parseFloat(c.curCSS(a,\" \"border\"+this+\"width\",true))||0})}a.offsetwidth!=\"=0?i():c.swap(a,ob,i);return\" math.max(0,math.round(e))}return=\"\" c.curcss(a,b,d)},curcss:function(a,b,d){var=\"\" f,e=\"a.style;if(!c.support.opacity&&b===\" opacity\"&&a.currentstyle){f=\"Oa.test(a.currentStyle.filter||\"\")?parseFloat(RegExp.$1)/100+\"\":\"\";return\"\" if(rb){if(ha.test(b))b=\"float\" ;b=\"b.replace(lb,\" -$1\").tolowercase();e=\"a.ownerDocument.defaultView;if(!e)return\"\" null;if(a=\"e.getComputedStyle(a,null))f=\" a.getpropertyvalue(b);if(b=\"==\" opacity\"&&f=\"==\"\")f=\"1\"}else\"\" if(a.currentstyle){d=\"b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var\" j=\"a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d===\" fontsize\"?\"1em\":f||0;f=\"e.pixelLeft+\"px\";e.left=b;a.runtimeStyle.left=j}}return\"\" f},swap:function(a,b,d){var=\"\" e=\"\" in=\"\" b){f[e]=\"a.style[e];a.style[e]=b[e]}d.call(a);for(e\" b)a.style[e]=\"f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var\" b=\"a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()===\" tr\";return\"=\"\">0&&d>0&&!f?false:c.curCSS(a,\"display\")===\"none\"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=//gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\\?(&|$)/,ka=/\\?/,wb=/(\\?|&)_=.*?(&|$)/,xb=/^(\\w+:)?\\/\\/([^\\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!== \"string\")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(\" \");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f=\"GET\";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===\"object\"){b=c.param(b,c.ajaxSettings.traditional);f=\"POST\"}var j=this;c.ajax({url:a,type:f,dataType:\"html\",data:b,complete:function(i,o){if(o===\"success\"||o===\"notmodified\")j.html(e?c(\"\").append(i.responseText.replace(tb,\"\")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this}, serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:\"GET\",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,\"script\")},getJSON:function(a,b,d){return c.get(a,b,d,\"json\")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:\"POST\",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href, global:true,type:\"GET\",contentType:\"application/x-www-form-urlencoded\",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!==\"file:\"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(a){}},accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",script:\"text/javascript, application/javascript\",json:\"application/json, text/javascript\",text:\"text/plain\",_default:\"*/*\"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&& e.success.call(k,o,i,x);e.global&&f(\"ajaxSuccess\",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f(\"ajaxComplete\",[x,e]);e.global&&!--c.active&&c.event.trigger(\"ajaxStop\")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!==\"string\")e.data=c.param(e.data,e.traditional);if(e.dataType===\"jsonp\"){if(n===\"GET\")N.test(e.url)||(e.url+=(ka.test(e.url)? \"&\":\"?\")+(e.jsonp||\"callback\")+\"=?\");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+\"&\":\"\")+(e.jsonp||\"callback\")+\"=?\";e.dataType=\"json\"}if(e.dataType===\"json\"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||\"jsonp\"+sb++;if(e.data)e.data=(e.data+\"\").replace(N,\"=\"+j+\"$1\");e.url=e.url.replace(N,\"=\"+j+\"$1\");e.dataType=\"script\";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType===\"script\"&&e.cache===null)e.cache=false;if(e.cache=== false&&n===\"GET\"){var r=J(),u=e.url.replace(wb,\"$1_=\"+r+\"$2\");e.url=u+(u===e.url?(ka.test(e.url)?\"&\":\"?\")+\"_=\"+r:\"\")}if(e.data&&n===\"GET\")e.url+=(ka.test(e.url)?\"&\":\"?\")+e.data;e.global&&!c.active++&&c.event.trigger(\"ajaxStart\");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType===\"script\"&&n===\"GET\"&&r){var z=s.getElementsByTagName(\"head\")[0]||s.documentElement,C=s.createElement(\"script\");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B= false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState===\"loaded\"||this.readyState===\"complete\")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader(\"Content-Type\",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader(\"If-Modified-Since\", c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader(\"If-None-Match\",c.etag[e.url])}r||x.setRequestHeader(\"X-Requested-With\",\"XMLHttpRequest\");x.setRequestHeader(\"Accept\",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+\", */*\":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger(\"ajaxStop\");x.abort();return false}e.global&&f(\"ajaxSend\",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q===\"abort\"){E|| d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q===\"timeout\")){E=true;x.onreadystatechange=c.noop;i=q===\"timeout\"?\"timeout\":!c.httpSuccess(x)?\"error\":e.ifModified&&c.httpNotModified(x,e.url)?\"notmodified\":\"success\";var p;if(i===\"success\")try{o=c.httpData(x,e.dataType,e)}catch(v){i=\"parsererror\";p=v}if(i===\"success\"||i===\"notmodified\")j||b();else c.handleError(e,x,i,p);d();q===\"timeout\"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x); g(\"abort\")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g(\"timeout\")},e.timeout);try{x.send(n===\"POST\"||n===\"PUT\"||n===\"DELETE\"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger(\"ajaxError\",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol===\"file:\"||a.status>=200&&a.status=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName===\"parsererror\"&&c.error(\"parsererror\");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a===\"string\")if(b=== \"json\"||!b&&f.indexOf(\"json\")>=0)a=c.parseJSON(a);else if(b===\"script\"||!b&&f.indexOf(\"javascript\")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\\[\\]$/.test(i)?f(i,n):d(i+\"[\"+(typeof n===\"object\"||c.isArray(n)?k:\"\")+\"]\",n)});else!b&&o!=null&&typeof o===\"object\"?c.each(o,function(k,n){d(i+\"[\"+k+\"]\",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+\"=\"+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional; if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join(\"&\").replace(yb,\"+\")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\\d+-.]+)(.*)$/,W,va=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K(\"show\",3),a,b);else{a=0;for(b=this.length;a-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||\"px\";this.now=this.start; this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop===\"width\"||this.prop===\"height\"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now= this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,\"olddisplay\");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,\"display\")===\"none\")this.elem.style.display=\"block\"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem, e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?\"swing\":\"linear\");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b\"; a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position=\"fixed\";f.style.top=\"20px\";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top=\"\";d.style.overflow=\"hidden\";d.style.position=\"relative\";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b); c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,\"marginTop\",true))||0;d+=parseFloat(c.curCSS(a,\"marginLeft\",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,\"position\")))a.style.position=\"relative\";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,\"top\",true),10)||0,i=parseInt(c.curCSS(a,\"left\",true),10)||0;if(c.isFunction(b))b=b.call(a, d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};\"using\"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,\"marginTop\",true))||0;d.left-=parseFloat(c.curCSS(a,\"marginLeft\",true))||0;f.top+=parseFloat(c.curCSS(b[0],\"borderTopWidth\",true))||0;f.left+=parseFloat(c.curCSS(b[0],\"borderLeftWidth\",true))||0;return{top:d.top- f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,\"position\")===\"static\";)a=a.offsetParent;return a})}});c.each([\"Left\",\"Top\"],function(a,b){var d=\"scroll\"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?\"pageXOffset\"in j?j[a?\"pageYOffset\": \"pageXOffset\"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each([\"Height\",\"Width\"],function(a,b){var d=b.toLowerCase();c.fn[\"inner\"+b]=function(){return this[0]?c.css(this[0],d,false,\"padding\"):null};c.fn[\"outer\"+b]=function(f){return this[0]?c.css(this[0],d,false,f?\"margin\":\"border\"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return\"scrollTo\"in e&&e.document?e.document.compatMode===\"CSS1Compat\"&&e.document.documentElement[\"client\"+b]||e.document.body[\"client\"+b]:e.nodeType===9?Math.max(e.documentElement[\"client\"+b],e.body[\"scroll\"+b],e.documentElement[\"scroll\"+b],e.body[\"offset\"+b],e.documentElement[\"offset\"+b]):f===w?c.css(e,d):this.css(d,typeof f===\"string\"?f:f+\"px\")}});A.jQuery=A.$=c})(window);","link":"/gallery/js/jquery.js"}],"posts":[{"title":"Hexo+icarus主题配置","text":"下载icarus主题 进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面 输入： git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 打开themes文件夹，就会发现多了一个icarus文件夹，这就是主题的所有文件 配置主题 更改站点配置文件_config.yml,将主题改为icarus theme: icarus Icarus文件目录概览： $config.yml$是主题的配置文件 $/layout$ 文件夹中是主题各种模板文件 我们主要的超作就是在这两个文件中了 主题配置文件（部分）# Version of the Icarus theme that is currently usedversion: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 上述设置已经让你的博客稍微有点属于你的样子了，下面来添加一些有意思的元素。 添加雪花飘落效果 在 $\\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$目录下新建一个 snow.js 文件(若没有src/文件夹可以自己新建)，复制粘贴以下代码： 样式1：六边形雪花 (function($){ $.fn.snow = function(options){ var $flake = $('').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('❄'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = { minSize : 10, maxSize : 20, newOn : 1000, flakeColor : \"#AFDAEF\" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ }, options = $.extend({}, defaults, options); var interval= setInterval( function(){ var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css({ left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor }).animate({ top: endPositionTop, left: endPositionLeft, opacity: 0.2 },durationFall,'linear',function(){ $(this).remove() }); }, options.newOn); };})(jQuery);$(function(){ $.fn.snow({ minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ });});作者：donlex链接：http://www.imooc.com/article/272005 样式2：圆点状雪花 function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / 60); };cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){ /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)}/* 创建画布 */function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function() { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */}flakeMove.prototype.update = function() { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) { this.velY = this.speed } this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) { this.reset(canvas.width, canvas.height) }};/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) { this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;};// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) { var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, \"rgba(255, 255, 255, 0.9)\"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, \"rgba(255, 255, 255, 0.5)\"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, \"rgba(255, 255, 255, 0)\"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();};/* 创建雪花-定义形状 */function createFlakes() { var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) { flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) }}/* 画雪 */function drawSnow() { var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) { flakes[e].update(); flakes[e].render(ctx); } /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() { drawSnow.apply(that); });}/* 调用及控制方法 */var snow = new snowFall({maxFlake:60});snow.start();作者：donlex链接：http://www.imooc.com/article/272005 最后在$\\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$的$body$标签中添加代码： &lt;!-- 雪花特效 --&gt; &lt;script type=\"text/javascript\"&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) { document.write('&lt;script type=\"text/javascript\" src=\"/js/src/snow.js\"&gt;&lt;\\/script&gt;'); } &lt;/script&gt; 默认雪花为白色，可自行更改颜色，效果可见本站 网站访问量与访客量统计 不蒜子官网：http://busuanzi.ibruce.info/ 在$\\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$模板文件的中添加如下代码： &lt;span id=\"busuanzi_container_site_pv\" class=\"theme-info\"&gt; | 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;span&gt;次 span&gt; &lt;span id=\"busuanzi_container_site_uv\" class=\"theme-info\"&gt; | 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;span&gt;人次 span&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;script&gt; 在$\\color{DarkTurquoise}{/themes/icarus/_config.yml}$中添加： busuanzi: enable: true 最终效果： 网站运行时间统计 在$\\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$中添加： &lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(\"12/28/2018 12:49:00\");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = \"0\" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \"0\" + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \"0\" + snum;} document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; } setInterval(\"createtime()\",250); &lt;/script&gt; 修改自己的建站时间 最终效果： 鼠标点击特效 在 $\\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$中添加click.js文件，复制以下代码进去： !function(e,t,a){ function n(){ c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\"); requestAnimationFrame(r) } function o(){ var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(\"div\"); a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(\"style\");a.type=\"text/css\"; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(\"head\")[0].appendChild(a) } function s(){ return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 最后在$\\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$文件中的 &lt;!DOCTYPE html&gt; 的下一行添加： &lt;script src=\"/js/src/click.js\"&gt;&lt;/script&gt; 效果见本站 看板娘插件 在博客主目录下进入点击进入Git Bash Here 输入命令： npm install hexo-helper-live2d --save 在网站配置文件或主题配置文件$\\color{green}{_config.yml}$中添加： live2d: enable: true #开启看板娘 scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-z16 #指定模型任务 display: position: right #显示位置 width: 200 #模型宽度 height: 400 #模型高度 mobile: show: true #是否在移动端显示 效果：见本站 遇到的坑及解决方法 ..公式渲染问题 .. ..$\\color{green}{Waiting….for….update….}$","link":"/2019/04/29/Hexo+icarus主题配置/"},{"title":"【数据结构】树","text":"树的基本概念 树的定义：前面所提到的线性结构的元素是一种一对一的关系，而树是一种一对多的非线性结构，下面将通过一个具体的树的例子讲解到底什么样的结构才是树以 及树的一些相关术语： 上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵空树。结点：上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；结点的度：该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；树的度：树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；叶子结点：又称为终端结点，指的是度为零的结点非终端结点：又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为内部结点。祖先：从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：A和B，因为路径为：A–B–E；层次：根处为第一层，以此类推……，如上图树的层次为4层；结点的深度和高度：联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；有序树：树中结点的子树从左到右都是有次序的不能交换无序树：树中结点的子树没有次序，可以任意交换丰满树：理想的平衡树，要求除了最底层外，其他层都是满的森林：若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林 树的存储结构 顺序存储：双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法) 链式存储：孩子存储结构（孩子表示法）孩子兄弟存储结构（孩子兄弟表示法） 二叉树 二叉树的五种基本形式 满二叉树的概念 完全二叉树的概念二叉树的几个重要性质 性质一：非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$； 性质二：二叉树的第$i$层上最多有$2^{i-1}$; 性质三：高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$. 性质四：该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述； 性质五：函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\\frac{1}{n+1}×C_{2n}^n$ ; 性质六：具有$n$个结点的完全二叉树的高度（或深度）为$[\\log_2{n}]+1$(向下取整)； 二叉树的存储结构 顺序存储结构：用一个数组来存储完全二叉树，将完全二叉树的结点值按编号依次存入一个一维数组中。 如果要从一维数组中还原二叉树的本来结构，按照以下规则：$i$ 为某结点的编号，若$i\\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；如果$2i\\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；如果$2i+1 \\leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；下面给出将数组还原成二叉链树的代码：void creatBTree(int BT[],int n,BTNode *&amp;e){ BTNode *BTNode_array[maxsize]; for(int i = 1;i &lt;= n;++i ){ BTNode_array[i] = (BTNode*)malloc(sizeof(BTNode)); BTNode_array[i] -&gt; data = BT[i]; BTNode_array[i] -&gt; lchild = NULL; BTNode_array[i] -&gt; rchild = NULL; } for (int i = 1;i &lt;= n;++i){ if(2*i &lt;= n ){ BTNode_array[i] -&gt; lchild = BTNode_array[2*i]; } if((2*i+1) &lt;= n){ BTNode_array[i] -&gt; rchild = BTNode_array[2*i+1]; } } e = BTNode_array[1];} 链式存储结构：为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：typedef struct BTNode{ int data; //数据域 struct BTNode *lchild;//指向左孩子的指针 struct BTNode *rchild;//指向右孩子的指针}; 二叉树的遍历算法(递归实现)：深度优先遍历： 前序遍历： void preorder(BTNode *p){ if(p != NULL){ Visit(p); preorder(p -&gt; lchild); preorder(p -&gt; rchild); }} 中序遍历： void inorder(BTNode *p){ if(p != NULL){ inorder(p -&gt; lchild); Visit(p); inorder(p -&gt; rchild); }} 后序遍历： void postorder(BTNode *p){ if(p != NULL){ postorder(p -&gt; lchild); postorder(p -&gt; rchild); Visit(p); }} 广度优先遍历： 算法流程图解：void level (BTNode *p){ if(p != NULL){ BTNode *que[maxsize]; int front = 0; int rear = 0; BTNode *q; rear = (rear + 1)%maxsize; que[rear] = p; while(front != rear){ front = (front + 1)%maxsize; q = que[front]; Visit(q); if(q -&gt; lchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; lchild; } if(q -&gt; rchild != NULL){ rear = (rear + 1)%maxsize; que[rear] = q -&gt; rchild; } } }} 二叉树的遍历算法(非递归实现) 上图而查处将作为例子方便讲解下面的算法 深度优先遍历算法： 先序遍历： void preorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; Stack[++top] = bt; while(top != NULL){ p = Stack[top--]; Visit(p); if(p -&gt; rchild != NULL){ Stack[++top] = p -&gt; rchild; } if(p -&gt; lchild != NULL){ Stack[++top] = p -&gt; lchild; } } }} 后序遍历：先序遍历算法遍历例子二叉树将得到：A B D E C F G后序遍历例子二叉树：D E B F G C A将后序遍历序列逆置：A C G F B E D可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。 void postorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode Stack1[maxsize]; BTNode Stack2[maxsize]; int top1 = -1; int top2 = -1; BTNode *p = NULL; Stack1[++top1] = bt; while(top1 != -1){ p = Stack1[top--]; Stack2[++top] = p; if(p -&gt; lchild != NULL){ Stack1[++top] = p -&gt; lchild; } if(p -&gt; rchild != NULL){ Stack1[++top] = p -&gt; rchild; } } while(top2 != -1){ p = Stack2[top--]; Visit(p); } }} 中序遍历： void inorderNonrecursion(BTNode *bt){ if(bt != NULL){ BTNode *Stack[maxsize]; int top = -1; BTNode *p; p = bt; while(top != -1 || p != NULL){ while(p -&gt; lchild != NULL){ Stack[++top] = p; p = p -&gt; lchild; } if(top != -1){ p = Stack[top--]; Visit(p); p = p -&gt; rchild; } } }} 线索二叉树 对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。 线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。线索二叉树的构造：结点定义： typedef struct TBTNode{ int data; // 数据域 struct TBTNode *lchild; // 左孩子（前驱结点）指针 struct TBTNode *rchild; // 右孩子（后继结点）指针 int ltag , rtag; //线索标记}; 根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。通过中序遍历对二叉树线索化代码： void InThread(TBTNode *p,TBTNode *&amp;pre){ if(p != NULL){ InThread(p -&gt; lchild,pre); // 递归地线索化左子树 if(p -&gt; lchild == NULL){ // 建立当前结点前驱线索 p -&gt; lchild = pre; p -&gt; ltag = 1; } if(pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ // 建立前驱结点的后继线索 pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; // pre 跟上 p，之后p会指向下一个结点 InThread(p -&gt; rchild,pre); // 递归地线索化右子树 }} 通过中序遍历线索二叉树的主程序如下：void creatTBTNode(TBTNode *root){ TBTNode *pre = NULL; if(root != NULL){ InThread(root,pre); //递归建立线索二叉树 pre -&gt; rchild = NULL; // 处理最后一个结点 pre -&gt; rtag = 1; }} 遍历中序线索二叉树：寻找中序线索二叉树 root 的第一个遍历结点：TBTNode *First(TBTNode *root){ while( root -&gt; ltag == 0){ root = root -&gt; lchild; } return root;} 在中序线索二叉树中，求结点p在中序下的后继结点的算法：TBTNode *Next(TBTNode *p){ if(p -&gt; rtag == 0){ return First(p -&gt; rchild); } else return p -&gt; rchild; // rtag = 1; 直接返回后继线索} 在中序线索二叉树上执行中序遍历：void Inoreder(TBTNode *root){ for (TBTNode *p = First(root);p != NULL;p = Next(p)){ Visit(p); }} 通过前序遍历对二叉树线索化void preInThread(TBTNode *p,TBTNode *&amp;pre){ if (p != NULL){ if(p -&gt; lchild != NULL){ p -&gt; lchild = pre; p -&gt; ltag = 1; } if (pre != NULL &amp;&amp; pre -&gt; rchild == NULL){ pre -&gt; rchild = p; pre -&gt; rtag = 1; } pre = p; if (p -&gt; ltag == 0){ preThread(p -&gt; lchild,pre); } if (p -&gt; rtag == 0){ preThread(p -&gt; rchild,pre); } }} 遍历前序线索二叉树算法：void preorder(TBTNode *root){ if(root != NULL){ TBTNode *p = root; while(p != NULL){ while(p -&gt; ltag == 0){ Visit(p); p = p -&gt; lchild; } Visit(p); p = p -&gt; rchild; } }} 树与森林的互相转换 树与二叉树的应用 二叉排序树与二叉平衡树 赫夫曼树与赫夫曼编码 赫夫曼树的相关概念及介绍：赫夫曼树又被称为最优二叉树，它的特点是带权路径最短。下面介绍几个相关概念： 路径：指从树中一个结点到另一个结点的分支所构成的路线 路径长度：路径上的分支数目 树的路径长度：从根到每个结点的路径长度之和 带权路径长度：结点具有权值，从该结点到根结点的路径长度乘于该结点的权值就是该结点的带权路径长度 树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和 赫夫曼树的构造方法：给定$n$个权值，用这些个权值来构造赫夫曼树：首先了解一下赫夫曼树的一些特点： 权值越大的结点距离根节点越近 树中没有度为1的结点 树的带权路径长度最短 根据上述特点反推我们是如何来构造一个赫夫曼树： 从最底层开始构造 最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点 权值最大的结点离根节点最近 有了上述导论我们就可以开始构造一棵赫夫曼树了：上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。 赫夫曼编码： * 利用赫夫曼树的特点来对文件进行压缩存储 看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$选三位长度的二进制数为A到E编码：根据上表我们可以将该字符串编码为：$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$解码时每三位一个字符解码总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？ 答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：到此我们得到了对A到E的霍夫曼编码规则：根据上表的编码规则可将字符串编码为：$1110010101101011110011110101010110111000011001011111111110110$只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。 解码霍夫曼编码：解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。 [注] 对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的 霍夫曼$n$叉树 霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例 构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。","link":"/2019/03/05/BinaryTree/"},{"title":"Hexo-icarus修改文章详情页","text":"为什么修改？ 由于Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局。但是三栏布局限制了文章内容的展示，因此试图将其改为两栏布局。 通过修改源代码来达成目标打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中：&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动：&lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=\"column &lt;%= col() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码：&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt; 大功告成我这里保存的是左边栏，若要保存右边栏可以在 widget.ejs 文件中更改（已标识）。 效果见本站！","link":"/2019/05/01/Hexo-icarus修改文章详情页/"},{"title":"【教程】Hexo+Github博客搭建","text":"开始 对于萌新来说，Hexo是一个非常容易上手的轻量级博客平台，只需简单的配置便可以打造令人满意的博客页面，下面是我自己搭建博课的流程，在此记录以备后续的需要。 Step1:前期准备: 安装Node.js : Download 安装git for win: Download 注册GitHub账号: Github.com Step2: 在GitHub中新建（New）一个库（Repositories），用来存放网站内容： Step3:连接git与GitHub账户： 在桌面点击鼠标右键，选择Git Bash Here 会跳出终端窗口输入命令并回车： ssh-keygen 根据路径找到密钥文件并打开： 打开你的GitHub账户点击右上角的头像选择setting –&gt; SSH and GPG keys: 至此，成功连接GIt与GitHub账户。 Step4:*安装Hexo： 在桌面打开Git Bash Here终端输入命令： npm install -g hexo-cli 如果许久后未能安装，说明网络太慢，可更换安装源Ctrl+C，在终端输入：npm config set registry http://registry.cnpmjs.org 安装成功后，在电脑的任意磁盘内建立文件夹以存放Hexo网站： 这是我创建的路径：blog文件夹将被用于博客 进入blog文件夹点击鼠标右键进入Git Bash Here终端，依次执行命令： hexo init //初始化文件夹为博客根目录hexo install //安装必要依赖文件 安装hexo-deployer-git插件： npm install hexo-deployer-git –save 到此，还记得之前创建的GitHub库吗？ 打开该仓库复制仓库的SSH地址： 进入网站根目录/blog,用编辑器（vs code)打开 _config.yml 网站配置文件： 修改_config.yml 配置文件保存并退出： 回到Git终端，执行命令： hexo g -d //将网站部署到GitHub上 至此，可在浏览器内输入你的博客地址查看是否成功： Step5:如何写作： 回到blog文件夹内，/source/_post/ 文件夹内的Markdown文件就是你的博文存放处 你可以新建md文档写作并用hexo g -d 命令将更新的博文部署到网站上 也可以利用HexoEdit编辑器写作并上传，详情可见我的另一篇博文HesoEditor教程 关于Markdown语法网上有许多教程可供学习Markdown中文文档 关于Hexo主题更换配置我会在以后的文章中介绍，若有错误请指明，不甚感激。Thanks for your watching !!!!!!","link":"/2018/12/26/HexoGitHub/"},{"title":"【工具】HexoEditor编辑器的安装配置及使用","text":"HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。GitHub：HexoEditor Step1: 安装 HexoEditor: 下载链接：Download 支持 Linux 、Windows 、MacOS Step2: 简单设置： Hexo配置文件选择网站根目录下的_config.yml文件 Tag模板目录选择网站很目录下的 /scaffolds 文件夹 主题随意选择 默认资源库可在网站根目录source文件夹内新建文件夹来存放文章图片资源 云图类型可默认，SM.MS云图为免费云端，也可自选其他云端服务 Step3:撰写文章： 点击新建Post可生成新的模板文档，开始写作。 在预览试图中右键点击所插入的图片，点击上传至SM.MS可将本地图片上传至云端，之后会发现文章中的图片Path变为URL链接。 Step4:发布文章： 右键 –&gt; Hexo –&gt; 部署网站","link":"/2018/12/27/HexoEditor/"},{"title":"Hexo用MathJax渲染数学公式","text":"更改默认Markdown渲染引擎 Hexo的默认Markdown渲染引擎为hexo-renderer-marked，将其替换为hexo-renderer-kramed,对于这一步，网上的大部分教程是这么干的：npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 也就是先卸载掉默认引擎，再安装新引擎。但是我的npm出了问题，而且我个人觉得npm实在是不好用，因此我下载了yarn，并执行：yarn remove hexo-renderer-markedyarn add hexo-renderer-kramed 但当我执行hexo clean时却出现了类似下面的错误：Error: hexo-renderer-marked is not installed , please install .... 所以一直无法成功。后来我想干脆不卸载marked渲染引擎，直接安装kramed：yarn add hexo-renderer-kramed 安装MathJax卸载hexo-math：yarn remove hexo-math 再安装hexo-renderer-mathjax：yarn add hexo-renderer-mathjax -S 解决行内公式语义冲突在博客的根目录下找到$\\color{red}{node_modules/kramed/lib/rules/inline.js}$做如下两处更改：var inline = { //escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, 第一处 escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, //em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第二处 em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| {2,}\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,}; 更改Mathjax加载脚本找到$\\color{red}{node-modules/hexo-renderer-mathjax/mathjax.html}$将最后一句改为：&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt; 大功告成hexo g -d 将改动部署到博客","link":"/2019/04/30/Hexo用MathJax渲染数学公式/"},{"title":"LeetCode1178_Hard_猜字谜","text":"题目描述：外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例：输入：words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 \"aboveyz\" 的谜底 : \"aaaa\" 1 个单词可以作为 \"abrodyz\" 的谜底 : \"aaaa\"3 个单词可以作为 \"abslute\" 的谜底 : \"aaaa\", \"asas\", \"able\"2 个单词可以作为 \"absoryz\" 的谜底 : \"aaaa\", \"asas\"4 个单词可以作为 \"actresz\" 的谜底 : \"aaaa\", \"asas\", \"actt\", \"access\"没有单词可以作为 \"gaswxyz\" 的谜底，因为列表中的单词都不含字母 'g'。 提示： 1 &lt;= words.length &lt;= 10^5 4 &lt;= words[i].length &lt;= 50 1 &lt;= puzzles.length &lt;= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] 都是小写英文字母。 每个 puzzles[i] 所包含的字符都不重复。 题解：法一：暴力枚举判断（超时）这个算法很直观，无非就是遍历枚举每一个谜面，判断words中能作为它的谜底的word的个数。vector&lt;int&gt; findNumOfVaildWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles){ vector&lt;int&gt; res; for(auto i : puzzles) { int charcounter[26] = {0}; for(auto j : i) { charcounter[j-'a']++; } int ans = 0; for(auto k : words) { bool flag = true; unordered_set&lt;char&gt; chset; for(auto m : k) { chset.insert(m); if(chset.size()&gt;7) { flag = false; break; } } if(flag) { if(chset.find(i[0])==chset.end()) continue; else { auto iter = chset.begin(); bool flags = true; for(;iter != chset.end();iter++) { if(charcounter[(*iter)-'a'] &lt;= 0) { flags = false; break; } } if(flags) ans++; } } } res.push_back(ans); } return res;} 法二：暴力枚举+位运算（超时）已知int行为32位，而小写字母有26个，因此用一个int型的整数就能够表示字符串中是否出现某字符： 上图就可以表示字符串“anwvw”因此思路就是沿用上面的暴力枚举方法，只不过将字符串查询比较转化为整数的比较。 vector&lt;int&gt; findNumOfVaildWords_BTL(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles){ vector&lt;int&gt; res; vector&lt;int&gt; binOfpuzzles; for(auto i : puzzles) { //生成谜面的二进制数 int puzzle = 0; for(auto j : i) { puzzle = puzzle | (1 &lt;&lt; (j-'a')); } binOfpuzzles.push_back(puzzle); } vector&lt;int&gt; binOfwords; for(auto&amp; k : words) { //生成谜底的二进制数 int word = 0; int cnt = 0; for(auto&amp; m : k) { word = word | (1 &lt;&lt; (m-'a')); } binOfwords.push_back(word); } int n = 0; for(auto&amp; i : binOfpuzzles) { int ans = 0; for(auto&amp; j : binOfwords) { if(i == j) ans++; else if(i &lt; j) continue; else if((((1 &lt;&lt; (puzzles[n][0]-'a')) &amp; j) != 0)) //如果word中包含puzz的第一个字母 { bool flag = true; for(int k = 0;k &lt; 26;k++) //判断是否符合第二条件 { if( ((int)((1 &lt;&lt; k)&amp;i) == 0) &amp;&amp; ((int)((1 &lt;&lt; k)&amp;j) != 0) ) //word中存在而puzz中不存在 { flag = false; break; } } if(flag) ans++; } } res.push_back(ans); n++; } return res;} 这个算法虽然比第一个好点但是当面对更大规模的测试样例时还是会超时。 法三：位运算+哈希分析题设，根据第一个成为谜底的条件就是word中必须包含puzzle中的第一个字符，因此可以建立26个字符与包含该字符的word的整数表示所组成的数组的映射关系： 如此一来，我们就只需判断包含puzzle首字符的word是否是谜底就可以了，减少了很多无用重复的比较。再者，不难发现若某一个word是puzzle的谜底那么其包含的字符种类肯定小于等于puzzle所包含的字符种类，这体现在整数化的字符串中就是：intOfWord的二进制值中 1 的位数肯定少于或等于intOfPuzzle中 1 的位数，并且intOfWord中 1 出现的位必将也是intOfPuzzle中 1 出现的位。因此对intOfWord和intOfPuzzle取余就会得到它们共同拥有的字符的字符串的整数表示，若该结果等与intOfWord就表明此时的word就是谜底。 最终算法如下：vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) { //v用来保存含有'a'+i字母的word的二进制数 vector&lt;int&gt; hashV[26]; for (auto&amp; i : words) { unordered_set&lt;char&gt; s(i.begin(), i.end()); int tmp = 0; //生成一个谜底word的二进制数 for (int ii = 0; ii &lt; 26; ii++) if (s.count('a' + ii)) tmp = tmp^(1 &lt;&lt; ii); // for (char j : s) hashV[j - 'a'].push_back(tmp); } //结果数组ans vector&lt;int&gt; ans; // for (auto&amp; i : puzzles) { int at = i[0] - 'a';//记录首字母 unordered_set&lt;char&gt; s(i.begin(), i.end()); int tmp = 0; //生成一个谜面的二进制数 for (int ii = 0; ii &lt; 26; ii++) if (s.count('a' + ii)) tmp ^= 1 &lt;&lt; ii; ans.push_back(0); for (int j : hashV[at]) //hashV[at]中保存的是包含puzzle首字母的word的二进制数 if ((j &amp; tmp) == j) //j &amp; tmp 会得到它们共同拥有的字符的二进制数， ans.back()++; //若其值与(j)不相等则表示word中含有puzzle中不含的字符 } return ans;} 运行测试：int main(){ vector&lt;string&gt; words = {\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"}; vector&lt;string&gt; puzzles = {\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"}; vector&lt;int&gt; res(findNumOfValidWords(words,puzzles)); for(auto i : res) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;} END","link":"/2019/09/06/LeetCode1178_Hard_猜字谜/"},{"title":"LeetCode23 合并 K 个排序链表(Hard)","text":"题目描述：&emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 题解：&emsp;因为所给链表均有序且头节点指针均在一个数组中，可以将当前数组中的头节点指针所指向的链表节点的值与其所在下标绑定为一个 pair 并存入一个最小堆中（按节点val排序，由优先级队列实现），这样就可以每次从堆中（pop）取出最小值用尾插法插入结果链表中。并且每次pop后都更新lists数组，将新的头节点的 pair 推入最小堆中，如此循环往复直至堆为空。 算法演示： I. 初始化堆：priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;&gt; Q; //初始化优先级队列，将lists中的元素下标与其所指链表节点的val绑定为pair入堆 for(int i=0;i&lt;lists.size();i++) { if(lists[i] != NULL) { //加负号取反，间接实现小顶堆 Q.push(make_pair(-lists[i]-&gt;val,i)); } } II. 从堆中取出最小元素（堆顶）并更新lists数组与堆 //实现摘下链表头节点的操作(跟新lists) p -&gt; next = new ListNode(-Q.top().first); p = p -&gt; next; int i = Q.top().second; ListNode *r = lists[Q.top().second]; lists[Q.top().second] = lists[Q.top().second] -&gt; next; delete(r);//释放内存 //弹出顶点 Q.pop();//新头节点进入 if(lists[i]!=NULL) Q.push(make_pair(-lists[i]-&gt;val, i)); 1. 更新lists数组2. 弹出堆顶3. 更新堆 III. 循环II（1、2、3）直到堆为空。 算法代码：ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists){ //定义优先级队列，对pair默认对第一个元素按从小到大排序（大顶堆） //因此push进队列时可将对应链表节点的val值取相反数，输出时还原，间接实现了小顶堆 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;&gt; Q; //初始化优先级队列，将lists中的元素下标与 for(int i=0;i&lt;lists.size();i++) { if(lists[i] != NULL) { Q.push(make_pair(-lists[i]-&gt;val,i)); } } //定义结果链表头节点 ListNode *head = new ListNode(-1),*p = head; while(!Q.empty()) { //实现摘下链表头节点的操作 p -&gt; next = new ListNode(-Q.top().first); p = p -&gt; next; int i = Q.top().second; ListNode *r = lists[Q.top().second]; lists[Q.top().second] = lists[Q.top().second] -&gt; next; delete(r); Q.pop(); if(lists[i]!=NULL) Q.push(make_pair(-lists[i]-&gt;val, i)); } return head -&gt; next;} 测试：//生成链表数组void generatList(vector&lt;ListNode*&gt;&amp; lists,vector&lt;vector&lt;int&gt;&gt;&amp; list){ if(list.size()!=lists.size()) return; for(int i = 0; i &lt; lists.size();i++) { ListNode* p = lists[i]; for(int j = 0; j &lt; list[i].size();j++) { if(p == NULL) { lists[i] = new ListNode(list[i][j]); p = lists[i];} else { p -&gt; next = new ListNode(list[i][j]); p = p -&gt; next; } } p -&gt; next = NULL; }}int main(){ vector&lt;ListNode*&gt; lists(3); vector&lt;vector&lt;int&gt;&gt; list = {{1,4,5},{1,3,4},{2,6,9}}; generatList(lists,list); ListNode* head = mergeKLists(lists); ListNode *p = head; while(p) { cout &lt;&lt; p -&gt; val &lt;&lt; endl; p = p -&gt; next; } return 0;} 运行结果： 复杂度分析：&emsp;假设 K 个链表每个链表的长度为 N ，堆的调整时间复杂度为 $ \\log_{2}{K} $，故时间复杂度为$ KN \\log_{2}{K} $.&emsp;空间复杂度为$ O(1) $. END","link":"/2019/09/10/LeetCode23合并-K-个排序链表(Hard)/"},{"title":"图解LeetCode295_Hard_MedianFinder","text":"[LC295] 数据流中的中位数(类设计）题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如： [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。示例：addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-median-from-data-stream 算法分析维护两个堆（一个大顶堆bigger，一个小顶堆smaller）来保存数据流中流过来的数字。无论何时都要保持abs(bigger.size-smaller.size)&lt;=1;并且保证大顶堆内的数字的值全都小于或等于小顶堆内的数字的值，这样就能保证大顶堆保存的是数据流中较小的一半数字，而小顶堆中保存的是另外较大的一半。 findMedian 函数设计&emsp;&emsp;如此一来，不难发现数据流的中位数查找函数 findMedian() 的逻辑就为(伪代码)：if smaller.size == bigger.size: return (smalle.top + bigger.top)/2;else if smaller.size &gt; bigger.size: return smaller.top;else return bigger.top; addNum 函数设计&emsp;&emsp;addNum() 函数在添加元素的过程中保持两个堆的动态平衡：Condition 1.保证两堆元素个数相差不超过 1Condition 2.保证大顶堆中的元素小于等于小顶堆中的任何元素 case 1: 如果两堆中的元素个数相同。这个时候无论插入哪一个堆，条件 1 都不会被破坏,因此考虑条件 2 ，将待插入元素与两堆的堆顶比较:若待插入元素为 5，显然这个时候若插入smaller会破坏条件 2，因此因插入bigger中。而若待插入为 9 则显然应插入 smaller 中。 case 2: 如果大顶堆元素个数小于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较: 若小于等于Bigger.top则直接插入Bigger中； 若大于smaller.top则为了保证条件1,需将smaller中的最小值（根）转存至Bigger中。 case 3: 如果大顶堆的元素个数大于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较： 若其大于等于Smaller.top则直接插入Smaller中； 若小于Bigger.top则为了保证条件1，需将Bigger中的最大元素值（根）转存至Smaller中。 代码实现#include \"Include_all.h\"using namespace std;class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } //插入过程中维持两堆元素个数的动态平衡 void addNum(int num) { //如果两堆元素个数相同 if(smaller.size()==bigger.size()) { if(!bigger.empty() &amp;&amp; bigger.top()&gt;=num) { cout &lt;&lt; \"Push num \" &lt;&lt; num &lt;&lt;\" into bigger\" &lt;&lt; endl; bigger.push(num); } else { cout &lt;&lt; \"Push num \" &lt;&lt; num &lt;&lt;\" into smaller\" &lt;&lt; endl; smaller.push(num); } } //小顶堆&gt;大顶堆 else if(smaller.size() &lt; bigger.size()) { if(bigger.top()&gt;num) { cout &lt;&lt; \"Push bigger's top \" &lt;&lt; bigger.top() &lt;&lt;\" into smaller\" &lt;&lt; endl; smaller.push(bigger.top()); cout &lt;&lt; \"Pop bigger's top'\" &lt;&lt; bigger.top() &lt;&lt;\" from bigger\" &lt;&lt; endl; bigger.pop(); cout &lt;&lt; \"Push num \" &lt;&lt; num &lt;&lt;\" into bigger\" &lt;&lt; endl; bigger.push(num); } else { cout &lt;&lt; \"Push num \" &lt;&lt; num &lt;&lt;\" into smaller\" &lt;&lt; endl; smaller.push(num); } } //大顶堆&gt;小顶堆 else { if(smaller.top() &lt; num) { cout &lt;&lt; \"Push smaller's top \" &lt;&lt; smaller.top() &lt;&lt;\" into bigger\" &lt;&lt; endl; bigger.push(smaller.top()); cout &lt;&lt; \"Pop smaller's top \" &lt;&lt; smaller.top() &lt;&lt;\" from smaller\" &lt;&lt; endl; smaller.pop(); cout &lt;&lt; \"Push num \" &lt;&lt; num &lt;&lt;\" into smaller\" &lt;&lt; endl; smaller.push(num); } else { cout &lt;&lt; \"Push \" &lt;&lt; num &lt;&lt;\" into bigger\" &lt;&lt; endl; bigger.push(num); } } } //该函数返回中位数 double findMedian() { if(smaller.size()==bigger.size()) { return (smaller.top()+bigger.top())/2.0; } else if(smaller.size()&gt;bigger.size()) { return smaller.top(); } else return bigger.top(); }private: //实现两个堆的动态平衡 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; smaller; //小顶堆 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; bigger; //大顶堆};/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */int main(){ vector&lt;int&gt; nums = {1,5,46,4,6,3,34,5,67,34,53,23,22,12,8,67,55,66}; MedianFinder* obj = new MedianFinder(); for(auto i : nums) obj-&gt;addNum(i); double param_2 = obj-&gt;findMedian(); cout &lt;&lt; param_2 &lt;&lt; endl; return 0;} 运行结果 end","link":"/2019/08/29/LeetCode295_Hard/"},{"title":"【数据结构】栈与队列","text":"栈和队列的基本概念 栈的基本概念 栈的定义 只能在一端（栈顶Top）进行插入和删除操作的线性表 栈顶由一个称为栈顶指针的位置指示器top来指示，它是动态变化的 表的另一端栈底是固定不变的 栈的特点 先进先出（ＦＩＬＯ） 栈就如同一个狭窄的死胡同，最先进去的人（元素）只能够最后出来 栈的存储结构 可以用顺序表或者链表来存储栈： a) 顺序栈 b) 链式栈 栈的数学性质 当ｎ个元素以某种顺序进栈，并且可以在任何时候出栈（在满足先进后出的前提下）时，所获得的元素排列的数目Ｎ恰好满足函数 Catalan() 的计算，即：$$ N = { \\dfrac{1} {n+1} }×C\\binom{n} {2n} $$ 队列的基本概念 队列的定义 是一种操作受限的线性表，且只允许在表的一端进行插入，在另一端进行删除操作。 可以插入的一端称为队尾（ｒｅａｒ），可以删除的一端称为队头（ｆｒｏｎｔ） 插入元素称为进队，删除元素称为出队 队列的特点 先进先出（ＦＩＦＯ），就像食堂打饭要排队一样，先来的人先有饭吃 队列的存储结构 可用线性表或者链表来存储队列： a) 顺序队 b) 链队 栈和队列的存储结构、算法与应用 顺序栈的定义 typedef struct SqStack { int data[Maxsize]; //一维数组用来存储数据 int top; // ｔｏｐ指针用来指向栈顶元素,规定top=-1 为栈空，top=Maxsize-1 为栈满} 链栈结点的定义 typedef struct LNode { int data; // 数据域 struct LNode *next; // 指针域}LNode; 顺序队列的定义 typedef struct SqQueue { int data[Maxsize]; //数组存放数据 int front; // 队首指针 int rear; // 队尾指针} 链队的定义a) 链队结点定义： typedef struct LQNode{ int date; //数据域 struct LQNode *next; //指针域 } b) 链队类型定义： // 定义一个只包含两个指针域的结点来存放队头与队尾指针 typedef struct LiQueue{ struct LQNode *front; // 队首指针 struct LQNode *rear; // 队尾指针 } // 链队类型定义 顺序栈 顺序栈的几个关键要素： 三个状态 栈空状态：st.top = -1; 栈满状态：st.top = Maxsize - 1; 非法状态：栈满却继续入栈发生上溢；栈空继续出栈发生下溢； 两个操作 元素进栈：++(st.top); st.data[st.top]=x; 元素出栈：x=st.data[st.top]; –(st.top); 初始化栈：// 初始化一个栈，只需将栈顶指针置为－１即可void initStack(){ int top = -1;} 判断栈空代码：int EmptyStack(SqStack ss){ if (ss.top == -1) return 1; // 栈空返回１； else return 0; // 栈非空返回０；} 进栈代码：#defined Error 0int push(SqStack &amp;ss, int x){ if (ss.top == -1) return Error; // 栈满时返回错误，无法入栈 ss.top++; ss.data[ss.top] = x; // 也可一句话解决： ss.data[++ss.top] = x; return 1; //入栈成功返回１} 出栈代码：int pop(SqStack &amp;ss,int e){ if (ss.top == -1) return Error; // 栈空不能出栈 e = ss.data[ss.top]; --ss.top; // 也可一句话解决： e = ss.data[ss.top--]; return 1;} 【注】:对于自增操作，入++a;总是比a++;的执行效率要高一些，因此在使用二者都可以的情况下优先选择++a; 链栈 以下链栈都由带头结点的链表表示 顺序栈的几个关键要素： 两个状态 栈空状态：lst –&gt; next = NULL; 栈满状态：不存在栈满状态，因为单链表的内存空间是动态分配的 两个操作 元素（由指针ｐ所指）的进栈操作：p -&gt; next = lst -&gt; next; lst -&gt; next = p;//其实 就是头插法建立单链表的操作 出栈操作：s = lst -&gt; next; x = s -&gt; data; lst -&gt; next = s -&gt; next; free(s); //其实就是单链表的删除操作 链栈的初始化代码：// 实际上，链栈的初始化与单链表的初始化并无不同void initLStack(LNode *&amp;lst){ lst = (LNode*)malloc(sizeof(LNode)); //制造一个头结点 lst -&gt; next = NULL; // 将链栈滞空} 判断栈空代码：int isEmpty(LNode lst){ if (lst -&gt; next == NULL) return 1; //栈空返回１； else return 0; // 栈不空返回０；} 进栈代码：int push(LNode &amp;lst,int x){ LNode s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = lst -&gt; next; lst -&gt; next = s; return 1;} 出栈代码：int pop(LNode &amp;lst, int &amp;e){ // 用e返回出栈元素的值 if (lst -&gt; next == NULL) return 0; e = lst -&gt; next -&gt; data; LNode *s = lst -&gt; next; lst -&gt; next = s -&gt; next; free(s); return 1;} 栈的应用 栈的主要应用有： 括号匹配 表达式求值 逆波兰转换算法 括号匹配 算法思想： 扫描整个表达式，判断当前符号是否为括号 如果不是，继续扫描下一个字符 如果是，判断是左括号还是右括号，是左括号将其入栈，是右括号就判断栈是否为空 若栈为空，说明此表达式的右括号多与左夸号 若栈不空则判断当前操作符是否和栈顶操作符匹配，若不匹配说明左右括号不匹配，若匹配则继续判断 下一个操作符。最后，判断栈是否为空，若不空则说明左括号多余右括 号，栈为空说明匹配成功。 initStack(Stack stack){ for (int i ;i&lt;strlen(str);i++){ if (str[i]=='{' || str[i]=='[' || str[i]=='('){ push(stack,str[i]); } else { if (str[i]=='{' &amp;&amp; getTopStack(stack) == '}') pop(stack); if (str[i]=='[' &amp;&amp; getToPStack(stack) == ']') pop(stack); if (str[i]=='(' &amp;&amp; getTopStack(stack) == ')') pop(stack); } } // 最后，若栈空则匹配成功，否则失败 if(isEmpty() == true){ cout &lt;&lt; \"括号匹配成功 ！！！\" &lt;&lt; endl; } else cout &lt;&lt; \"匹配失败 ！！！\" &lt;&lt; endl;} 表达式求值 算法思想： 扫描表达式，当扫描到数时将其推入栈中，当扫描到一个运算符时，将该运算符作用于位于栈顶的两个数上，并将所得结果推入栈中 以下将给出后缀表达式的求值程序 int calcExp(char* exp , Stack s){ int i = 0; while (exp[i] != '\\0'){ // if (exp[i]&gt;='0' &amp;&amp; exp[i]&lt;='9'){ s.push(s , exp[i]-'0'); // 若为数字，推入栈中 } else if(exp[i] == '运算符'){ int m = s.gettop(); // 取栈顶元素后将其出栈 s.pop(); int n = s.gettop(); // 取栈顶元素后将其出栈 s.pop; s.push(s, n[运算符]m); // 将运算结果推入栈中 } i++; // 继续遍历 } return s.top;} 逆波兰转换算法 算法思想： 设立一个栈，存放运算符，初始栈为空，编译程序从左往右扫描中缀表达式，若遇到数字，直接输出，并输出一个空格为两个操作数之间的分隔符； 若遇到运算符，则与栈顶比较，若运算符级别比栈顶级别高则进栈，否则退出栈顶元素并输出，之后输出一个空额作分隔符 所遇到左括号，紧张； 若遇到右括号，则一直退栈粗出知道退出第一个左括号为止 当栈为空时，输出的结果即为后缀表达式 void tranfExp (char* exp , Stack s){ while (exp[i] != '\\0'){ if (exp[i] &gt;= '0' &amp;&amp; exp[i] &lt;= '9'){ // 若为数字，直接输出 } else if (exp[i] == '('){ // 若为左括号，进栈 } else if (exp[i] == ')'){ // 若为右括号，出栈直至第一个左括号 } else if (exp[i] == '运算符'){ // 判断与栈顶元素的优先级大小 if (exp[i] &gt; s.gettop()) s.push(exp[i]); // 优先级大于栈顶运算符，将该运算符进栈 else // 优先级小于栈顶运算符，退出栈顶元素并且输出 while (s.isEmpty() == false) pop();// 把栈中剩余元素全部退出并输出 } }} 顺序队 循环队列 循环队列的基本要素 两个状态： 队空状态：qu.rear = qu.front; 队满状态：(qu.rear+1)%front == qu.front ; 两个操作： 元素x进队操作：qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; 出队操作：qu.front = (qu.front+1)%MaxSize; elem = qu.data[qu.front];//elem 保 存出队的元素 循环队列的基本操作实现 初始化队列算法： void initQueue(Queue &amp;qu){ qu.front = 0; qu.rear = 0; } 判断队空算法： int isQEmpty(Queue qu){ if (qu.front == qu.rear){ return 1; // } return 0; //} 进队算法： int enterQueue(Queue &amp;qu , int x){ if ((qu.rear+1)%MaxSize == front){ cout &lt;&lt; \"队列已满\" &lt;&lt; endl; return 0; } qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x; return 1;} 出队算法： int outQueue(Queue &amp;qu , int e){ if (qu.rear == qu.front){ cout &lt;&lt; \"队空无法出队\" &lt;&lt; endl; return 0; } qu.front = (qu.front+1)%MaxSize; e = qu.data[qu.front]; return 1;} 链队采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限 链队的基本要素 两个状态： 队满状态： 不存在队满状态 队空状态：que.rear = NULL || que.front = NULL (两个满足一个即可) 两个操作： 元素q进队操作： 分两种情况1. 当前队为空：que --&gt; rear = que --&gt; front = q; 2. 当前队不空：que --&gt; rear --&gt; next = p;que --&gt; rear = p; 元素出队操作： s = que –&gt; front; que –&gt; front = s –&gt; next;elem = s –&gt; data; free(s); 链队的基本操作实现1.初始化链队算法：void initLiQueue(LiQueue *&amp;que){ que = (LiQueue*)malloc(sizeof(LiQueue)); que -&gt; rear = NULL; que -&gt; front = NULL; } 2.判断队空算法：int isEmpty(LiQueue que){ if (que.rear = NULL || que.front = NULL){ cout &lt;&lt; \"队列为空\" &lt;&lt; endl; return 1; } return 0;} 3.入队算法：int enterLiQueue(LiQueue &amp;que ， int x){ LQNode* s = (LQNode*)malloc(sizeof(LQNode)); if (isEmpty(que)){ // 若队列为空，进队操作比较特别 que -&gt; front = que -&gt; rear = s; return 1; } else{ que -&gt; rear -&gt; next = s; que -&gt; rear = s; return 1; } return 0;} 4.出队算法：int outLiQueue(LiQueue &amp;que , int &amp;elem){ LQNode* s = que -&gt; front; if (isEmpty()){ cout &lt;&lt; \"队为空，无法出队\" &lt;&lt; endl; return 0; } if (que -&gt; front == que -&gt; rear){ // 若队列只有一个元素，出队操作比较特别 que -&gt; front = NULL; que -&gt; rear = NULL; } que -&gt; front = s -&gt; next; elem = s -&gt; data; free(s); return 1;}","link":"/2019/03/10/QueueStack/"},{"title":"【数据结构】 字符串","text":"串的定义 // 通常用一个字符数组来表示char str[] = \"hello\";// 数组str内存储的字符为{'h','e','l','l','o','\\0'} ,故有6个数组元素，其中'\\0'是串的结束标志，告知编译器串结束了。// 但是串str的长度为5，“hello”， 【注】以上定义方式一般不用，因为用该方式单纯以 ‘\\0’ 结尾的串如果要得到字符串的长度较为麻烦（需要遍历整个串，时间复杂度为O(n)，故一般情况下我们用自己定义的结构体来定义串，下面会谈到。 【注】空格也是串中的元素，由一个或多个空格组成的串称为空格串，空格串不是“空串”。 串的逻辑结构与线性表类似，串是限定了元素为字符的线性表。但从操作对象上来说，串与线性表有着很大的不同：线性表的主要操作对象是单个元素，而串的主要操作对象是该串的一个“子串”。 串的存储结构 1. 定长顺序存储表示：typedef struct Str{ char str[maxsize+1]; // 用来存放字串的字符数组，maxsize 为字符串最大长度，maxsize+1为数组最大长度，+1 用于存储 '\\0'. int length; // 字符串长度，可用Str.length方法直接访问 length &lt;= maxsize;} 2. 动态分配存储表示：typedef struct LStr{ char *ch; // 指向malloc();动态分配存储区的首地址的指针 int length; // 字符串长度} 串的基本操作 1. 赋值操作：int strassign(LStr&amp; str,char* ch){ // 需返回的变量带引用符号&amp; if (str.ch){ free(str.ch); // 释放原有空间 } int len = 0; char *c = ch; while(c){ // 计算ch的长度 ++len; ++c; } if (len == 0 ){ str.ch = NULL; // 如果ch为空，则直接返回一个空的串 str.len = 0; return 1; } else { str.ch = (char*)malloc(sizeof(char)*(str.len+1)); // 用malloc函数分配一块连续的存储空间，str.len+1是为了容纳'\\0' if (str.ch == NULL) { return 0; //分配失败 } else { c = ch; for (int i = 0; i &lt;= len;i++){ //遍历并赋值 str.ch[i] = *c; // *c 表示c指针所指的位置的值 ++c; // c指针指向下一个位置 } str.len = len; // 被赋值的串长度等于ch的串长 } } return 1; // successfully} 2. 取串长度操作：int StrLength(LStr str){ // 有给串长度信息的情况： return str.len; // 返回str串的长度 //在没有给出串长度信息的情况下： int len = 0; char = *c; c = str.ch; while(c){ ++len; ++c; } return len;} 串的比较操作：int strCompare(LStr str1,LStr str2){ //啰嗦版: for (int i = 0;i &lt; str1.len &amp;&amp; i &lt; str2.len){ if(str1.ch[i] - str2.ch[i] == 0) i++; else if(str1.ch[i] - str2.ch[i] &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else { cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } } if (str1.len - str2.len &gt; 0){ cout &lt;&lt; \"str1 &gt; str2\" &lt;&lt; endl; } else if (str1.len - str2.len &lt; 0){ cout &lt;&lt; \"str1 &lt; str2\" &lt;&lt; endl; } else cout &lt;&lt; \"str1 = str2\" &lt;&lt; endl; return 1; // 简洁版： for (int i = 0; i &lt; str1.len &amp;&amp; i &lt; str2.len ;i++){ if (str1.ch[i] != str2.ch[i]){ return str1.ch[i] - str2.ch[i]; } return str1.len - str2.len; }} 4. 串的连接操作：int concat(LStr &amp;str,LStr str1,LStr str2){ // 将两个字符串连接并用一个新的字符串str返回 if(str.ch) { // 清除原有空间 free(str.ch); str.ch = NULL; str.len = 0; } str.ch = (char*)malloc(sizeof(char)*(str1.len+str2.len+1)); // 分配连续空间，+1是为了多分配一个位置空间存放‘\\0’ int i = 0; while(i &lt; str1.len){ // 插入str1; str.ch[i] = str1.ch[i]; ++i; } int j = 0; while(j &lt;= str2.len){ // 插入str2，注意这里用\"&lt;=\"是为了吧'\\0' 也加到末尾 str.ch[i+j] = str2.ch[j]; ++j; } str.len = str1.len + str2.len; // 更新字符串长度 return 1; // 成功连接} 5. 求子串操作：int subStr(LStr &amp;substr,LStr str,int pos,int len){ if (pos + len &gt; str.len || pos &lt; 0 || len &lt; 0 || pos &gt;= str.len){ return 0; //判断输入是否合法 } if (substr.ch){ // 清空原空间 free(substr.ch); substr.ch = NULL; } if (len == 0){ // 若子串长度为0.直接返回空子串 substr.ch = NULL; substr.len = 0; return 1; } else{ substr.ch = (char*)malloc(sizeof(char)*(len+1)); // 分配连续的内存空间 int i = 0; int j = pos; while(i&lt;len){ // 从pos处开始遍历并赋值给子串 substr.ch[i] = str.ch[j]; ++i; ++j; } substr.ch[i] = '\\0'; // 这个千万别忘了加进去 substr.len = len; // 更新子串长度 return 1; // 成功 }} 串的清空操作：// 串的清空操作在上诉各函数中均有用到int clearStr(LStr &amp;str){ if (str.ch){ free(str.ch); str.ch = NULL; } str.len = 0; return 1;} 串的模式匹配算法(重点)何为模式匹配： 对一个串中某子串的定位操作称为串的模式匹配，其中待匹配的子串称为“模式串”。串的模式匹配算法分为： 简单模式匹配算法 KMP算法 1. 简单模式匹配算法： 算法思想： 从主串的第一个位置起开始遍历字符串，若该字符与模式串的第一个字符相同，则继逐一比较后续字符， 否则从主串的下一个位置开始，重复上一步操作，以此类推，直到比较完模式串的所有字符。若匹配成 功，返回模式串在主串中的位置。匹配失败 ……,随便你想咋样。int subStr_Match(Lstr str,LStr substr){ if (substr.ch == NULL || str.ch == NULL){ return 0; } int i ,j , pos = 0; for (i = 0 , j = 0;i &lt; str.len &amp;&amp; i &lt; substr.len; ){ if (str.ch[i] == substr.ch[j]){ ++j; ++i; } else { j = 0; // 匹配失败，j 重新指向模式串起始位置 i = ++pos; // pos 记录上一次匹配的起始位置，在匹配失败后将i指向上一轮匹配的初始位置pos的后面一个位置++pos开始新一轮匹配 } } if (j &gt;= substr.len){ return pos; // 匹配成功，返回模式串在主串中的位置 } return 0;} KMP算法： 算法思想解析 : 上述的匹配算法称为“简单模式匹配算法（BF）”，其时间复杂度为O(mn),其中m为主串长度，n为模式串长度。由此可知简单模式匹配算法虽然易于理解但是效率很低，无法满足当已知数据异常庞大时的效率要求。所以就诞生了接下来登场的KMP算法。 我们知道，在BF算法中每次发生不匹配i与j都要回溯到该轮匹配的初始位置，并且在回溯之后的后几次匹配同样有可能导致（不必要的）不匹配状态，这是导致算法效率低下的主要原因，那么如何直接跳过这些不必要的不匹配状态而直接到达可能解决不匹配位置的的状态呢？ 解决办法就是利用匹配失败后的信息，那么如何利用呢？ 为了使问题变得更加直观，我们假想匹配过程就是模式串在主串上的移动(实际上并不会移动，全是指针在变化)，如果在某一次匹配时在模式串的第j位置发生了不匹配（j位置前的所有元素都已匹配成功），如果照着BF算法来做，我们会抛弃掉j位置前的匹配“成果”直接将i与j回溯重新开始下一轮比较。但现在我们不这么做，因为我们完全可以将j之前的匹配成果利用起来 不不妨假设模式串为“ABABABB”，并且该模式串在与主串的一次匹配流程中第4个元素B与主串发生了不匹配，很显然这个时候主串i位置前的三个元素跟模式串是完全匹配的，为了利用这个成果，就是在模式串向后移动后尽可能地保留这些匹配成果，我们观察这三个元素“ABA”的特点，发现他的前缀与后缀出现了相同的字符序列“A”，这时候我们应该意识到，要时上一次的成果得到最大限度的保留，我们只能将模式串移动到前缀与后缀重合的状态，这样子就保留了一个匹配成果“A“，同时i根本就不需要回溯（原地不动就好），因为i无需从模式串头部重新开始与其匹配，而只需从保留的成果后开始匹配也就是模式串的第二个位置（A的后一个位置）开始匹配。 但问题又来了，怎么知道模式串该怎么移动呢，从上面的分析我们发现，对于模式串移动的分析完全没有涉及到主串，那我们是怎么做到视主串而不见的呢(它可是”主“串啊给点面子好不好)。事实上，我们用到他了，因为我们的假设是”j位置前的元素与主串完全匹配“，竟然这样那么不就说明j位置前的模式串部分与主串的那一部分完全一样吗，所以我们可以用一个所谓”假模式串“来代替主串，而模式串只要在这个”傀儡身上移动就好了。所以，模式串在哪个位置与主串发生不匹配后模式串应该怎么移动，这个问题就可以脱离主串而背单独拿出来分析了，这就是后面要谈到的next数组（用与存放当j位置发生不匹配时，j指针应该重新调整到那个位置上）。有了next数组，我们就可以知道当模式串在J处与主串发生不匹配之后，为了最大限度地保留之前的匹配成果，模式串该怎么移动（指针该怎么变化）。 KMP算法代码：int KMP (LStr str,LStr substr,int next[]){ // 函数接受主串，模式串，next数组 int i = 1 ,j = 1; // i 扫描主串，j 扫描模式串 for (i &lt; str.len &amp;&amp; i &lt; substr.len){ if (j == 0 || str.ch[i] == substr.ch[j]){ // j=0;的情况就是模式串中的第一个字符与主串中的第i个字符不匹配，应从// 主串的下一个位置与模式串的第一个位置继续比较，故++i(主串的下一个位置);// ++j(模式串第一个位置0+1=1(很强)) ++j; ++i; } else { j = next[j]; // j 被调整到合适位置，这里的i不需要回朔，这也是KMP算法的一大特点 } } if (j &gt;= substr.len){ // j 的长度超过了模式串，显然匹配成功 return i - substr.len; // 匹配成功，返回模式串在主串中的位置 } return 0;} next数组的求法: 经过前面的分析我们知道，只需要模式串本身我们就可以求出next数组，并不需要主串的参与。所以我们可以定义一个函数将next数组一次性求出，从此一劳永逸…… 这里我们要用到一个算法思想，那就是递推,我们知道数列就是一种有着递推关系的数的序列。现在假设等差数列{An},给你一个递推公式(实际上就是前一个元素与后一个元素的关系)：A(n+1) = An + 1;其中n={1,2,3,…}然后告诉你第一个元素A1 = 0(实际上告诉你任何一个位置上的元素值都可以); 有了这两个已知条件你可以知道这个数列的所有元素就是非负整数集{0,1,2,3, …}。 那我们如何在求解next数组上面应用这个思想呢？ 首先看看我们有什么已知条件？ 显然我们需要知道两个相邻状态Sk与Sk+1之间的关系，假设模式串为p1～pm，问题转化为两个模式串之间的匹配问题。如果在Sk时，已经求得了next[j] = t；若要求得Sk+1状态的next[j+1]，我们需要分两种状态来考虑： 若Pj = Pt；则next[j+1] = t+1; 若Pj != pt;这时候就又回到了我们讨论模式串与主串匹配出现匹配失败的经典情形了，不匹配发生在t处，我们应该去查next数组看看t应该怎样调整位置了，显然next[t]我们已经求得了，所以令t = next[t],继续比较pj与pt，若不相等重复第二种情况，直到t = 0;或者pj = pt 满足第一种情况，从而求得next[j+i]; next求数组代码:void getNext(LStr substr,int next[]){ int j = 1; int t = 0; int next[1] = 0; // 特殊情况，模式串的第一个位置发生不匹配 while(i &lt; substr.len){ if(t==0 || substr.ch[t] == substr.ch[j]){ // t=0;是因为next数组中可能有0元素,也说明没有重合的前后缀 next[j+1] = t+1; ++j; ++t; } else{ t = next[t]; } }} KMP 算法的改进 KMP算法就还有什么地方需要改进的？ 为了回答这个问题我们先来看一种特殊情况：模式串为（A A A A A B）,该模式串所对应的next数组为{0,1,2,3,4,5}。可以遇见的是当在模式串第j=5个位置A处发生不匹配时，next数组指导j指向4；而4处的元素依然不匹配（因为4处元素与5处相等），j来到了3（同样不匹配），紧接着来到了2（不匹配），来到1（依然不匹配），最后j=0(++i,++j)到此才结束了之前陷入的“尴尬”局面。 由上分析我们不难想到，如何才能让j直接跳到0；而免去从1-4的多余的比较呢？这就是KMP算法需要改进的地方 也就是说，对KMP算法的改进主要就是对求next数组的方法的改进，于是就有了改进版的next数组，我们称之为 nextval 数组 getNextval() 算法核心思想： 通过上面那个特殊情况，我们知道当j处发生不匹配时，若next数组指导的下一个位置的值与j处的值是相等的，那么显然这次比较就是多余的（因为显然还是会不匹配），所以我们应该跳过next数组所指向的那个位置，换一种思路就是我们应该让next[j] 所指向的位置与Pj不相等，就是改变next[j] 的值；改变后的next数组就是nextval数组. 求解nextval数组的一般步骤： 当j等于1时，nextval[j]赋值为 0 ，作为特殊标记； 当j大于1 时： 若Pj不等于P(next[j]),则nextval[j] 等于 next[j]; 若Pj等于P(next[j]),则nextval[j] 等于 nextval[next[j]]; void getNextval(LStr substr,int nextval[]){ int j = 1; int t = 0; nextval[1] = 0; while(i&lt;substr.len){ if (j == 0 || substr.sh[j] == substr.ch[t]){ if(substr.ch[j+i] != substr.ch[t+1]) nextval[j+1] = t+1; else nextval[j+1] = nextval[t+1]; ++j; ++t; } else t = nextval[t]; }}","link":"/2019/03/11/String/"},{"title":"Tarjan算法求图的强连通分量","text":"强连通分量简介&emsp;&emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 &emsp;&emsp;比如下图： Tarjan 算法&emsp;Tarjan算法是用来求强连通分量的，它是一种基于DFS（深度优先搜索）的算法，每个强连通分量为搜索树中的一棵子树。并且运用了数据结构栈。由于栈的先进先出的性质可以保证当前在栈中的结点中先入栈的结点必然有一条通路通往后入栈的结点，这样一来判断后入栈的结点是否有一条路径通向先入栈结点就成了算法要解决的主要问题。算法思路：&emsp;首先引入两个数组 dfn[maxn] 和 low[maxn], 其中 dfn[i] 表示编号为 i 的节点被访问时的时间戳；low[i] 表示从编号为 i 的节点可追溯到（到达）的最早被访问到的节点的时间戳。下面通过上述例子跑一遍算法，描绘出每个时刻的DFS树状态和栈中的内容。 &emsp;由上述过程可得该图由三个连通分量：{5}，{4}，{2,3,1,0} 算法实现： 代码中有详细注释，可结合上述图例分析 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;/* 求强连通分量： Tarjan算法 Tarjan 算法， 以Robert Tarjan的名字命名的算法 该算法用来在线性时间内求解图的连通性问题*/class Ssc{public: void Tarjan(int); Ssc(int n_, vector&lt;vector&lt;int&gt;&gt; &amp;g) : n(n_) { // InitializeMG graph = g; dfn = vector&lt;int&gt;(n,0); low = vector&lt;int&gt;(n,0); scc = vector&lt;bool&gt;(n,false); time = 0; sscnum = 0; } vector&lt;vector&lt;int&gt;&gt; Sscs; // 所有连通分量 vector&lt;vector&lt;int&gt;&gt; graph; // 有向图的邻接矩阵 int n; // 顶点总数 vector&lt;int&gt; dfn; // 时间戳数组 vector&lt;int&gt; low; // 最小时间戳数组（能够追溯到的最早栈中节点时间戳） vector&lt;bool&gt; scc; // 在栈内标记数组 int time, // 时间 sscnum; // 连通分量数 stack&lt;int&gt; stk; // 遍历栈};void Ssc::Tarjan(int root){ if( dfn[root] ) return; // 访问过了，直接返回 dfn[root] = low[root] = ++time; stk.push(root); // 入栈 scc[root] = true; for(int v = 0;v &lt; n;v++) // 遍历 root 所指节点 { if(!dfn[v] &amp;&amp; graph[root][v]) // v 还未被访问过 { Tarjan(v); low[root] = min(low[root], low[v]); } else if(scc[v] &amp;&amp; graph[root][v]) // 如果 v 还在栈内 { low[root] = min(low[root], dfn[v]); } } if(low[root] == dfn[root]) // 后代不能找到更浅的节点了 { sscnum ++; // 记数 vector&lt;int&gt; sc; // 保存当前连通分量 while(true) // 依次退栈至 root { int x = stk.top(); scc[x] = false; stk.pop(); sc.push_back(x); if(x == root) break; } Sscs.push_back(sc); }}int main(){ vector&lt;vector&lt;int&gt;&gt; graph = { {0,1,1,0,0,0}, {0,0,0,1,0,0}, {0,0,0,1,1,0}, {1,0,0,0,0,1}, {0,0,0,0,0,1}, {0,0,0,0,0,0}, }; Ssc S(6, graph); S.Tarjan(0); int index = 1; for(auto i : S.Sscs) { cout &lt;&lt; \"SSC (\" &lt;&lt; index++ &lt;&lt; \") : \"; for(auto j : i) { cout &lt;&lt; j &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; \"The Number of SSC : \" &lt;&lt; S.sscnum &lt;&lt; endl; return 0;} 运行结果","link":"/2019/11/21/Tarjan算法求图的强连通分量/"},{"title":"【数据结构】数组、矩阵、和广义表","text":"数组： 常见的数组有一维数组和二维数组，二维数组是元素可以看成是一维数组的一维数组。对于数组主要考察元素下标计算的问题。对于一维数组较为简单，而对于二维数组的元素位置计算较为复杂，要考虑行优先和列优先两种情况。 二维数组的行优先和列优先存储： 行优先：从起始行开始一行一行地存入连续空间中 列优先：从起始列开始一列一列地存入连续空间中 矩阵的压缩存储： 矩阵的定义 矩阵一般用一个二维数组A[m][n]表示，表示一个m行n列的矩阵 其中m n 必须为常量，或者为预先定义的宏常量，如下：#define m 5#define n 6int A[m][n]; 矩阵的一般操作与实现 矩阵的转置： void transpose(int A[][maxsize],int B[][maxsize],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n ; ++j){ B[j][i] = A[i][j]; // 矩阵转置操作，元素关于主对角线互换位置 } }} 矩阵相加: void addition(int A[][max],int B[][max],int C[][max],int m,int n){ for(int i = 0; i &lt; m ; ++i){ for(int j = 0; j &lt; n){ c[i][j] = A[i][j] + B[i][j]; //对应位置元素相加 } }} 矩阵相乘： void Multiply(int A[m][n],int B[n][k],int C[m][k],int m,int n,int k){ for(int i = 0;i&lt;m;++i){ for (int j = 0;j&lt;k;++j){ C[i][j] = 0; for(int h = 0;h&lt;n;++h){ C[i][j] += A[i][h] * B[h][j]; } } }} 特殊矩阵和稀疏矩阵 矩阵中绝大多数元素都是0的矩阵称为稀疏矩阵(国外教材) 相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵(严版) 特殊矩阵：a) 对称矩阵 矩阵中的元素满足A[i][j] = A[j][i] 的矩阵称为对称矩阵 如上图所示，只需要存储一半的元素就可以了，要还原出另一半只需根据A[i][j] = A[j][i]这个条件就行了。 将一个n×n的对称矩阵存储在一维数组中，所需的存储空间为 $ \\dfrac{(1+n)·n}{2}$ 需要保存的元素为： 按照行优先来存储，保存在一维数组中，如下图所示：b)三角阵 上三角矩阵 为矩阵下三角部分(不包括对角线)元素全为零 下三角矩阵 为矩阵上三角部分(不包括对角线)元素全为零 三角矩阵的存储方式与对称矩阵类似，以下三角矩阵的存储为例，只需存储对角线及其以下部分的元素和其上三角中的一个元素C即可，如下图： c)对角矩阵 如下图所示的对角矩阵，其特点为除了主对角线以及其上下两条带状区域的元素外，其余元素都为C ( C可以为0)： 下面介绍如何求出第i行带状区域内的第一个元素在一维数组中的下标，假设c存在数组的最后一位： 当i=1时，带状区域内的第一个元素为矩阵当中的第一个元素，其在一维数组中的下标为0； 当i&gt;1时，第i行之前的元素个数为 $2+(i-2)×3$，则带状区域的第一个元素在一维数组中的下标为 $2+(i-2)×3$2.稀疏矩阵 稀疏矩阵中的相同元素c不像特殊矩阵中的相同元素的位置分布那么有规律可循，故必须为其设计一些特殊的存储结构 稀疏矩阵的顺序存储及其相关操作：常用的稀疏矩阵顺序存储方法有三元组表示法，和伪地址表示法。 三元组表示法：三元组数据结构为一个长度为n，表内每个元素都有三个分量的线性表，其三个分量分别为：“值”、“行下标”、“列下标”。元素结构体定义如下：typedef struct Trimat{ int val; // 值 int i; // 行下标 int j; // 列下标}； 结构体示意图：结构题数组的定义：Trimat trimat[maxterms + 1]; // maxterms + 1;因为从第 1 行才开始存储元素 但是，为了方便起见，一般不用上诉结构体来定义三元组，直接申请一个二维数组就可以了：int trimat[maxterms + 1][3];// 如要求其他类型，可将int替换掉// 需要注意的是，如果矩阵是float型的（或者其他非整型的数据类型）// 则此时用一个数组来表示三元组应该写成如下形式：float trimat[maxterms + 1][3];// 这个时候若要取当前非零元素的所在位置应该这么做： (int)trimat[k][1]; (int)trimat[k][2];// 就是将float 型的元素造型成int型，这样就可以避免很多不必要的问题的发生 上诉定义方式中：trimat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值trimat[k][1]、trimat[k][2]表示第k个非零元素在矩阵中的位置。事实上，trimat此时就是一个maxterms 行 3 列的二维数组，我们规定第0行的三个元素分别用来存储原矩阵中的非零元素个数，以及矩阵的行数与列数。示意图如下： 给定一个二维数组存储的矩阵，要求设计算法将其转化为三元组存储： 算法分析：建立一个三元组的核心问题在于求矩阵的非零元素个数以及非零元素的值，还有其在矩阵（原数组）中的位置，故只需扫描所给矩阵的二维数组即可得到相关数据，进而建立三元组。 // 建立三元组时，结点间的次序行按元素在矩阵中的行优先顺序排列void creattrimat(float A[][max],int m,int n,float B[][3]){// m,n 表示所给矩阵的规模为m×n int k = 1; for (int i = 0;i&lt;m;++i){ for (int j =0;j&lt;n;++j){ // 双重循环扫描矩阵 if (A[i][j] != 0){ // 若矩阵的[i][j] 上的元素不为零，将该元素连同其位置信息存入三元组中 B[k][0] = A[i][j]; B[k][1] = i; B[k][2] = j; k++; // k 指向三元组的下一个空间 } } } B[0][0] = k-1; // 将矩阵的基本信息存入三元组的第0行 B[0][1] = m; B[0][2] = n;} 设计算法打印出所给三元组存储的矩阵： 算法分析：读取三元组的第0行，得到矩阵的相关信息循环按行打印，若下标与三元组中的非零元素下标信息匹配则打印该非零元素，否则，打印0；void print(float trimat[][3]){ int m = trimat[0][1]; int n = trimat[0][2]; int k = 1; // 非零元素从第一行开始存储 for(int i = 0;i&lt;m;i++){ // 双重循环打印矩阵 for(int j = 0;j&lt;n;j++){ // 循环过程中检查第[i][j]下标是否与三元组中的非零元素相同，若相同打印该非零元素，若不同打印 0 ； if(i = (int)trimat[k][1] &amp;&amp; j == (int)trimat[k][2]){ cout &lt;&lt; trimat[k][0] &lt;&lt; \" \"; ++k; } else cout &lt;&lt; \"0 \" &lt;&lt; endl; } }} 伪地址表示法：伪地址表示法与三元组表示法在本质上并无差别，只不过是三元组表示法的每一行用两个存储单元来存放原矩阵非零元素的位置标记，而伪地址表示法可以只用一个存储单元来存放位置标记，原因是因为对于一个$ m·n $的矩阵，伪地址表示法将元素位置下标的两个整数用一个公式映射( $ n·(i-1) +j $)到了一个整数上，同样利用该公式也可还原原i和j的值。我们来看一个例子： 稀疏矩阵的链式存储及相关操作： 邻接表表示法：邻接表表示法将矩阵中每一行的非零元素串联成一个单链表，链表结点中有三个分量：元素值、所在列、指针域结点的定义如下：typedef struct Listmat{ int data; int col; struct Listmat *next;}; 示意图如下：上图中最左端为一个指针数组，用来存储指向每一行非零元素单链表的头指针，数组下标为表示行标号。 十字链表表示法：在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点有 5 个分量：行分量、列分量、数据域、指向下方结点的指针域、指向右方结点的指针域；结构图如下：普通结点定义：typedef struct matNode{ int row; int col; int data; struct matNode *down; struct matNode *right;}; 头结点定义:typedef struct CrossList{ struct matNode *rhead,*cheard; // 指向两头结点数组的指针 int m,n,k; // 矩阵行数、列数、非零结点总数} 由于十字链表存储结构比较复杂，我们将通过其结构图例来深入了解它，图中附有详细的注释： 上图中，银灰色的结点为行头结点数组与列头结点数组，他们的定义如下：// 其中的m n 为矩阵的行数和列数typedef struct Rhead{ // 行头结点数组 struct matNode Rhead[m]; // 元素为matNode结点的数组};typedef struct Chead{ // 列头结点数组 struct matNode Chead[n];} 在理解了十字链表存储结构后，我们来看一个实际的应用：给定一个float型二维数组存储的稀疏矩阵，建立其对应的十字链表结构。算法分析：首先应该建立整体框架，也就是十字链表头结点以及行、列头结点数组。然后，按行优先顺序遍历矩阵数组，若发现不为零的元素，分配一个结点空间将其值存入，调整行、列头结点的指针域指向该结点，如此直到结束遍历int creatCrossListmat(float A[][maxsize],int m,int n,int k,CrossList &amp;M){ //============================================ // 搭建基本框架操作 //============================================ // 清空处理： if (M.rhead) free(M.rhead); if (M.chead) free(M.chead); // 将矩阵信息存入十字链表头结点： M.m = m; M.n = n; M.k = k; // 申请行、列头结点数组空间： if (!(M.rhead = (matNode*)malloc(sizeof(matNode)*m))) return 0; if (!(M.chead = (matNode*)malloc(sizeof(matNode)*n))) return 0; // 将行、列头结点数组的right和down指针置空： for(int i = 0;i &lt; m ; ++i){ M.rhead[i].right = NULL; M.rhead[i].down = NULL; } for(int i = 0;i &lt; n ;++i){ M.chead[i].right = NULL; M.chead[i].down = NULL; } //=================================================== // 核心算法 //=================================================== // 建立链表的辅助指向列头结点的指针数组： matNode *temp_r[maxsize]; for(int i = 0;i&lt;n;++i){ temp_r[i] = &amp;(M.chead[i]); // 引用 } // 行优先顺序遍历矩阵数组构建十字链表： for(int i = 0;i &lt; m ;++i){ matNode *c = &amp;(M.rhead[i]); for(int j = 0;j &lt; n;++j){ if (A[i][j] != 0){ matNode *p = (matNode*)malloc(sizeof(matNode)); p -&gt; row = i; p -&gt; col = j; p -&gt; val = A[i][j]; p -&gt; down = NULL; p -&gt; right = NULL; // 如果某行（列）中已经连接了元素，那么就让这个元素充当该行（列）的头部，这样能使十字链表的行（列）头结点数组中的结点避免重复指向，覆盖；所以下面的代码所要做的事情很重要。 c -&gt; right = p; c = p; temp_r[j] -&gt; down = p; temp_r[j] = p; } } } return 1;} 广义表 表元素可以是原子类型的元素，也可以是广义表的一种线性表 三个重要概念： 广义表的长度：表中最上层元素的个数 广义表的深度：表中括号的最大层数，求解时应将所有的子表展开在分析 表头(Head)和表尾(Tail)：当表非空时，第一个元素为广义表的表头，其余元素组成广义表的表尾两种存储结构： 头尾链表存储结构：这种存储结构有两种结点，即原子结点和广义表结点。原子结点有两个域：标记域、数据域。广义表结点有三个域：标记域、头指针域、尾指针域其中头指针指向一个原子结点或广义表结点，尾指针为空或者指向 本层中 的下一个广义表结点，而标记域用来区分广义表结点(1)与原子结点(0);示意图入下： 扩展线性表结构：该种存储结构同样有两种结点，与头尾链表存储结构不同的是这里的原子结点有三个域：标记域、数据域、尾指针域。示意图如下：","link":"/2019/03/01/arrayandlist/"},{"title":"Hello Friend","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2019/02/01/hello-world/"},{"title":"【数据结构】线性表","text":"线性表的基本概念与实现 1. 线性表的定义: 线性表是具有相同特性数据元素的一个有限序列，重点在“有限序列”。线性表可以是有序的，也可以是无序的。2. 线性表的逻辑特性: 除了表头和表尾的数据元素“结点”，所有元素都有一个直接前驱与一个直接后继。表头无前驱，表尾无后继。 线性表的存储结构： * 顺序存储结构：（顺序表） 1. 存储空间连续（空间为*一次性*分配的） 2. 可以随机存取，也可以顺序存取 3. 插入删除时平均需要移动近一半的元素，时间复杂度为:__O((n-1)/2)=O(n)__ 4. 存储密度为１ * 链式存储结构：（链表） 1. 存储空间可以不连续（存储空间是*动态*分配的） 2. 每一个结点不仅包含数据还包含指向下一个结点的指针 3. 只能够进行顺序存储 4. 存储密度&lt;1 5. 插入删除时不需要移动元素，只需修改*指针*即可,时间复杂度为:__O(1)__ 线性表的定义与实现：a) 顺序表的定义： 结构体定义：#defined MaxSize 100typedef sturct Sqlist { int data[MaxSize]; //线性表最多能容纳的元素个数，即分配的空间大小 int length ; //元素的个数}Sqlist; 用的最多的简单定义：int A[MaxSize]; //直接利用数组就是顺序表的一种这一特性int length; b) 单链表的结点定义：typedef struct LNode { int data; //数据域 struct LNode *next; //指针域}LNode; c) 双链表结点定义： typedef struct DLNOde { int data; //数据域 struct DLNOde *prior; // 指向前驱结点的指针 struct DLNode *next; // 指向后继结点的指针} 【注】 为结点分配存储空间：LNode *A = (LNOde*)malloc(sizeof(LNode));//malloc 函数返回一个空间的地址，让指针Ａ来指向它 线性表的相关操作 查找操作： int findElem (Sqlist a, int x){ for (int i = 0;i&lt;l.length;++i){ if (a[i]==x){ return i; //找到了，返回所在的下标 } } return 0; // 没找到，返回０} 插入操作： int insertElem(Sqlist &amp;L,int i ,int x){ if (i&lt;0 || i &gt; L.length){ return -1; //如果插入位置不合法，返回－１ } if (L.length == MaxSize){ int newL[L.length+MaxSize] for (int j=0;j&lt;L.length;++j){ newL[j] = L[j]; //如果发现顺序表已经满了，就构造一个更大的顺序表并把原顺序表的元素放进去 } L = newL; } for (int k = L.length-1; k&gt;=i; --k){ L[k+1] = L[k]; //从某位开始将插入位置至末尾的元素向后移动一个位置 } L[i] = x; // 插入ｘ到ｉ处 L.length++; // 插入后该表表的长度} 删除操作： // 通过索引下标删除元素，并返回所删元素的值int deleteElem_by_index (Sqlist &amp;L,int i){ int q = L[i]; // 保留ｉ位置的元素 for (int j = i+1;j&lt;L.length;++j){ L[j-1] = L[j]; // 从待删除元素的右边开始每个元素向左移动一个位置，覆盖掉ｉ位置的元素 } L.length--; // 顺序表长度减一，完成删除操作 return q; // 返回被删除元素的值}// 通过值来删除元素，并返回所删元素的下标int deleteElem_by_value (Sqlist &amp;L, int e){ int index = findElem(L,e); //利用findELem() 函数找到要删除元素的下标 int value = L[index]; deliteElem_by_index (L,index); // 用下标索引法删除元素 return value;} 初始化顺序表： void initList (Sqlist &amp;L){ L.length = 0;} 求指定位置元素： int getElem (Sqlist L , int index){ if (index &lt; 0 || index &gt; L.length-1) return Error; rerurn L[index];} 单链表的相关操作 以下所有的算法用的都是带头结点的单链表 尾插法建立单链表： // 给定数组ａ[] 为数据源，建立单链表void creatListR(LNode *&amp;C , int a[], int length){ LNode *s,*r; //用ｓ指向新建的结点，ｒ始终指向链表的尾部结点 C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 r = C; // r 指向头结点，也就是空链表的头结点 for (int i = 0 ; i&lt;length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); // 用malloc函数循环分配结点空间 s -&gt; next = NULL; s -&gt; data = a[i]; // 尾插法的核心算法： r -&gt; next = s; r = r -&gt; next; //r 指向当前尾结点 } // r -&gt; next == NULL;} 头插法建立单链表： void creatListH(LNode *&amp;C ,int a[] ,int length){ LNode *s; C = (LNode*)malloc(sizeof(LNode)); // 建立链表头结点 C -&gt; next = NULL; // 将链表滞空 for (int i = 0 ; i &lt; length ; ++i){ s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = a[i]; // 头插法的核心算法： s -&gt; next = C --&gt; next; C -&gt; next = s; }} 删除结点： // 按值索引删除链表结点void deleteNode(LNode &amp;L , int elem){ LNode *p,*q; p = L; if (L -&gt; next == NULL) return 0; //如果链表为空，返回０； while (p -&gt; next != NULL){ // 循环遍历链表结点 if (p -&gt; next -&gt; data == elem){ // 如果ｐ指向的结点的下一个结点的数据域与带删除数据相等，删除该下一个结点，释放空间 // 删除操作的核心算法： q = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; free(q); // 释放内存 break; //删除成功，退出循环 } p = p -&gt; next; //该节点不是待删除结点，令ｐ指向下一个结点 }} 插入结点： // 在链表的指定元素前插入结点void insertNode(LNode &amp;L , int we,int e){ LNode *r; r = L; LNode *s = (LNode*)malloc(sizeof(LNode)); q -&gt; data = we; q -&gt; next = NULL; while (r -&gt; next != NULL ){ if (r -&gt; next -&gt; data == e){ //插入操作的核心算法： s -&gt; next = r -&gt; next; r -&gt; next = s; } r = r -&gt; next; }} 双链表的相关操作 尾插法建立双链表： // 给定数据源数组，建立双链表void creatDListR (DLNode ＆L , int a[], int length){ DLNode *s,*r; //用ｒ始终指向链表末尾结点，ｓ接受新分配的结点 L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; r = L; //r 指向头结点 for (int i = 0; i&lt; length;++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; // 尾插发的关键步骤： s -&gt; prior = r; r -&gt; next = s; r = r -&gt; next; // r = s; 令ｒ 指向下一个结点 r -&gt; next = NULL; //滞空末尾结点的ｎｅｘｔ指针域 }} 头插法建立双链表： void creatDListH (DLNode ＆L , int a[], int length){ DLNode *s ; L = (DLNode*)malloc(sizeof(DLNode)); // 申请头结点空间，并将链表滞空 L -&gt; prior = NULL; L -&gt; next = NULL; for (int i = 0 ; i&lt;length; ++i){ s = (DLNode*)malloc(sizeof(DLNode)); s -&gt; data = a[i]; //关键步骤： s -&gt; next = L -&gt; next; L -&gt; next -&gt; prior = s; s -&gt; prior = L; L -&gt; next = s; }} 查找结点的算法： // 在双链表中查找第一个值为ｘ的结点，从第一个结点开始，边扫描边比较，若找到返回该结点的指针，没找到返回 ＮＵＬＬDLNode* findNode(DLNode *L, int x){ DLNode *p; p = L -&gt; next; while (p != NULL){ if (p -&gt; data == x){ return p; } p = p -&gt; next; } return NULL;} 插入结点的算法： //在双链表中ｐ所指结点后插入新的结点ｓ//关键步骤如下： s -&gt; next = p -&gt; next; s -&gt; prior = p; p -&gt; next -&gt; prior = s; p -&gt; next = s; 删除结点： //在双链表中的删除指针ｐ所指结点的后继结点,并用ｓ指针返回被删除的结点//关键步骤如下： s = p -&gt; next ; s -&gt; next -&gt; prior = p; p -&gt; next = s -&gt; next; free(s);","link":"/2019/03/06/linearList/"},{"title":"【底层原理】浮点数在计算机中的表示","text":"一道C语言题： #include &lt;stdio.h&gt;int main(){ int num = 9; float *pFloat = &amp;num; printf(\"num 的值为：%d\\n\",num); printf(\"*pFloat 的值为：%f\\n\",*pFloat); *pFloat = 9.0; printf(\"num 的值为：%d\\n\",num); printf(\"*pFloat 的值为：%f\\n\",*pFloat); return 0;} 运行结果： 产生上述结果的原因：浮点数在计算机中的表示与整数在计算机中的表示存在差异 分析：整数在计算机中的表示：int num = 9; 上面这条语句声明并定义了一个整型int变量num为9；在普通的32位计算机中，用四个字节表示int，其二进制表示为： 00000000 00000000 00000000 00001001 浮点数在计算机中的表示：根据国际标准IEEE 754，任意一个二进制浮点数V可以表示为下面这种形式： $ V = (-1)^{s} · M · 2^{E} $ s表示符号位，s=0为正，s=1为负； M为有效数字，$1&lt;= M &lt;2$; $2^E$表示指数位； 如题例，十进制的 $ 9.0 $ ,写成二进制位$1001.0$,相当于：$ 1.001 · 2^{3} $,其中$ s=0,M=1.001,E=3 $;十进制的$ -9.0 $,写成二进制为$ -1001.0 $,相当于：$ -1.001 · 2^{3} $,其中$ s=1,M=1.001,E=3 $; 有效数字M： IEEE 745规定，对于32位的浮点数，最高的一位是符号位s，接着的8位是指数E，剩下的23位为有效数字M：对于64位的浮点数来说，最高的一位仍为符号位s，接着的11位是指数E，剩下的52位为有效数字M：另外，前面提到，$1&lt;= M &lt;2$,也就是说M可以写成$1.x_1x_2x_3x_4$的形式，其中$x_1x_2x_3x_4$表示小数部分。IEEE 754规定，在计算机内包存M时， 默认这个数的第一位为 1，因此可以被舍去，这样子就可以节省一位有效数字位，使得32（64）位浮点数可以保存24（53）位的有效数字。 指数E的情况稍微复杂一些： 首先，E是一个无符号整数（unsign int ）,着意味着当E为8位时，其取值范围为0到255；若E为11位其取值范围为0到2047。但是我们知道，科学计数法中的E可以是负数，因此，E的真实值必须减去一个中间值。对于8位的E应减去127，对于11位的E应减去1023； 比如说，$ 2^{9} $ 的E是9，所以保存成32位浮点数时，必须保存为$E = 9+127=136$,即$10001000$。 还原E的真实值时还可以分成3种情况： E不全为0或不全为1:。这时可直接用E减去127（1023）即可得到E的真实值。 E全为0。这时浮点数的指数E为1-127（1-1023），有效数字M不再加上第一位，而是还原成$0.x_1x_2x_3x_4$的小数。这样做是为了表示$\\pm0$,以及接近于0的很小的数字。 E全为1。这时如果有效数字M全为0，则表示$\\pm$无穷大（取决于符号位s）；如果有效数字M不全为0，表示这个数是一个$NaN$。 到此，回顾最初的问题。 为什么$00000000 00000000 00000000 00001001$还原成浮点数就变成了$0.000000$ 呢???首先：00000000 00000000 00000000 00001001的符号位s为0表示其为正；再者：00000000 00000000 00000000 00001001的指数位E为00000000（全为0），符合第2种情况，还原后的E的真实值为：$E=1-127=-126$；最后：00000000 00000000 00000000 00001001的有效数字位为：$000 0000 0000 0000 0000 1001$。综上：$V = (-1)^{0} · 0.00000000000000000001001 · 2^{-126} = 1.001 · 2^{-146}$可以看出这是一个很小的数，故用十进制表示为0.000000. 浮点数9.0如何用二进制表示，还原成十进制后为何是1092567616 呢？首先：浮点数9.0的二进制表示为1001.0，即为$1.001 · 2^3$；符号位s=0；再者：有效数字M=100 0000 0000 0000 0000 0000（共23位（100后加上20个0）其中最高位1默认被省略）。最后：指数E=3+127=130，即$E = 10000010_{BIN}$。综上：浮点数9.0在计算机内的表示为：$0 10000010 00100000000000000000000$，将其转化为十进制就是：1091567616","link":"/2019/02/22/【底层原理】浮点数在计算机中的表示/"},{"title":"【算法】DP最大和问题","text":"动态规划 问题描述： 给定一个整数数字序列（用数组表示），在这个数列中选择若干个互不相邻的数，使得这些数的和达到最大值。 分析： 属于01背包问题同类问题，对于每一个数，都有两种选择（选或不选）。假设给定数组set[]的长度为n，最终要求OPT(n-1)的结果,也就是从下标0到下标n-1这些数中能组成的最大和，而要求OPT(n-1)就分为两种情况：1.选择set[n-1],因为不能出现相邻选项故OPT[n-1]的结果为set[n-1]与OPT[n-3]的和。2.不选择set[n-1],则OPT[n-1]的结果就与OPT[n-2]相等。判断出口：不难看出，OPT[0] = set[0]，OPT[1] = max(set[0],set[1]); 因此其状态转移方程为： 算法实现：递归实现：int OPT(int i){ if(i == 0) return set[0]; if(i == 1) return set[0]&gt;set[1] ? set[0]:set[1]; int a = OPT(i-1); int b = OPT(i-2)+set[i]; return a&gt;b?a:b;} DP实现：int OPT_(int set[],int m){ int *opt = new int[100];//状态数组 //出口 opt[0] = set[0]; opt[1] = set[0]&gt;set[1] ? set[0]:set[1]; for(int i = 2;i &lt; m;i++) { int a = opt[i-1]; int b = opt[i-2] + set[i]; opt[i] = a&gt;b?a:b; } return opt[m-1];} 测试： 输入：{1,5,8,9,7,8,2,1,6,3}输出：","link":"/2019/03/17/【算法】DP最大和问题/"},{"title":"【算法】全排列问题","text":"算法思想： 设定一个数组p用来存放当前排列，并用一个数组Hash用来标记已填入p中的数字。按顺序将数字填入数组p中的第0位置第Max-1位，现在假设已经填好了p[0]~p[index-1]，正准备将数字填入index位置，若index位置未及Max（数组边界），则枚举0~Max-1；判断是否有数字未填入，若有则将其填入p中，同时在Hash中将该数字置为已填入。其后继续填入下一个位置index+1；当递归完成时，将Hash[i]还原为false（将i置为未填入）。 代码实现：#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define Max 10using namespace std;//列举从0到Max-1的全排列int p[Max];//保存当前排列bool Hash[Max] = {false};//标记i是否已填入p中，是为真，否为假；void generate_x(int index){ if(index == Max)//递归边界，已生成一种排列可能 { for(int i = 0;i &lt; Max;i++)//输出该排列 { cout &lt;&lt; p[i] &lt;&lt; ' '; } cout &lt;&lt; endl; return; } for(int i = 0;i &lt; Max;i++) { if(Hash[i] == false)//判断i是否还未已填入p中 { p[index] = i;//填入 Hash[i] = true;//标记已填入 generate_x(index+1);//填写下一个数 Hash[i] = false;//处理完P[index] = i 的子问题，还原状态 } }}int main(){ generate_x(0);//从0开始填入 return 0;} 输出结果：/20190313012239824.png)","link":"/2019/03/13/【算法】全排列问题(C++)/"},{"title":"【算法】String实现大数运算算法汇总","text":"大数加法: #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;stdexcept&gt;#define max 1000using namespace std;struct bign//定义一个结构体表示大数{ int dig[max];//由低位到高位存放大数的低位到高位的各位数值 int len;//保存大数的位数 bign(){//初始化函数 dig[max] = {0}; len = 0; }};void s_to_array(string &amp;s,bign &amp;d)//字符串转数组{ int s_len = (int)s.size(); for(int i = 0,j = s_len-1;j &gt;= 0 &amp;&amp; i &lt; max;i++,j--) { if(s[j]&gt;='0' &amp;&amp; s[j]&lt;='9') d.dig[i] = (int)(s[j] - '0'); else throw invalid_argument(\"无效的输入，只能由数字构成！！！\"); } d.len = s_len;}void add(bign &amp;a,bign &amp;b,bign &amp;ans)//大数加法函数{ int carry = 0;//进位 int re; for(int i = 0;i &lt; a.len || i &lt; b.len;i++) { re = a.dig[i] + b.dig[i] + carry; ans.dig[ans.len++] = re%10;//取个位 carry = re/10; } if(carry != 0) { ans.dig[ans.len++] = carry; }}int main(){ string num; string num1; while(cin &gt;&gt; num &gt;&gt; num1) { bign a,b; bign ans; try{ s_to_array(num,a); s_to_array(num1,b); }catch(invalid_argument err){ cout &lt;&lt; err.what() &lt;&lt; endl; cout &lt;&lt; \"Please Try Again\" &lt;&lt; endl; continue; } for(int i = a.len-1;i &gt;= 0;i--) { cout &lt;&lt; a.dig[i]; } cout &lt;&lt; endl; cout &lt;&lt; \"+\" &lt;&lt; endl; for(int i = b.len-1;i &gt;= 0;i--) { cout &lt;&lt; b.dig[i]; } cout &lt;&lt; endl; cout &lt;&lt; \"=\" &lt;&lt; endl; add(a,b,ans); for(int i = ans.len-1;i &gt;= 0;i--) { cout &lt;&lt; ans.dig[i]; } cout &lt;&lt; endl; } return 0;} 大数减法:#include &lt;stdio.h&gt;#include &lt;string.h&gt;void sub(char s1[],char s2[],char t[]){ int i,l1,l2,k; l1 = strlen(s1); l2 = strlen(s2); t[l1] = '\\0'; l1--; for(i=l2-1;i&gt;=0;i--,l1--) { if(s1[l1]-s2[i] &gt;= 0) { t[l1] = s1[l1] - s2[i] + '0'; } else { t[l1] = 10 + s1[l1] - s2[i] + '0'; s1[l1-1] = s1[l1-1] - 1; } } k = l1; while(s1[k]&lt;0) { s1[k] += 10; s1[k-1] -= 1; k--; } while(l1&gt;0) { t[l1] = s1[l1]; l1--; }loop: if(t[0] == '0') { l1 = strlen(s1); for(i = 0;i&lt;l1-1;i++) t[i] = t[i+1]; t[l1-1] = '\\0'; goto loop; } if(strlen(t) == 0) { t[0] = '0'; t[1] = '\\0'; }}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",c,t)) { sub(c,t,sum); printf(\"%s\\n\",sum); } return 0;} 大数乘法:#include&lt;stdio.h&gt;#include&lt;string.h&gt;void mult(char a[],char b[],char s[]){ int i,j,k=0,alen,blen,sum=0,res[65][65]={0},flag=0; char result[65]; alen = strlen(a); blen = strlen(b); for(i=0;i&lt;alen;i++) { for(j=0;j&lt;blen;j++) res[i][j] = (a[i]-'0')*(b[j]-'0'); } for(i=alen-1;i&gt;=0;i--) { for(j=blen-1;j&gt;=0;j--) { sum = sum + res[i+blen-j-1][j]; printf(\"res = %d\\n\",res[i+blen-j-1][j]); } result[k] = sum%10; k++; sum /= 10; } if(sum) { result[k] = sum; k++; } for(i=0;i&lt;k;i++) { result[i] += '0'; } for(i=k-1;i&gt;=0;i--) { s[i] = result[k-1-i]; } s[k] = '\\0'; while(1) { if(strlen(s) != strlen(a) &amp;&amp; s[0] == '0') strcpy(s,s+1); else break; }}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",c,t)) { mult(c,t,sum); printf(\"%s\\n\",sum); } return 0;} 大数除以小数:#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void StringToNum(string str,int num[]){ //字符串转int数组 int len = str.length(); for(int i = 0;i &lt; len;i++) { num[i+1] = str[i] - '0'; } num[0] = len;}int Divide(int div[],int ans[],int divisor)//得到div除于divisor的结果{ //int carry = 0; int temp = 0;//保存上一步的余数 int i; for(i = 1;i &lt;= div[0];i++) { temp = temp*10 + div[i]; if(temp &lt; divisor) ans[i] = 0;//不够除，ans[i]为0 else { //够除 ans[i] = temp/divisor;//ans[i]为商 temp = temp % divisor;//更新余数 } } ans[0] = i;//保存长度标记 return temp;//返回余数}int main(){ string str; int dividend[1001];//被除数 int ans[1001];//结果 while(cin &gt;&gt; str) { StringToNum(str,dividend); DecToBinary(dividend,ans); for(int i = ans[0];i &gt; 0;i--) { cout &lt;&lt; ans[i]; } cout &lt;&lt; endl; /* int carry = DivideTwo(dividend,ans); for(int i=1;i &lt; ans[0];i++) { cout &lt;&lt; ans[i]; } ans[1001] = {0}; cout &lt;&lt; \"..............\"&lt;&lt;carry&lt;&lt; endl; */ } return 0;} 大数阶乘:#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(){ void factorial(int n,int *); int b[10000]; int n; while(cin&gt;&gt;n) { factorial(n,b); } return 0;}void factorial(int n,int b[10000]){ long a[10000]; int i,j,l,c,m=0,w; a[0] = 1; for(i=1;i&lt;=n;i++) { c=0; for(j=0;j&lt;=m;j++) { a[j] = a[j] * i + c; c = a[j]/10000; a[j] = a[j]%10000; } if(c&gt;0) { m++; a[m] = c; } } w = m*4 + log10(a[m])+1; cout &lt;&lt; w &lt;&lt; endl; cout &lt;&lt; a[m]; for(i=m-1;i&gt;=0;i--) { cout &lt;&lt; a[i]; } cout &lt;&lt; endl;} 大整数乘以小数:#include&lt;stdio.h&gt;#include&lt;string.h&gt;void mult(char c[],int m,char t[]){ char s[100]; int len=strlen(c); for(int i=0;i&lt;len;i++) { s[len-i-1] = c[i] - '0'; } int flag,add=0; for(int i=0;i&lt;len;i++) { int k = s[i] * m + add; if(k&gt;=10) { s[i] = k % 10; add = k / 10; flag = 1; } else { s[i] = k; add = 0; flag = 0; } } while(add) { s[len++] = add % 10; add /= 10; } for(int i=0;i&lt;len;i++) t[len-i-1] = s[i] + '0'; t[len] = '\\0';}//大数加小数void addt(char a[],int b,char c[]){ int len = strlen(a); char s[100]; for(int i=0;i&lt;len;i++) s[len-i-1] = a[i] - '0'; int add = 0; for(int i=0;;i++) { if(i&gt;=len) { s[i] = 0; len++; } int k = s[i] + b % 10 + add; b /= 10; if(k&gt;=10) { s[i] = k%10; add = k/10; } else { s[i] = k; add = 0; } if(b==0 &amp;&amp; add==0) break; } for(int i=0;i&lt;len;i++) { c[len-i-1] = s[i] + '0'; } c[len] = '\\0';}int main(){ char c[1000],t[1000],sum[1000]; int m; while(~scanf(\"%s%s\",&amp;m)) { mult(c,m,t); printf(\"%s\\n\",t); addt(c,m,sum); printf(\"%s\\n\",sum); } return 0;}","link":"/2019/02/28/【算法】大数运算算法汇总/"},{"title":"【算法】数字黑洞","text":"【PAT】B1019 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct digs{ int dig[10]; int len; digs() { dig[10] = {0}; len = 0; }};void to_array(int n,digs &amp;d){ while(n) { d.dig[d.len++] = n%10; n /= 10; }}int to_number(digs d){ int i = d.len-1; int t = 0; int result = 0; for(;i &gt;= 0;i--,t++) { result = result + d.dig[i]*((int)pow(10,t)); } return result;}bool cmp_less(int &amp;a,int &amp;b){ return a&gt;b;}int main(){ int n; while(cin &gt;&gt; n) { while(1) { digs d; to_array(n,d); sort(d.dig,d.dig+d.len); int min = to_number(d); sort(d.dig,d.dig+d.len,cmp_less); int max = to_number(d); n = max - min; printf(\"%04d - %04d = %04d\\n\",max,min,n); if(n == 0 || n == 6174) break; } }/* for(int i = 0;i &lt; d.len;i++) { cout &lt;&lt; d.dig[i]&lt;&lt; ' '; } cout &lt;&lt; endl;*/ return 0;}","link":"/2019/03/13/【算法】数字黑洞/"},{"title":"【算法】素数筛法","text":"Eratosthenes筛法 算法思想： 从小到大枚举所有数，对每一个素数，筛去其所有的倍数，剩下的就都是素数了。比如：已知2为素数，筛去2的倍数4,6,8,10……继续枚举到3，筛去3的倍数6,9,12,15……由于4已被筛去，故其不是素数，来到5，筛去5的倍数10,15…..如此下去，即可得到一个素数表 代码实现：#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;//素数筛法const int Max = 101;int prime[Max],pNum = 0;//pNum存放素数个数bool p[Max] = {false};void findPrime(){ for(int i = 2; i &lt; Max;i++)//遍历从2到100的数 { if(p[i] == false)//若i为素数 { prime[pNum++] = i;//将i添加到prime数组中 for(int j = i+i;j &lt; Max;j+=i)//筛掉i的倍数 { p[j] = true; } } }}int main(){ findPrime(); for(int i = 0;i &lt; pNum;i++) { printf(\"%d\\n\",prime[i]); } return 0;} 输出结果：","link":"/2019/03/12/【算法】素数筛法/"},{"title":"【算法】背包问题的DFS与DP解法","text":"Kanapsack Problem 问题描述： 有n件物品，每件物品重w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品总重量不超过背包限重的情况下，让背包内的物品总价值达到最大。 DFS解法：算法思想： 对于每件物品，有两种情况（选，或不选）。若选择该物品，则将更新背包内的总重与总价值量，若不选择该物品，则跳过它去判断下一件物品，当处理完n件物品后，此时记录的sumW和sumC就是所选物品的总质量和总价值。如果sumW不超过V且sumC比MaxValue还大，就更新MaxValue。 #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#define Maxn 10using namespace std;int n,V,MaxValue = 0;//n为物品的总件数，V为背包的容量，MaxValue为最大价值int w[Maxn],c[Maxn];//w[i]为每件物品的重量,c[i]为每件物品的价值void DFS_Kanapsack(int index,int sumW,int sumC){ if(index == n)//已完成对n件物品的选择 { if(sumW &lt;= V &amp;&amp; sumC &gt; MaxValue) { MaxValue = sumC;//更新最大价值 } return; } // DFS_Kanapsack(index+1,sumW,sumC);//不选择第index件物品 DFS_Kanapsack(index+1,sumW + w[index],sumC + c[index]);//选择第index件物品}int main(){ cin &gt;&gt; n &gt;&gt; V; for(int i = 0;i &lt; n;i++)//输入每件物品的重量 { cin &gt;&gt; w[i]; } for(int i = 0;i &lt; n;i++)//输入每件的价值 { cin &gt;&gt; c[i]; } DFS_Kanapsack(0,0,0);//初始时为第0件物品，重量为0，价值为0; cout &lt;&lt; MaxValue &lt;&lt; endl; return 0;} 由于每种物品有两种选择，因而易得上述算法的时间复杂度为$2^n$;这显然很是糟糕，因为在上述算法中，总是把对n件物品的选择全部确定后才去更新最大价值，但是却忽略了背包容量总是不能超过V这个点，也就是说，我们可以把选择index物品放入对上述条件的判断之中，若选择index后重量不超过V则才选择它。 改进后的算法：void DFS_Kanapsack(int index,int sumW,int sumC){ if(index == n) { return; } DFS_Kanapsack(index+1,sumW,sumC); if(sumW + w[index] &lt;= V) { if(sumC + c[index] &gt; MaxValue) { MaxValue = sumC + c[index]; } DFS_Kanapsack(index+1,sumW+w[index],sumC+c[index]); }}","link":"/2019/03/14/【算法】背包问题的DFS与DP解法/"},{"title":"人工神经网络学习笔记（1）","text":"如何让网络可以学习上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况： 老师：1+1=？ 小明：6 老师：1+2=？ 小明：2 … 可以发现，当小明给出答案后老师并没有给于他反馈。因此小明可能某一次猜中了正确答案，但只是凑巧而已，他不具备学习能力。现在让老师给点反馈： 老师：1+5=？ 小明：4 老师：少了 小明：5 老师：少了 小明：6 老师：正确，你真棒！ 这样子，小明学会了1+5=6.我们的神经网络也需要具备这样的学习能力。也就是说，当网络输出错误的结果时要有一个改变下一次输出的机制。想要改变输出，可以改变哪些量呢？观察输出函数：$$O_{output}=\\left[\\begin{matrix}Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot i_{oj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot i_{oj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot i_{oj}}) \\\\\\end{matrix}\\right]=\\left[\\begin{matrix}o_1\\\\o_2\\\\o_3\\end{matrix}\\right]$$不难发现，输出值与以下参数有关： SigMoid函数 链接权重 输入值 显然，我们不可能去左右网络的输入值，因为那是网络要求解的问题，不可能以改变问题的方式改变答案。那么改变激活函数sig如何？这太麻烦了，试想那么多的神经元每一个都不同的激活函数会对运算造成大麻烦，将无法采用简洁的矩阵运算。因此，改变链接权重会是一个好办法。 学习能力的养成我们已经知道可以通过改变链接权重来改变网络的输出值，使其符合预期。那么问题又来了： 改变权重的依据是什么？ 如何改变？ 改变的幅度多大合适？ 改变的依据改变权重的目的是让输出值与期望值越接近越好（误差值越小越好），因此误差就是依据。所谓误差就是期望值与网络输出值的差：$$E=t-o$$我们知道输出层的误差为：$E_o=t_n-o_n$，但是其他层结点的误差是不知道的，因为其他层并没有一个输出期望值$t_n$。不难发现，最终输出层造成的误差是所有层共同作用的结果，所以可以将总误差分摊给其他层。 误差的反向传播 如上图误差为$e_1$，因为链接权重越大说明对该误差的影响越大，因此以链接权重来决定每条链路所分摊误差的大小：$$e_{w_{1,1}}=\\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\\cdot e_1$$$$e_{w_{2,1}}=\\frac{w_{2,1}}{w_{1,1}+w_{2,1}}\\cdot e_1$$反向传播误差到更多层中：隐藏层结点的误差值：$$e_{h1}=\\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\\cdot e_{o1}+\\frac{w_{1,2}}{w_{1,2}+w_{2,2}}\\cdot e_{o2}$$ 使用矩阵乘法简化误差反向传播 误差向量：$$error_{output}=\\left(\\begin{matrix}e_1 \\\\e_2\\end{matrix}\\right)$$ 隐藏层误差：$$error_{hidden}=\\left(\\begin{matrix}\\frac{w_{1,1}}{w_{1,1}+w_{2,1}} &amp; \\frac{w_{1,2}}{w_{1,2}+w_{2,2}} \\\\\\\\\\frac{w_{2,1}}{w_{1,1}+w_{2,1}} &amp; \\frac{w_{2,2}}{w_{1,2}+w_{2,2}}\\end{matrix}\\right) \\cdot \\left(\\begin{matrix}e_1 \\\\ e_2 \\end{matrix} \\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)$$上述矩阵乘法太过复杂，无法通过简单的矩阵运算求解。观察上式可知，最重要的事情是输出误差链接权重$w_{j,k}$的乘法。较大的权重携带较大的误差给隐藏层，这些分数的分母是一种归一化因子。如果我们忽略掉这个因子，我们仅仅只是失去了后馈误差的真实值大小，但并没有失去其表示的真正含义（影响力）,也就是说反馈误差始终是以链接权重的强度来分配的。因此上式可以简化为：$$error_{hidden}=\\left(\\begin{matrix}w_{1,1} &amp; w_{1,2} \\\\w_{2,1} &amp; w_{2,2}\\end{matrix}\\right)\\cdot \\left(\\begin{matrix}e_1\\\\ e_2\\end{matrix}\\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)$$不难发现，隐藏层至输出层的链接权重矩阵$W_{hidden\\rightarrow output}$为:$$W_{hidden\\rightarrow output}=\\left(\\begin{matrix}w_{1,1} &amp; w_{2,1} \\\\w_{1,2} &amp; w_{2,2}\\end{matrix}\\right)=\\left(\\begin{matrix}w_{1,1} &amp; w_{1,2} \\\\w_{2,1} &amp; w_{2,2}\\end{matrix}\\right)^T$$因此：$$error_{hidden}=W_{hidden\\rightarrow output}^T\\cdot error_{output}=\\left(\\begin{matrix}w_{1,1} &amp; w_{2,1} \\\\w_{1,2} &amp; w_{2,2}\\end{matrix}\\right)^T\\cdot \\left(\\begin{matrix}e_1\\\\ e_2\\end{matrix}\\right)=\\left(\\begin{matrix}e_{h1}\\\\e_{h2}\\end{matrix}\\right)$$到此我们得到了用矩阵来传播误差的算法：$$error_{hidden}=W_{hidden\\rightarrow output}^T\\cdot error_{output}$$ 到此，我们已经做了大量的工作了。我们计算出了所有层的误差，接下来的工作就是根据误差来调整链接权重了。","link":"/2019/06/03/人工神经网络学习比记（1）/"},{"title":"二分图最大匹配问题(匈牙利算法)","text":"二分图&emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 奇环 (边为奇数的环路)， 如果一个图没有 奇环 ,那么它就一定是 二分图。 二分图的匹配&emsp;给定一个二分图 G , 在 G 的一个子图 M 中， M 的边集 { E } 中的任意两条边都不依附于同一个顶点， 则称 M 是一个匹配。 翻译成人话就是 在图 G 中找到一些边构成一个集合， 这个集合中的任意一条边所连接的两个顶点都只属于这条边的连个端点，即每条边的顶点都不与其他边共用。如下图： 边集合 E = {(1,5),(3,6),(4,7)} 构成了一个匹配。 最大匹配 &emsp;顾名思义，就是最大化满足上述规定的边集 E 。如上图的一个最大匹配结果为： 匈牙利算法&emsp;此算法由美国数学家 哈罗德·库恩 于1955年提出该算法。先介绍两个概念：&emsp;交替路： 从一个未匹配顶点出发，依次经过非匹配边、匹配边、非匹配边 … 形成的路径叫作 交替路。&emsp;增广路： 从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路就称为增广路(agumenting path)，且增广路中非匹配边的数目要大于匹配边的数目。 如下图：图中已匹配点带蓝色标记，红色箭头边为一条匹配边，黑色箭头边为非匹配边。 &emsp;展开来就是这样的一条 增广路： &emsp;如果此时将上述增广路的 匹配边与非匹配边对调 ： &emsp;不难发现，匹配边多了一条（两条变三条），并且新增了两个匹配顶点。如此一来，边集 E 内不就多了一条边吗，符合我们的目标（最大化边集 E）。因此，匈牙利算法的 核心 就是 不断地寻找增广路径 ，以便可以不断扩大边集 E，得到一个更大的匹配。 总结增广路的定义： 其路径长度必定为奇数，且第一条边与最后一条边必定都不属于 M（最大匹配子图）。 该路径经过取反操作（匹配变不匹配，不匹配变匹配）后可以得到一个更大的匹配 M’。 M 为 G 的最大匹配当且仅当不存在相对于 M 的增广路径。 算法概述： 从 X 集合中选一个未匹配点 u 作为起点。选一条非匹配边(u,v), 到 Y中的点 v。 如果 v 是为匹配点， 说明找到了一条增广路。 否则若 v 是匹配点，下一步走匹配边，v 恰好和一条匹配边邻接。 设另一端为 left[v], 可以理解为 u 直接走到了 left[v], 也是 X 中的点。 如果始终没有找到未匹配点（找不到最后一条非匹配边）,最后会扩展出一棵匈牙利树（root 是未匹配点， 叶子节点都是匹配点），从 root 到 leaf 的路径都不是增广路。 每次选择一个未匹配点 u 进行 DFS。 如果找不到以 u 开头的增广路，就换一个未匹配点来进行 DFS， 且以后再也不从 u 出发找增广路了。 如果以后存在一个从 u 出发的增广路，那么现在肯定找得到。 算法实现：#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 0x00ffclass BPM { // 二分图的最大奇数匹配public: int n, m, e; // 左右顶点个数, 边数 vector&lt;vector&lt;bool&gt;&gt; G; // G[x][y] == 1,表示存在边 x - y int *left; // left[i] 为右边（Y 集合）第i个顶点的匹配顶点编号 bool *T; // T[i] = true 表示第i个顶点已经被标记已访问 BPM() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; e; T = new bool[maxn]; left = new int[maxn]; G = vector&lt;vector&lt;bool&gt;&gt;(maxn,vector&lt;bool&gt;(maxn,false)); for(int i = 0; i &lt; e; i++) { int t1, t2; cin &gt;&gt; t1 &gt;&gt; t2; G[t1][t2] = true; } memset(T, false, sizeof(T)); memset(left, -1, sizeof(left)); } bool match(int u) // 匈牙利算法 { for(int v = 0; v &lt; m ; v++) // 遍历右边 Y 集合中的顶点 { if(G[u][v] &amp;&amp; !T[v]) { T[v] = true; if(left[v] == -1 || match(left[v])) // left[v] != -1, left[v] 是 v 的匹配边 { // 若 v 未匹配就将它与 u 匹配(相当于找到了一条增广路 u -&gt; v)，否则通过 v 的匹配点继续找未匹配点 left[v] = u; return true; } } } return false; } int solve() // 求最大匹配 { int ans = 0; // 匹配数 for(int u = 0; u &lt; n; u++) // 遍历左边顶点寻找增广路 { memset(T, false, sizeof(T)); if(match(u)) { cout &lt;&lt; \"--\" &lt;&lt; endl; ans++; // 找到一条增广路 } } return ans; }};","link":"/2019/11/25/二分图最大匹配问题(匈牙利算法)/"},{"title":"人工神经网络学习笔记（0）","text":"何为人工神经网络人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。 生物神经元关键部件： 树突 &amp; 胞体 &amp; 轴突 单个神经元的工作机制可以简单地描述为：树突接受其他神经元的神经末梢传来的电信号，信号传送到胞体并由某种机制决定是否激发下一次电信号的传递，若激发则电信号由轴突传递至神经末梢，再由神经末梢传递给其他神经元。其中，判断是否激发的机制有一大好处是可以减小神经元间微弱电信号（噪声）的干扰，使得自由足够强的电信号才能激发下一次传递。 人工神经元概览 由生物神经元得到的启发，人工神经元与其大同小异。上图中： $x_1,x_2,x_3,x_4$ 为该神经元树突所接受到的其他神经元传来的电信号。中间的圆圈为胞体，在胞体中将会由处理信号的机制，以决定输出信号y。功能 在之前的生物神经元中已经说道，神经元对是否激发信号传递有一个判断机制，这是因为神经元不希望传递微小的噪声信号，而只传递有意识的明显信号。只有信号强度达到了某一个阙值，才会激发电信号的传递。那么在人工神经元中我们如何来实现这个机制呢？ 这样的一个函数也许能够满足我们的需要：$$Function(x) = \\begin{cases}0 &amp; x \\leq T \\\\1 &amp; x&gt;T\\end{cases}$$显而易见，这个简单的阶跃函数在输入信号大于T（阙值）时才会产生输出信号1（被激发），而较小的输入时输出为0（被抑制）；我们称这样的函数为激活函数。当然，激活函数不会就只有这么一种。常用的还有sigmoid函数：$$Sigmoid(x) = \\frac{1}{1+e^{-x}}$$函数图像：可以发现，sigmoid函数相对于阶跃函数而言更加平滑，自然，接近现实。我们的神经网络也将采用它。如此一来，我们的单个神经元模型就成型了：参数含义： $x_1 ,x_2… x_m$为输入信号 $w_1 ,w_2… w_m$为权重值，表示各个输入信号对输出结果的影响力大小。对于为何引入权值可以做如下思考：你去相亲，你对未来对象的考量主要有身高，长相，身材，文化程度等，但遇到样样都好的概率实在是太底了，所以你决定适当放宽某些要求。比如如果学历高就可以降低身材长相的要求。这表示你比较注重伴侣的文化程度。因此，对方的文化程度对你的择偶有着重要的影响，其所占权重就会比较高。 求和函数将计算$x=\\sum_{m}{x_iw_i},i=1,2,…m$后将所得的值传给激活函数Sigmoid即：$$Output=Sig(x)=\\frac{1}{1+e^{-(\\sum_{m}{x_iw_i})}}$$观察函数图不难发现，Sigmoid函数将加权求和的输入映射到0~1的值域内输出。人工神经网络介绍完单个神经元的功能，如果把这些小部件组合起来，就成了所谓的人工神经网络。层次结构： 输入层：接受外部输入信息，可以是图片等。 隐藏层：隐藏层层数不一，可根据需求来定。 输出层：将结果输出到外部。 链接方式： 除输入层外，每一层的每个神经元都接受其上一层所有神经元传来的信号的加权值。 神经元的链接方式并不唯一，你可以创造自己的链接方式，但为了便于抽象计算编码，规则的链接方式能帮我们大忙。 一个三层神经网络示例 参数释义： $i_1,i_2,i_3$为输入信号。 $w_{j,k}$表示后层结点$j$与前一层节点$k$之间链接的权重值。 $o_1,o_2,o_3$为该网络输出的结果信号。 信号的前向传播：前面我们介绍了单个人工神经元对信号的处理。但是现在网络中有多个神经元，我们当然不愿意对每一个神经元节点都进行编码计算，因此我们将其简化为矩阵运算。 将输入看成一个多维列向量：$$I=\\left[\\begin{matrix}i_1 \\\\i_2 \\\\i_3\\end{matrix} \\right]$$ 链接权重为一个$3\\times3$的矩阵：$$W_{input\\rightarrow hidden}=\\left[\\begin{matrix}w_{1,1} &amp; w_{2,1} &amp; w_{3,1} \\\\w_{1,2} &amp; w_{2,2} &amp; w_{3,2} \\\\w_{1,3} &amp; w_{2,3} &amp; w_{3,3}\\end{matrix} \\right]$$ 将两者相乘得到隐藏层的输入信号：$$I_{hidden}=W_{input\\rightarrow hidden}\\cdot I=\\left[\\begin{matrix}w_{1,1}\\cdot i_1 + w_{2,1}\\cdot i_2 + w_{3,1}\\cdot i_3 \\\\w_{1,2}\\cdot i_1 + w_{2,2}\\cdot i_2 + w_{3,2}\\cdot i_3 \\\\w_{1,3}\\cdot i_1 + w_{2,3}\\cdot i_2 + w_{3,3}\\cdot i_3\\end{matrix} \\right]$$也即：$$I_{hidden}=\\left[\\begin{matrix}\\sum_{j=1}^{3}{w_{j,1}\\cdot i_j} \\\\\\sum_{j=1}^{3}{w_{j,2}\\cdot i_j} \\\\\\sum_{j=1}^{3}{w_{j,3}\\cdot i_j}\\end{matrix}\\right]=[i_{h1},i_{h2},i_{h3}]^T$$ 再将加权求和的信号值经过Sigmoid激活函数处理我们可以得到最终的输出向量：$$O_{hidden}=Sig(W_{hidden\\rightarrow output}\\cdot I_{hidden})=\\left[\\begin{matrix}Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot o_{hj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot o_{hj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot o_{hj}}) \\\\\\end{matrix}\\right]=[o_{h1},o_{h2},o_{h3}]^T$$这里需要注意的是，输入层到隐藏层的链接权重矩阵与隐藏层到输出成的链接权重矩阵是不同的矩阵。但是计算过程是一致的，因此同理可得：$$I_{output}=Sig(W_{hidden\\rightarrow output}\\cdot O_{hidden})$$网络的最终输出为：$$O_{output}=\\left[\\begin{matrix}Sig(\\sum_{j=1}^{3}{w_{j,1}\\cdot i_{oj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,2}\\cdot i_{oj}}) \\\\Sig(\\sum_{j=1}^{3}{w_{j,3}\\cdot i_{oj}}) \\\\\\end{matrix}\\right]=[o_1,o_2,o_3]^T$$到此，我们已经了解了神经网络中信号的前向传播机制，但是目前这个网络模型远远达不到我们的要求，它除了单纯的传播信号什么事情也做不了。显然后续我们得为其添加反馈机制，使其能够具有学习能力。","link":"/2019/06/03/人工神经网络学习笔记（0）/"},{"title":"人工神经网络学习笔记（2）","text":"如何更新权重在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？ 暴力枚举：对于一个三层的神经网络，每层有3个神经元结点，有两个$3\\times 3$的链接权重矩阵，共有18个权重值。假设每个权重在1和-1之间共有1000种取值，那么我们有$1000^{18}$种权重组合，这个数字已经很大了。但是，如果是每层有500个结点呢？那么权重数将达到$2\\times 500\\times 500 = 500000$个，将会有$1000^{500000}$种组合。想要遍历这么些种可能得等到人类灭绝… 可见，暴力枚举并不能实际地解决我们的问题。 新的思路：让我们再次明确下我们的最终目的，让误差值降到最小。试着将其转化成数学上的求函数最小值问题。先前我们知道，误差是所有链接权重的函数:$$Error = F_{error}(w_{1,1},w_{2,1},……,w_{j,k})$$现在我们需要额就是找出该函数的最小值。但由于真正的误差函数的自变量太多，先举个简单的例子：假设误差函数只有一个自变量（链接权重）：$$E_{simple}=F_e(x)$$其图像为：可以将其想象成一个连绵的山脉，有山峰也有山谷。设想将一个小球至于山腰，那么在重力的作用下它必定沿着所在位置的斜率方向向下滚动直到山谷。但是很明显，我们并没有重力帮忙，因此必须人为指定“滚动方向”。不难发现，当斜率为正时应向左滚动（x–），斜率为负时应向右滚动（x++）。这种方法在数学上被称为梯度下降（gradient descent）。可能的意外情况：我们可能会碰到这种情况：当小球的起始位置为左侧山腰时，其很有可能最终会在局部最小值（左侧的山谷）停下，这可不是我们所希望的结果。因为我们的目的是把误差降到最小，那里显然不是最小的地方。为了避免上述情况，我们应从选择不同的其实位置对神经网络进行多次训练，以确保其并不总是终止于错误的地方。而不同的其实位置意味着不同的链接权重。 选择误差函数的形式可选项： $E=t_n-o_n$ (目标值 - 期望值) $E=(t_n-o_n)^2$ 方差形式 我们选用方差形式，因为其具有很多优点： 可以很容易地使用代数方法（链式法则求解偏导数）计算出梯度下降的斜率 误差函数平滑连续，这使得梯度下降算法可以很好地发挥作用 越接近最小值梯度（斜率）越小，按照斜率调整步长可以减少越过最佳位置的风险 计算梯度值（斜率） 当只有一个链接权重时，误差函数为二维曲线：$$k=\\frac{\\partial{E}}{\\partial{x}}$$ 当有两个链接权重时，误差函数为一个三维曲面：$$k=\\frac{\\partial{E}}{\\partial{w_{j,k}}}$$上述表达式表示了当权重$w_{j,k}$改变时，误差$E$是如何改变的。这是误差函数的斜率，也就是我们希望使用梯度下降的方法达到最小值的方向。 计算梯度： 在开始计算前我们回顾一下网络中各个参数的意义： 展开误差函数：由于一个结点的误差只与与其相连的链接权重有关，因此误差函数可以简单地表示为：$$E=(t_k-o_k)^2$$其中：$o_k=Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})$所以：$$E=(t_k-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))^2$$所以：$$\\frac{\\partial{E}}{\\partial{w_{j,k}}}=\\frac{\\partial{(t_k-o_k)^2}}{\\partial{w_{j,k}}}$$$$=\\frac{\\partial{E}}{\\partial{o_k}}\\cdot \\frac{\\partial{o_k}}{\\partial{w_{j,k}}}=-2(t_k-o_k)\\cdot \\frac{\\partial{o_k}}{\\partial{w_{j,k}}}$$其中：令$x=\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}$$$\\frac{\\partial{o_k}}{\\partial{w_{j,k}}}=\\frac{\\partial{Sig(x)}}{\\partial{w_{j,k}}}=\\frac{\\partial{Sig(x)}}{\\partial{x}}\\cdot \\frac{\\partial{x}}{\\partial{w_{j,k}}}$$且：$$\\frac{\\partial{Sig(x)}}{\\partial{x}}=Sig(x)\\cdot (1-Sig(x))$$因此，我们得到了以下表达式：$$\\frac{\\partial{E}}{\\partial{w_{j,k}}}=-2(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot \\frac{\\partial{(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}})}{\\partial{w_{j,k}}}$$$$=-2(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj}$$又由于我们只关心误差函数斜率的方向，因此可以将公式中的常数2省略，并不影响正负号：$$\\frac{\\partial{E}}{\\partial{w_{j,k}}}=-(t_k-o_k)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj}$$$$=-(e_j)\\cdot Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}})\\cdot (1-Sig(\\sum_{j=1}^{n}{w_{j,k}\\cdot o_{hj}}))\\cdot o_{hj}$$ 改变链接权重之前提到过，权重的改变方向与梯度的方向相反。因此我们规定权重的改变方式为：$$w_{j,k}^{new}=w_{j,k}^{old}-\\alpha \\cdot \\frac{\\partial{E}}{\\partial{w_{j,k}}}$$参数释义： $\\alpha$为学习因子，可以调节这些权重变化的强度 用矩阵来简化运算：$$\\left(\\begin{matrix}\\vartriangle w_{1,1} &amp; \\vartriangle w_{2,1} &amp; \\vartriangle w_{3,1} &amp; …\\\\\\vartriangle w_{1,2} &amp; \\vartriangle w_{2,2} &amp; \\vartriangle w_{3,2} &amp; …\\\\\\vartriangle w_{1,3} &amp; \\vartriangle w_{2,3} &amp; \\vartriangle w_{3,3} &amp; …\\\\… &amp; … &amp; … &amp; …\\end{matrix}\\right)=\\alpha\\cdot \\left(\\begin{matrix}e_1\\cdot S_1\\cdot (1-S_1)\\\\ e_2\\cdot S_2\\cdot (1-S_2)\\\\ e_k\\cdot S_k\\cdot (1-S_k)\\\\ …\\end{matrix}\\right) \\cdot (o_1,o_2,o_3,…)$$将Sig函数简化为输出：$$\\vartriangle w_{j,k} = \\alpha\\times E_k \\times O_k \\times (1-O_k) \\cdot O_j^T$$ 到此，所有的前期工作都已完成。","link":"/2019/06/04/人工神经网络学习笔记（2）/"},{"title":"人工神经网络学习笔记（3）","text":"Python-numpy编码实现人工神经网络 前面的几篇文章我们熟悉了人工神经网络的数学原理及其推导过程，但有道是‘纸上得来终觉浅’，是时候将理论变为现实了。现在我们将应用Python语言以及其强大的扩充程序库Numpy来编写一个简单的神经网络。 准备数据： 训练集and测试集：Mnist手写数字数据集(复制git链接克隆)MINST数据库是由米国机器学习大佬Yann提供的手写数字数据库文件，其官方下载地址Download Mnist。该数据集将会是神经网络的输入信号。 每一张图片像素都为$28\\times 28$,因此可作为一个$784\\times 1$的向量传入神经网络。 初始花链接权重矩阵：使用正态概率分布采样权重，平均值为0，标准方差为结点传入链接数目的开方，即$\\frac{1}{\\sqrt{inputconnects}}$ 编码实现下面的代码实现了一个双隐层的神经网络，但是它的表现并不好（最起码在Mnist数据集的表现上差强人意），我训练了5个小时（5世代）也只能达到%96.54的准确率。相比而言当隐层的神经网络在Mnist数据集上的表现更好，三个小时（5世代）可以达到%97.34的准确率。你可以注释掉下面的部分代码将其退回到单隐层结构甚至加到三隐层结构。虽然代码写的很乱但代码中每一句都有详细的注释，别介意哈哈哈。包含两个源代码文件： neural_network.py 包含神经网络主类用于训练神经网络 network_test.py 用于测试神经网络 neural_network.py import numpyimport matplotlib.pyplot as pltimport scipy.specialimport scipy.ndimage.interpolationimport timeimport progressbarimport matplotlib.animation as anim# 神经网络类定义class neuralNetwork: # 初始化神经网络 def __init__(self,inputnodes,hiddennodes,hiddennodes_2,outputnodes,learningrate): # 设置神经网络的输入层、隐藏层、输出层、的结点数和学习率 self.inodes = inputnodes self.hnodes = hiddennodes # 第一隐藏层结点数 self.hnodes_2 = hiddennodes_2 # 第二隐藏层结点数 #self.hnodes_3 = hiddennodes_3 # 第三隐藏层结点数 self.onodes = outputnodes # 学习率 self.lr = learningrate # （常规版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络） self.wih = (numpy.random.rand(hiddennodes,inputnodes)-0.5) self.who = (numpy.random.rand(outputnodes,hiddennodes)-0.5) # （进阶版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络） self.wih_ = numpy.random.normal(0.0,pow(self.hnodes,-0.5),(hiddennodes,inputnodes)) # 输入层到第一隐藏层权重矩阵 self.wh12_ = numpy.random.normal(0.0,pow(self.hnodes_2,0.5),(hiddennodes_2,hiddennodes)) # 第一隐藏层到第二隐藏层权重矩阵 #self.wh23_ = numpy.random.normal(0.0,pow(self.hnodes_3,0.5),(hiddennodes_3,hiddennodes_2)) # 第二隐藏层到第三隐藏层权重矩阵 self.who_ = numpy.random.normal(0.0,pow(self.onodes,-0.5),(outputnodes,hiddennodes_2)) # 第三隐藏层到输出层权重矩阵 #定义激活函数，由scipy库提供 self.activation_function = lambda x : scipy.special.expit(x) # 训练神经网络 def train(self,inputs_list,targets_list): # 将输入信号列表和目标信号列表转换成列向量 inputs = numpy.array(inputs_list,ndmin=2).T targets = numpy.array(targets_list,ndmin=2).T # 第一隐藏层的输入信号： hidden_inputs = numpy.dot(self.wih_,inputs) # 第一隐藏层的输出信号（激活函数作用）： hidden_outputs = self.activation_function(hidden_inputs) # 第二隐藏层的输入信号: hidden_inputs_2 = numpy.dot(self.wh12_,hidden_outputs) # 第二层隐藏层的输出信号： hidden_outputs_2 = self.activation_function(hidden_inputs_2) ''' # 第三隐藏层的输入信号： hidden_inputs_3 = numpy.dot(self.wh23_,hidden_outputs_2) # 第三隐藏层的输出信号： hidden_outputs_3 = self.activation_function(hidden_inputs_3) ''' # 输出层的输入信号： final_inputs = numpy.dot(self.who_,hidden_outputs_2) # 输出层的输出信号： final_outputs = self.activation_function(final_inputs) # 计算输出层误差向量 output_errors = targets - final_outputs # 计算第三隐藏层误差向量 #hidden_errors_3 = numpy.dot(self.who_.T,output_errors) # 计算第二隐藏层的误差向量 hidden_errors_2 = numpy.dot(self.who_.T,output_errors) # 计算第一隐藏层的误差向量 hidden_errors = numpy.dot(self.wh12_.T,hidden_errors_2) ''' 优化链接权重值 ''' # 第三隐藏层与输出层间的链接权重优化 #self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)),numpy.transpose(hidden_outputs_3)) # 第二隐藏层与第三隐藏层间的链接权重优化 self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)),numpy.transpose(hidden_outputs_2)) # 第一隐藏层与第二隐藏层间的链接权重优化 self.wh12_ += self.lr * numpy.dot((hidden_errors_2 * hidden_outputs_2 * (1.0 - hidden_outputs_2)),numpy.transpose(hidden_outputs)) # 输入层与第一隐藏层间的链接权重优化 self.wih_ += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)),numpy.transpose(inputs)) #return self.query(inputs_list) # 查询 def query(self,inputs_list): # 将输入列表转成numpy向量对象并转置为列向量 inputs = numpy.array(inputs_list,ndmin=2).T # 第一隐藏层结点的输入信号：权重矩阵与输入信号向量的乘积 self.hidden_inputs = numpy.dot(self.wih_,inputs) # 第一隐藏层结点的输出信号：经过S函数的加权求和值 self.hidden_outputs = self.activation_function(self.hidden_inputs) # 第二隐藏层的输入信号: self.hidden_inputs_2 = numpy.dot(self.wh12_,self.hidden_outputs) # 第二层隐藏层的输出信号： self.hidden_outputs_2 = self.activation_function(self.hidden_inputs_2) ''' # 第三隐藏层的输入信号： self.hidden_inputs_3 = numpy.dot(self.wh23_,self.hidden_outputs_2) # 第三隐藏层的输出信号： self.hidden_outputs_3 = self.activation_function(self.hidden_inputs_3) ''' # 输出层结点的输入信号： self.final_inputs = numpy.dot(self.who_,self.hidden_outputs_2) # 输出层结点的最终输出信号： self.final_outputs = self.activation_function(self.final_inputs) # 返回最终输出信号 return self.final_outputsdef test(Network,test_dataset_name): Network.wih_ = numpy.loadtxt('wih_file.csv') Network.wh12_ = numpy.loadtxt('wh12_file.csv') #Network.wh23_ = numpy.loadtxt('wh23_file.csv') Network.who_ = numpy.loadtxt('who_file.csv') # 准备测试数据 test_data_file = open(test_dataset_name,'r') test_data_list = test_data_file.readlines() test_data_file.close() print('\\n') print(\"Testing...\\n\") # 统计 correct_test = 0 all_test = 0 correct = [0,0,0,0,0,0,0,0,0,0] num_counter = [0,0,0,0,0,0,0,0,0,0] #测试进度条 p_test = progressbar.ProgressBar() p_test.start(len(test_data_list)) # 动画显示 #plt.figure(1) for imag_list in test_data_list: all_values = imag_list.split(',') lable = int(all_values[0]) scaled_input = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 imag_array = numpy.asfarray(scaled_input).reshape((28,28)) ''' plt.imshow(imag_array,cmap='Greys',animated=True) plt.draw() plt.pause(0.00001) ''' net_answer = Network.query(scaled_input).tolist().index(max(Network.final_outputs)) num_counter[lable] += 1 if lable == int(net_answer): correct_test += 1 correct[lable] += 1 p_test.update(all_test + 1) all_test += 1 p_test.finish() print(\"Finish Test.\\n\") # 网络性能 performance = correct_test/all_test Per_num_performance = [] for i in range(10): # 测试集可能不包含某些数字，故捕捉除以0异常 try: Per_num_performance.append(correct[i]/num_counter[i]) except ZeroDivisionError: Per_num_performance.append(0) print(\"The correctRate of per number： \",Per_num_performance) print(\"Performance of the NeuralNetwork： \",performance*100) return performance# 定义网络规模与学习率input_nodes = 784hidden_nodes = 700hidden_nodes_2 = 700#hidden_nodes_3 = 100output_nodes = 10learningrate = 0.0001if __name__ == \"__main__\": # 定义训练世代数 epochs = 5 #创建神经网络实例 Net = neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate) #plt.imshow(final_outputs,interpolation=\"nearest\") # 准备训练数据 data_file = open(\"mnist_train.csv\",'r') data_list = data_file.readlines() N_train = len(data_list) data_file.close() # 动画显示 #plt.figure(1) print(\"Training：\", epochs, \"epochs...\") for e in range(epochs): # 训练进度条 print('\\nThe '+str(e+1)+'th epoch trainning:\\n') p_train = progressbar.ProgressBar() p_train.start(N_train) i = 0 for img_list in data_list: # 以逗号分割记录 all_values = img_list.split(',') # 将0-255映射到0.01-0.99 scaled_input = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 imag_array = numpy.asfarray(scaled_input).reshape((28,28)) #plt.imshow(imag_array,cmap='Greys',animated=True) #plt.draw() #plt.pause(0.00001) #旋转图像生成新的训练集 input_plus_10imag = scipy.ndimage.interpolation.rotate(imag_array,10,cval=0.01,reshape=False) input_minus_10imag = scipy.ndimage.interpolation.rotate(imag_array,-10,cval=0.01,reshape=False) input_plus10 = input_plus_10imag.reshape((1,784)) input_minus10 = input_minus_10imag.reshape((1, 784)) # 根据标签创建目标值向量 targets = numpy.zeros(output_nodes) + 0.01 targets[int(all_values[0])] = 0.99 # 用三个训练集训练神经网络 Net.train(scaled_input,targets) Net.train(input_plus10,targets) Net.train(input_minus10,targets) #time.sleep(0.01) p_train.update(i+1) i+=1 p_train.finish() print(\"\\nTrainning finish.\\n\") # 将训练好的神经网络链接权重输出到csv文件中 numpy.savetxt('wih_file.csv',Net.wih_,fmt='%f') numpy.savetxt('wh12_file.csv',Net.wh12_,fmt='%f') #numpy.savetxt('wh23_file.csv',Net.wh23_,fmt='%f') numpy.savetxt('who_file.csv',Net.who_,fmt='%f') network_test.py import neural_network as nkimport numpyimport matplotlib.pyplot as plimport scipy.specialimport scipy.ndimage.interpolationimport jsonimport timeimport progressbar# 测试神经网络if __name__ == \"__main__\": input_nodes = nk.input_nodes hidden_nodes = nk.hidden_nodes hidden_nodes_2 = nk.hidden_nodes_2 #hidden_nodes_3 = nk.hidden_nodes_3 output_nodes = nk.output_nodes learningrate = nk.learningrate Network = nk.neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate) nk.test(Network,\"mnist_test.csv\") # hidden_nodes = 200 lr = 0.01 performance = 97.34 运行程序 cd进入代码所在文件夹 (训练神经网络)输入命令：python neural_network.py （测试神经网络）输入命令：python network_test.py [Warning] 运行时请确保训练集和测试集数据的.csv文件与源代码文件在同一个目录下，否则请修改源码中的文件路径","link":"/2019/06/07/人工神经网络学习笔记（3）/"},{"title":"侯捷C++学习笔记[未整理版]","text":"还没有整理过的笔记，有点乱 C++ 程序设计II 兼谈对象模型 Conversion function - 转换函数 operator type()// this type -&gt; other typeclass Fraction { // 分数类，分数可以被看成double public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const // 最好加const { return ((double)m_numerator / m_denominator); } // 转换函数，不唯一，合理就行 private: int m_denominator; // 分母 int m_numerator; // 分子};// 使用int main(){ Fraction f(3,5); double d = 4 + f; // 调用 operator double() 将 f 转换成 double cout &lt;&lt; d &lt;&lt; endl;// 4.6} non-explicit-one-argument ctor // other type -&gt; this typeclass Fraction { // 分数类 public: // non-explicit-one-argument constructor Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} Fraction operator+(const Fraction&amp; f) { return Fraction(...); } /* 当下面operator type() 函数同时存在时，会迷惑编译器，出错 ambiguous // 因为有两条路可行： 1. 将 4 转Fraction 2. 将 f 转double 在将 4.6 转Fraction 从而产生歧义 operator double() const // 最好加const { return ((double)m_numerator / m_denominator); } // 转换函数 */ private: int m_denominator; // 分母 int m_numerator; // 分子};// 使用int main(){ Fraction f(3,5); Fraction d = 4 + f; // 调用 non-explicit ctor 将 4 转换成 Fraction,然后调用operator+()} explicit-one-argument ctor// other type -&gt; this typeclass Fraction { // 分数类 public: // explicit-one-argument constructor explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} // 90% 的 explicit 用在构造函数上 Fraction operator+(const Fraction&amp; f) { return Fraction(...); } operator double() const // 最好加const { return ((double)m_numerator / m_denominator); } // 转换函数 */ private: int m_denominator; // 分母 int m_numerator; // 分子};// 使用int main(){ Fraction f(3,5); Fraction d = 4 + f; // [Error] conversion from double to Fraction requested, 4 不能自动转为Fraction} 应用template&lt;class Alloc&gt;class vector&lt;bool, Alloc&gt; { public: typedef __bit_reference reference; protected: reference operator[](size_type n) { return *(begin() + defference_type(n)); }}struct __bit_reference { unsigned int* p; unsigned int mask; ...public: operator bool() { return !(!(*p &amp; mask)); } ...} pointer-like classes, 关于智能指针 一个 class 产生出来的对象像一个指针(do more then pointer, such as auto pointer) template&lt;class T&gt;class shared_ptr { public: // 固定写法 T&amp; operator*() const { return *px;} T* operator-&gt;() const { return px;} shared_ptr(T* p) : px(px) {} private: T* px; // 指向 T 的指针 long* pn; ...};struct Foo{ void method() {}};int main(){ shared_ptr&lt;Foo&gt; sp(new Foo); // 初始化sp为指向Foo的智能指针,即sp内部的px指向Foo Foo f(*sp); // *p 调用 operator*() sp -&gt; method(); // 调用 method 函数 等价于 调用operator-&gt;() 再调用 px -&gt; method();} pointer-like classes, 关于迭代器(一种特别的智能指针)// list 链表节点设计template&lt;class T&gt;class __list_node { void* prev; void* next; T data;}template&lt;lass T, class Ref, class Ptr&gt;struct __list_iterator { // 链表的迭代器实现 typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; // 指向链表节点的指针类型 link_type node; // node 为指向链表节点的指针 bool operator==(const self&amp; x) const {return node == x.node;} bool operator!=(const self&amp; x) const {return node != x.node;} // 本节重点 reference operator*() const {return (*node).data;} pointer operator-&gt;() const {return &amp;(operator*());} self&amp; operator++() {node = (link_type)((*node).next); return *this;}//前置 self operator++(int) {self tmp = *this; ++*this; return tmp;}//后置 self&amp; operator--() {node = (link_type)((*node).prev); return *this;}//前置 self operator--(int) {self tmp = *this; --*this; return tmp;}//后置};// 使用int main(){ list&lt;Foo&gt;::iterator it; *it; // 获得一个Foo对象 it -&gt; method(); // 调用Foo::method() // 相当于 (*it).method(); // 相当于 (&amp;(*it)) -&gt; method();} function-like classes, 所谓 仿函数 (像函数的类) () 函数调用操作符 function call一般只要看到class内重载了()操作符，那他的用意就是想要变成一个function,其构造的对象称为函数对象标准库中，仿函数会继承一些奇特的基类如：unary_function , binary_function // 大小为零template&lt;class Arg, class Result&gt;struct unary_function { typedef Arg argument_type; typedef Result result_type;}; template&lt;class T&gt; struct identity : public unary_function&lt;T, T&gt;{ const T&amp; operator() (const T&amp; x) const {return x;} // 重载了函数调用操作符};template&lt;class Pair&gt; // 源代码暗示你给他一个 pairstruct select1st : public unary_function&lt;Pair, typname Pair::first_type&gt; { const typename Pair::first_type&amp; operator() (const Pair&amp; x) const {return x.first;}};template&lt;class Pair&gt;struct select2nd : public unary_function&lt;Pair, typname Pair::second_type&gt; { const typename Pair::second_type&amp; operator() (const Pair&amp; x) const {return x.second;}};template&lt;class T1, class T2&gt;struct pair { T1 first; T2 second; pair() : first(T1()), second(T2()) {} // 无参初始化 pair(const T1&amp; a, const T2&amp; b) : first(a), second(b) {} // 传参初始化};int main(){ pair&lt;char,int&gt; p('a',97); char ch = select1st(p); int in = select2nd(p);} namespase 经验谈 避免命名冲突 using namespace std;// ---------------------------------------------#include &lt;iostream&gt;#include &lt;memory&gt; // shared_ptrnamespace jj01 { void test_member_template() { ... }} // namespace// ---------------------------------------------#include &lt;iostream&gt;#include &lt;list&gt;namespase jj02 { template&lt;typename T&gt; using Lst = list&lt;T,allocator&lt;T&gt;&gt;; void test_template_param() {...}} // namespace// ----------------------------------------------// 可以将所有测试函数放在一个main里面执行int main(int argc, char** argv) { jj01::test_member_template(); jj02::test_template_param();} class template, 模板类(泛型编程) template&lt;class T&gt;class Class { T a;public: T getA() const { return a;}}; function template, 函数模板 编译器会对 function template 进行 实参推导 (augument deduction) class stone {public: stone (int w, int h, int we) : _w(w), _h(h), _weight(we) {} bool operator&lt; (const stone&amp; ths) const {return _weight &lt; rhs._weight;}private: int _w, _h, _weight;};template&lt;class T&gt;inlineconst T&amp; min(const T&amp; a, const T&amp; b){ return b &lt; a ? b : a; // 实参推导的结果，T 为stone，于是调用 stone::operator&lt;()} member template, 成员模板(令构造函数更有弹性)template&lt;class T1, class T2&gt;struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) {} // 无参初始化 pair(const T1&amp; a, const T2&amp; b) : first(a), second(b) {} // 传参初始化 // 成员模板(是成员又是模板) template&lt;class U1, class U2&gt; pair(const pair&lt;U1, U2&gt;&amp; p) // 构造函数 U1,U2 必须(可转型为)继承于 T1,T2 : first(p.first), second(p.second) {}}; 例子:class Base1 {};class Derived1 {};class Base2 {};class Derived2 {};pair&lt;Derived1, Derived2&gt; p;pair&lt;Base1, Base2&gt; p2(p); // 可以pair&lt;Base1, Base2&gt; b;pair&lt;Derived1, Derived2&gt; b2(b); // 不可以 template&lt;typename _Tp&gt;class shared_ptr : public __shared_ptr&lt;_Tp&gt; { template&lt;typename _Tp&gt; explicit shared_ptr(_Tp1* __p) : __shared_ptr&lt;_Tp&gt;(__p) {}};Base1* ptr = new Derived1; // up-cast 向上造型shared_ptr&lt;Base1&gt; sptr(new Derived1); // 模拟up-cast specialization, 模板特化// 泛化template &lt;class Key&gt; // 绑定struct hash { };// 特化template &lt;&gt;struct hash&lt;char&gt; { size_t operator() (char x) const { return x;}};template &lt;&gt;struct hash&lt;int&gt; { size_t operator() (int x) const { return x;}}int main(){ cout &lt;&lt; hash&lt;int&gt; () (1000); // 临时对象} partial specialization, 模板偏特化 – 个数上的偏// 泛化template &lt;typename T, typename Alloc = ...&gt;class vector{ pass};// 偏特化template &lt;typename T, typename Alloc=...&gt;class vector&lt;bool, Alloc&gt; // 绑定第一个模板参数，必须从左到右依次指定，不可跳跃{ pass};// --------------------------------------------// 范围上的偏特化template &lt;typename T&gt;class C{ pass};template &lt;typename T&gt;class C&lt;T*&gt;{ pass};C&lt;string&gt; obj1;C&lt;string*&gt; obj2; template template parameter, 模板模板参数 // Container为模板模板参数template &lt;typename T, template&lt;typename T&gt; class Container &gt;class XCls{private: Container&lt;T&gt; c;public: pass};template &lt;typename T&gt;using Lst = list&lt;T, allocator&lt;T&gt;&gt;;XCls&lt;string, list&gt; my1st1; // Error list本身是模板，未定义XCls&lt;string, Lst&gt; my1st2; // 可以 template&lt;typename T, template&lt;typename T&gt; class SmatPtr&gt;class XCls{private: SmatPtr&lt;T&gt; sp;public: XCls() : sp(new T) {}};XCls&lt;string, shared_ptr&gt; p1; // okXCls&lt;string, unique_ptr&gt; p2; // noXCls&lt;string, weak_ptr&gt; p3; // noXCls&lt;string, auto_ptr&gt; p4; // ok 这个不是 template template parametertemplate&lt;typename T, class Sequence = deque&lt;T&gt;&gt;class stack { passprotected: Sequence c;}stack&lt;int&gt; s1;stack&lt;int, list&lt;int&gt; &gt; s2; // 已经指定list&lt;int&gt; 关于 C++ 标准库 Iterator 迭代器Container 容器Algorithm 算法Functors 仿函数 查看标准库，并实验每一个已经实现的标准库功能。 C++11 新特性 variadic templates 数量不定的模板参数 (since C++11)template &lt;typename T, typename... Types&gt; // ... 也是语法的一部分void print (const T&amp; firstArg, const Types&amp;... args){ cout &lt;&lt; firstArg &lt;&lt; endl; // &lt;&lt; 须重载 print(args...); // 递归调用，每次分为firstArg和后面 Types... (其他的多个)}// 调用print(7.5, \"hello\", bitset&lt;16&gt;(337), 42);/*7.5hello000000010111100142*/// 通过 sizeof(args...) 可以得到后面一包是几个 auto 语法糖(since c++11)list&lt;string&gt; c;auto ite = find(c.begin(), c.end(), target); // 让编译器自动帮你推断类型，但前提是你得有assign语句，不然编译器不知道怎么推auto it; // 不能这样写，编译器不知道it是什么类型it = find(c.begin(), c.end(),target); // 错误 range-base for 语法糖(since C++11)for(auto i : container) // 逐个取出，copy到 i 上 (pass by value){ statement}for(auto &amp;i : container) // pass by reference 更改了container 中的值{ statement}for(int i : {0,1,2,3,4,5,6,7,8,9}) // 新语法{ cout &lt;&lt; i &lt;&lt; endl;} reference 引用(代表),实际上是指针实现的int x = 0;int* p = &amp;x; // p pointer to xint&amp; r = x; // r reference to x , r 代表 x, r 从一而终，不能再代表其它对象了int x2 = 5;// 编译器制造的假象cout &lt;&lt; (sizeof(r) == sizeof(x)) &lt;&lt; endl; // true 但其实 r 是一个指针cout &lt;&lt; (&amp;r == &amp;x) &lt;&lt; endl; // true 假象r = x2; // r 不能从新代表其它对象，只是把 r 代表的 x 的值变成 x2 的值罢了int&amp; r2 = r; // r2 reference to r (r2 代表 r, 亦相当于代表 x)// 不管是内置类型还是自定义类型都符合上述结论 reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)的描述. void func1(T *pobj) {pobj -&gt; xxx();}void func2(T pobj) {pobj.xxx();} // 须拷贝，传递较慢void func3(T&amp; pobj) {pobj.xxx();}T obj;func1(&amp;obj);// 调用接口不同，困扰func2(obj); // 调用接口相同，很好func3(obj);// 特别注意，写函数重载时，以下两种(same signature)不能并存double imag(const double&amp; im);double imag(const double im); // Ambiguous Q : const 是不是函数签名的一部分，即是否能作为重载的指标？A : 是！ Object Model 对象模型 Part I 的承接 Inheritance 继承： 构造由内而外，析构由外而内Composition 复合： 构造由内而外，析构由外而内Inheritance+Composition： 构造由内而外，析构由外而内 Derived::Derived(…) : Base(),Component() {…}Derived::~Derived() {… Component(); Base()} // 与构造相反 关于 vptr 和 vtbl (虚指针和虚表) 只要类中有虚函数，其对象在内存中就会多一根指针（指向虚表）父类有虚函数，子类对象也一定拥有该指针 class A {public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2();private: int m_data1, m_data2;};class B : public A {public: virtual void vfunc1(); // override void func2();private: int m_data3;};class C : public B {public: virtual void vfunc1(); // override void func2();private: int m_data1, m_data4;}; 内存模型： 动态绑定 C *p = new C;(*p).vfunc2();// 相当于,其中 n 表示虚表中的第 n 个虚函数(*(p-&gt;vptr)[n])(p);(* p-&gt;vptr[n] )(p); 应用：PPT 图形类(多态的应用) 总结：&emsp;C++ 编译器看到一个函数调用，会有两个考量（静态绑定，动态绑定) 静态绑定是被编译成: CALL xxxx(func address)。 但如果符合某些条件就会动态绑定： 通过指针调用 指针向上转型 up-cast 所调用的是虚函数(virtual func)动态绑定的形式：虚机制多态：指针具有很多的类型（型态） 关于 this pointer 设计分析继承体系时要对this pointer有一个清晰的认识对象调用成员函数时，该对象的this指正就会隐含地传入函数中下图中在对象调用OnFileOpen()时传入对象地址this，因此碰到虚函数Serialize()函数后，回去寻找CMyDoc类的虚函数表中的函数（动态绑定） 谈谈 const (const member function 常量成员函数) const 是属于函数签名的一部分 class Class {public: Class() {} int function() const {return mem;} // 保证不更改 mem int function() {return mem;}private: int mem;}; const object(datamember不可变动) non-const object(datamem可变动) const member functions(保证datamenber不变) YES YES non-const member functions(不保证datamember不变) 无法调用 YES 当成员函数的 const 和 non-const 版本同时存在时，const Object 只会调用 const 版本，non-const Object 只会调用 non-const 版本 关于 new , delete. array new , array delete.(重载)Part I 承接： 全局重载形式 成员重载形式 new 分解为 3 个动作delete 分解为 2 个动作接管内存的分配和释放的行为 示例， 接口#ifndef __FOO__#define __FOO__#include &lt;iostream&gt;#include &lt;string&gt;class Foo { public: int _id; long _data; string _str; public: Foo() : _id(0) {std::cout &lt;&lt; \"default ctor. this = \" &lt;&lt; this &lt;&lt; \"id = \" &lt;&lt; _id &lt;&lt; std::endl;} Foo(int id) : _id(id) {cout &lt;&lt; \"ctor. this = \" &lt;&lt; this &lt;&lt; \"id = \" &lt;&lt; _id &lt;&lt; std::endl;} //virtual // 可选的 virtual 关键字 ~Foo() {std::cout &lt;&lt; \"dtor. this = \" &lt;&lt; this &lt;&lt; \"id = \" &lt;&lt; _id &lt;&lt; std::endl;} static void* operator new(size_t size); static void* operator delete(void* phead, size_t size); static void* operator new[](size_t size); static void* operator delete[](void* phead, size_t size);};void* Foo::operator new(size_t size){ Foo* p = (Foo*) malloc(size); std::cout &lt;&lt; \"Foo:new has been called.\" &lt;&lt; std::endl; return p;}void* Foo::operator delete(void* phead,size_t size){ std::cout &lt;&lt; \"Foo:delete has been called.\" &lt;&lt; std::endl; free(phead);}void* Foo::operator new[](size_t size){ Foo* p = (Foo*) malloc(size); std::cout &lt;&lt; \"Foo:new[] has been called.\" &lt;&lt; std::endl; return p;}void Foo::operator delete[](void* phead, size_t size){ std::cout &lt;&lt; \"Foo:delete[] has been called.\" &lt;&lt; std::endl; free(phead);}#endif // END DEFINE 测试：#include &lt;iostream&gt;#include \"Foo.h\"using namespace std;int main(){ cout &lt;&lt; \"sizeof(Foo) = \" &lt;&lt; sizeof(Foo) &lt;&lt; endl; Foo *p = new Foo(7); delete p; cout &lt;&lt; \"============================================\" &lt;&lt; endl; Foo* pArray = new Foo[5]; delete[] pArray; cout &lt;&lt; \"********************************************\" &lt;&lt; endl; // 强制全局,不会进入重载函数 Foo* _p = ::new Foo(7); ::delete[] _p; cout &lt;&lt; \"============================================\" &lt;&lt; endl; // 强制全局 Foo *_pArray = new Foo[5]; ::delete[] _pArray; return 0;}","link":"/2019/11/13/侯捷C++学习笔记[未整理版]/"},{"title":"博客迁移后的发布测试","text":"测试文章发布是否正常 迁移过程之后会整理出来，急需要的话可以留言。","link":"/2019/03/05/博客迁移后的发布测试/"},{"title":"快速排序及其改进","text":"快速排序 简单快速排序算法template&lt;class Type&gt;int Partition(Type a[], int p, int r){ int i = p, j = r+1; Type x = a[p]; // 确定主元 // 划分 while(true) { while(a[++i] &lt; x &amp;&amp; i &lt; r); // 从左往右寻找比 x 大的元素 while(a[--j] &gt; x); // 从右往左寻找比 x 小的元素 if(i &gt;= j) break; swap(a[i], a[j]); // 交换 } a[p] = a[j]; // j 最终停留在一个比 x 小的数上面 a[j] = x; // 将主元放到最终位置 return j; // 返回枢轴元素下标}template&lt;class Type&gt;void QuickSort(Type a[], int p, int r){ if(p &lt; r) // 递归出口，只有一个元素时 { int q = Partition(a, p, r); // 得到划分位置 QuickSort(a, p, q-1); // 排序左子序列 QuickSort(a, q+1, r); // 排序右子序列 }}//----------------------------------------------------------------------------------- 快速排序在平均情况下时间复杂度为 O(nlog n) 最坏情况下(如待排序列有序)为 O(n^2) 要使得在最坏情况下时间复杂度为 O(nlog n) 容易看到，快速排序的性能取决于划分的 对称性 可以每次都将问题划分为相等规模的两个子问题 即 T(n) = 2T(n/2) + n 由主定理解得 T(n) = O(nlog n) 因此可以用一个算法选取当前序列的中位数将其作为主元(pivot)，将子问题划分为原问题的一半规模 随机选择快速排序算法// 随机选择快速排序算法在当数组还没有被划分时随机第从 a[p:r] 中选择主元作为划分基准// 从而可以期望划分是较对称的int Random(int p, int r){ return (rand() % (r-p+1))+ p; // 生成 [p,r] 区间内的随机整数}template&lt;class Type&gt;int RandomizedPartition(Type a[], int p, int r){ int i = Random(p, r); // 产生一个属于 [p:r] 区间的随机数 swap(a[i], a[p]); return Partition(a, p, r); // 调用划分函数}template&lt;class Type&gt;void RandomizedQuickSort(Type a[], int p, int r){ if(p &lt; r) { int q = RandomizedPartition(a, p, r); // 随机划分 RandomizedQuickSort(a, p, q-1); // 排序左子序列 RandomizedQuickSort(a, q+1, r); // 排序右子序列 }} 随机线性时间选择算法// 由于RandomizedSelect中使用了RandomizedPartition产生的划分基准是随机的// 在这个条件下可以证明，算法RandomizedSelect可以在 O(n) 的平均时间内找出n个输入的第 k 小元素// 但其在最坏情况下的时间复杂度为 O(n^2),比如在找最小元素时(k=1),总是在最大元素处划分template&lt;class Type&gt; Type RandomizedSelect(Type a[], int p, int r, int k) // 返回第 k 小的数 { if(p == r) return a[p]; int i = RandomizedPartition(a, p, r); // 随机划分 int j = i - p + 1; // 计算前半部分子序列长度 if(k &lt;= j) // 如果 j &gt;= k ,说明第 k 小的元素在前半部分 return RandomizedSelect(a, p, i, k); else // 否则, 第 k 小的元素在右半部分 return RandomizedSelect(a, i+1, r, k-j); // 从右半部分中寻找第 k - j 小的元素 } 线性时间选择算法下面讨论一个最坏情况下可以在 O(n) 时间内找到第 k 小的元素的线性时间选择算法// /* * 1. 将 n 个元素划分成 n/5 个分组， 每组 5 个元素， 除可能有一个组不是 5 个元素外。用任意一种排序算法， * 将每组中的元素排好序，并去除每组的中位数，共 n/5 个。 * 2. 递归调用 Select 函数找出这 n/5 个元素的中位数。 如果 n/5 为偶数，就找他的两个中位数中较大的一个 * 然后以这个元素作为划分基准。 */void insertSort(int a[], int p, int r) // 插入排序{ for (int i = p+1; i &lt;= r; i++) { for (int j = i - 1; j &gt;= 0 &amp;&amp; a[j + 1] &lt; a[j]; j--) { swap(a[j], a[j + 1]); } } }template&lt;class Type&gt;Type Select(Type a[], int p, int r, int k){ if(r - p &lt; 75) { insertSort(a,p,r); // 简单插入排序 return a[p+k-1]; // 返回中位数 } for(int i = 0; i &lt;= (r-p-4)/5; ++i) { // 将 a[p + 5 * i] 至 a[p + 5 * i + 4] 的第三小元素与 a[p + i] 交换位置 Type x = Select(a, p, p + (r-p-4)/5, (r-p-4)/10); // 找出中位数中的中位数，r-p-4 即为 n-5 int m = Partition(a, p, r, x) , j = i - p + 1; if(k &lt;= j) return Select(a, p, m, k); else return Select(a, m+1, r, k-j); }} 三路划分快速排序template&lt;class Type&gt;void QuickSort3Way(Type a[], int left, int right){ if(left &lt; right) { Type x = a[right]; // 取尾元素为主元(基准) // i 指向序列头元素的前一个元素(不存在) // j 指向序列尾元素 // p 与 i 相同 // q 与 j 相同 int i = left - 1, j = right, p = left - 1, q = right; // 开始划分 while(1) { while( a[++i] &lt; x ); // 从左往右找大于x的元素 while( a[--j] &gt; x ) if( j == left ) break; // 从右往左找小于x的元素 if(i &lt; j) // i j 未交错 { swap(a[i], a[j]); // 交换 if(a[i] == x) { p++; swap( a[p], a[i] ); } // 将与主元相等的元素交换到两侧 if(a[j] == x) { q--; swap( a[q], a[j] ); } } else break; // i j 交错， i 为主元最终位置 } swap(a[i], a[right]); // 将主元交换到最终位置 j = i - 1; i = i + 1; // 此时 p，q 指向两侧与主元相等元素的最内侧元素 /* 如下图：x 为主元 x x x x x x x a d d t g e w x d i s e s x x x x | | | | p j i q */ for(int k = left; k &lt;= p; k++, j--) swap( a[k], a[j] ); // 将左侧相等元素交换到主元左边 for(int k = right - 1; k &gt;= q; k--, i++) swap( a[i], a[k] ); // 将右侧相等元素交换到主元右边 // 一次划分结束 QuickSort3Way(a, left, j); QuickSort3Way(a, i, right); }}int main(){ int a[28] = {1,2,5,2,7,4,7,10,65,2,3,63,78,23,61,11,8,34,6,23,23,23,23,23,23,23,23,23}; //RandomizedQuickSort(a,0,19); time_t start, end; start = clock(); QuickSort3Way(a, 0, 28); end = clock(); cout &lt;&lt; 1.0 * (end - start)/CLOCKS_PER_SEC &lt;&lt; \" s \" &lt;&lt; endl; for(int i = 0;i &lt; 20;i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl;}","link":"/2019/11/19/快速排序及其改进/"},{"title":"感知机与逻辑门的实现","text":"感知机 &emsp;感知机（Perceptron）由两层神经元组成，输入层接收外界信号后传递给输出层，输出层是M-P神经元（如下图），亦称” 阙值逻辑单元（threshold logic unit）“。 逻辑门的实现 &emsp;感知机能容易地实现逻辑与、或、非、异或运算。注意到$y=f(\\sum_{i}{w_ix_i-\\theta})$,假定$f$为阶跃函数:$$sgn(x) = \\begin{cases}1, &amp; x&gt;= 0 \\\\0, &amp; x&lt;0\\end{cases}$$则有： 与门（$ x_1\\land x_2 $）：令$w_1=w_2=1,\\theta=1.5$,则$y=f(1\\cdot x_1+1\\cdot x_2-2)$,仅当$x_1=x_2=1$时，$y=1$ # python实现与门def AND(x1,x2): w1,w2,theta = 1.0,1.0,1.5 result = w1*x1 + w2*x2 - theta if result &gt;= 0: return 1 else: return 0 或门（$x_1\\lor x_2$）：令$w_1=w_2=1,\\theta=0.5$,则$y=f(1\\cdot x_1+1\\cdot x_2-0.5)$,仅当$x_1=1$或$x_2=1$时，$y=1$。 # python实现或门def OR(x1,x2): w1,w2,theta = 1.0,1.0,0.5 result = w1*x1 + w2*x2 - theta if result &gt;= 0: return 1 else: return 0 非门（$\\lnot x_1$）：令$w_1=-0.6$,$w_2=0,\\theta=-0.5$,则$y=f(-0.6\\cdot x_1+0\\cdot x_2+0.5)$,仅当$x_1=1$时，$y=0$；当$x_1=0$时，$y=1$。 # python 实现非门def NOT(x1): w1, theta = -0.6, -0.5 result = w1*x1 - theta if result &gt;= 0: return 1 else: return 0 与非门：令$w_1=w_2=-1,\\theta=-1.5$,则$y=f(1\\cdot x_1+1\\cdot x_2+1.5)$,仅当$x_1=x_2=1$时，$y=0$ # python 实现与非门def NAND(x1,x2): w1,w2,theta = -1.0,-1.0,-1.5 result = w1*x1 + w2*x2 - theta if result &gt;= 0: return 1 else: return 0 异或门（$x_1\\oplus x_2$）：异或门在生活中有很多用处，我们常常听到下面这句话：“这件事要么你来做，要么我来做”。意思是这件事只能由我们之间的任何一个人来做，其他都不行。又比如你房间中的灯的开关一般门口一个床头一个，这样子你每按下其中任何一个开关都只会有两种结果（变得与另一个一样，变得与另一个不一样）利用这两种结果就可以构成灯的开与关。 # python 实现异或门def ExOR(x1,x2): return AND(OR(x1,x2),NAND(x1,x2))","link":"/2019/06/01/感知机与逻辑门的实现/"},{"title":"深度学习-卷积神经网络(0)","text":"&emsp;作为本系列的第一篇文章，本文仅对卷积神经网络的工作过程做一个简单的介绍，并不涉及数学原理与推导。若想要深入了解数学原理，那么可以去查看相关文献或者我将会在之后更新相关内容的文章。 &emsp;阅读这篇文章前你最好对简单的神经网络有一定的了解，如果没有，可以参看博主的神经人工神经网络学习笔记系列文章。如果你已经做好了准备，那就让我们开始吧！ 什么是卷积神经网络？ &emsp;卷积神经网络（Convolutional Neural Network，CNN）是前馈人工神经网络的一种。在图像识别领域有着广泛的应用并且非常有效。当人们谈到计算机视觉时，通常都绕不开卷积神经网络。 计算机眼中的图像 &emsp;毫无疑问，你可以很快分辨下图中的动物是只猫。但在计算机“眼中”，它仅仅是一个数字序列。图像由一个个像素组成，每一个像素通常以RGB(Red,Green,Blue)三原色表示。但为了简化，我们使用灰度（0-255）表示，仅仅一个数字就可以表示（0：黑色 255：白色）。如此一来，对于一张$200\\times 200$像素的图片，在计算机眼中就为一个$200\\times 200$的矩阵，也即一个$40000$维的向量。 &emsp;计算机学习（训练）识别图像的过程就是将许多图片向量输入某种算法处理后将结果与目标值相比对，对误差进行修正直到结果输出令人满意为止。待训练结束后再给它看一个从未看过的图像它也能准确地识别图像的内容。&emsp;本系列文章我们将继续使用Mnist数据集来训练和测试神经网络。 LeNet框架（20世纪90年代） &emsp;LeNet框架是卷积神经网络的祖师爷LeCun在1998年提出的，用于解决手写数字识别的视觉任务。自那时起，CNN的最基本的架构就定下来了：卷积层、池化层、全连接层。本篇文章也将围绕该框架来进行卷积神经网络的介绍。 LeNet 卷积神经网络的工作过程 1、卷积运算： &emsp;顾名思义，卷积神经网络得名于“卷积”运算。在卷积神经网络中，卷积的主要目的是从目标图像中提取“特征”。通过使用输入数据中的小方块（矩阵分块）来学习图像特征，卷积运算保留了像素间的空间关系。&emsp;正如前文所说，每个图像都可以被计算机看成是一个像素值矩阵。现仅考虑一个$5\\times 5$像素的图像矩阵$W_{img}$： 再令一个$3\\times 3$的矩阵$W_{f}$： 将$3\\times 3$的矩阵在$5\\times 5$矩阵上移动并将对应位的数值相乘并求和，得到一个新的矩阵即为卷积运算后的特征值矩阵： &emsp;这个由特征值组成的矩阵被称为 卷积特征 或 特征映射 。而上述参与卷积运算的$3\\times 3$矩阵被称为 卷积滤波器 或 核 或 特征探测器 （以下统称滤波器，但是事实上过滤器的作用就是原始图像的 特征检测器）。上述例子中过滤器在图像矩阵上每次移动1个像素单位，称为 步幅 。 &emsp;不难发现，不同的滤波器作用于相同图像上会得到不同的特征映射，下图列出了一些滤波器的取值以及功能作用(边缘检测，锐化等)： &emsp;总的来说，一个滤波器在输入图像上移动（卷积操作）以生成特征映射。在同一张图像上，另一个滤波器的卷积生成了不同的特征图。需要注意到，卷积操作捕获原始图像中的局部依赖关系很重要。还要注意这两个不同的滤波器如何从同一张原始图像得到不同的特征图。请记住，以上图像和两个滤波器只是数值矩阵。&emsp;实际上，卷积神经网络在训练过程中会自己学习这些滤波器的值（尽管在训练过程之前我们仍需要指定诸如滤波器数目、大小，网络框架等参数）。我们拥有的滤波器数目越多，提取的图像特征就越多，我们的网络在识别新图像时效果就会越好。 特征映射（卷积特征）的大小由我们在执行卷积步骤之前需要决定的三个参数控制： 深度：深度对应于我们用于卷积运算的过滤器数量。在图6所示的网络中，我们使用三个不同的过滤器对初始的船图像进行卷积，从而生成三个不同的特征图。可以将这三个特征地图视为堆叠的二维矩阵，因此，特征映射的“深度”为3。 步幅：步幅是我们在输入矩阵上移动一次过滤器矩阵的像素数量。当步幅为1时，我们一次将过滤器移动1个像素。当步幅为2时，过滤器每次移动2个像素。步幅越大，生成的特征映射越小。 零填充：有时，将输入矩阵边界用零来填充会很方便，这样我们可以将过滤器应用于输入图像矩阵的边界元素。零填充一个很好的特性是它允许我们控制特征映射的大小。添加零填充也称为宽卷积，而不使用零填充是为窄卷积。 2、非线性操作（ReLU操作） &emsp;每次卷积操作之后，都会进行一次ReLU操作，其全称为修正线性单元（Rectified Linear Unit),是一种非线性操作。以下为修正线性函数的图像及表达式： $$f(x)=\\begin{cases}0, &amp; x&lt;0 \\\\x, &amp; otherwise\\end{cases}$$ &emsp;ReLU 是一个针对元素的操作（应用于每个像素），并将特征映射中的所有负像素值替换为零。ReLU 的目的是在卷积神经网络中引入非线性因素，因为在实际生活中我们想要用神经网络学习的数据大多数都是非线性的（卷积是一个线性运算 —— 按元素进行矩阵乘法和加法，所以我们希望通过引入 ReLU 这样的非线性函数来解决非线性问题）。从可以很清楚地理解 ReLU 操作。它展示了将 ReLU 作用于某个特征映射得到的结果。这里的输出特征映射也被称为“修正”特征映射。 其他非线性函数如 Sigmoid 或 tanh 也能达到类似效果，但是 ReLU 函数的效果是最好的。 3、池化（Pooling） &emsp;空间池化（也称为子采样或下采样）可降低每个特征映射的维度，并保留最重要的信息。空间池化有几种不同的方式：最大值，平均值，求和等。 &emsp;在最大池化的情况下，我们定义一个空间邻域（例如一个2 × 2窗口），并取修正特征映射在该窗口内最大的元素。当然我们也可以取该窗口内所有元素的平均值（平均池化）或所有元素的总和。在实际运用中，最大池化 的表现更好。&ensp;下图展示了通过2 × 2窗口在修正特征映射（卷积+ ReLU 操作后得到）上应用最大池化操作的示例: &emsp;我们将2 x 2窗口移动2个单元格（也称为“步幅”），并取每个区域中的最大值。如图9所示，这样就降低了特征映射的维度,变成了一个$2\\times 2$的矩阵。&emsp;由于池化操作分别应用于每个特征映射（因此，我们从三个输入映射中得到了三个输出映射）。 两种池化方法的结果对比： &emsp;池化的作用是逐步减少输入的空间大小。具体来说有以下四点： 使输入（特征维度）更小，更易于管理 减少网络中的参数和运算次数，因此可以控制过拟合 使网络对输入图像微小的变换、失真和平移更加稳健（输入图片小幅度的失真不会改池化的输出结果 —— 因为我们取了邻域的最大值/平均值） 可以得到尺度几乎不变的图像（确切的术语是“等变”）。这是非常有用的，这样无论图片中的物体位于何处，我们都可以检测到 &emsp;目前为止，我们已经了解了卷积神经网络中 卷积、ReLU、池化 的工作原理。这一点非常重要，下面我们将举例来描述这一过程。 可视化卷积神经网络 &emsp;Adam Harley 创建了一个基于 MNIST 手写数字数据集训练卷积神经网络的可视化。我强烈推荐大家 使用它来了解卷积神经网络的工作细节。其链接如下,可以自行尝试： 2D Visualization of a Convolutional Neural Network. 1、卷积层&emsp;将鼠标放在卷积层的某个像素点上并点击会出现： 2、池化层 3、全连接层&emsp;全连接层的每一个结点都与其前一层的每一个结点相连接。 &emsp;该可视化项目还有3D版的，大家可以去玩玩，对于加深理解很有帮助。 卷积神经网络如何学习？ Waiting for update …","link":"/2019/06/19/机器学习-卷积神经网络介绍(0)/"}],"tags":[{"name":"djset","slug":"djset","link":"/tags/djset/"},{"name":"ML","slug":"ML","link":"/tags/ML/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Knapsack","slug":"Knapsack","link":"/tags/Knapsack/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"QuickSort","slug":"QuickSort","link":"/tags/QuickSort/"}],"categories":[{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"机器学习","slug":"机器学习","link":"/categories/机器学习/"},{"name":"教程","slug":"教程","link":"/categories/教程/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"底层原理","slug":"底层原理","link":"/categories/底层原理/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}