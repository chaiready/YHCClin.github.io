<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞鱼の博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ccyh.xyz/"/>
  <updated>2019-05-30T07:37:05.817Z</updated>
  <id>https://www.ccyh.xyz/</id>
  
  <author>
    <name>AokiLin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo-icarus修改文章详情页</title>
    <link href="https://www.ccyh.xyz/2019/05/01/Hexo-icarus%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E9%A1%B5/"/>
    <id>https://www.ccyh.xyz/2019/05/01/Hexo-icarus修改文章详情页/</id>
    <published>2019-05-01T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么修改？"><a href="#为什么修改？" class="headerlink" title="为什么修改？"></a>为什么修改？</h2><a id="more"></a><p>由于Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局。但是三栏布局限制了文章内容的展示，因此试图将其改为两栏布局。</p><hr><h2 id="通过修改源代码来达成目标"><a href="#通过修改源代码来达成目标" class="headerlink" title="通过修改源代码来达成目标"></a>通过修改源代码来达成目标</h2><p>打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">col</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!is_post())&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> main_column_class();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'is-6-tablet is-6-desktop is-9-widescreen'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>再section标签中做如下改动：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"section"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"columns"</span>&gt;</span></span><br><span class="line">                <span class="hljs-comment">&lt;!-- 将main_column_class() 改为 col() --&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column &lt;%= col() %&gt; has-order-2 column-main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">body</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">left</span>' &#125;) %&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">right</span>' &#125;) %&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。<br>通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。</p><p>为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。<br>将代码全选复制，再粘贴于末尾，做如下修改3处代码：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-keyword">if</span> (get_widgets(position).length &amp;&amp; !is_post()) &#123; %&gt;        <span class="hljs-xml"><span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-1' : 'has-order-3';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!-- 粘贴的部分 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">position</span> === <span class="hljs-string">'left'</span> &amp;&amp; <span class="hljs-attr">is_post</span>()) &#123; %&gt;</span>                          <span class="hljs-comment">&lt;!-- 修改，可选保留的栏 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-3' : 'has-order-1';       <span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure></p><hr><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>我这里保存的是左边栏，若要保存右边栏可以在 widget.ejs 文件中更改（已标识）。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>见本站！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么修改？&quot;&gt;&lt;a href=&quot;#为什么修改？&quot; class=&quot;headerlink&quot; title=&quot;为什么修改？&quot;&gt;&lt;/a&gt;为什么修改？&lt;/h2&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo用MathJax渲染数学公式</title>
    <link href="https://www.ccyh.xyz/2019/04/30/Hexo%E7%94%A8MathJax%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.ccyh.xyz/2019/04/30/Hexo用MathJax渲染数学公式/</id>
    <published>2019-04-30T17:24:31.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更改默认Markdown渲染引擎"><a href="#更改默认Markdown渲染引擎" class="headerlink" title="更改默认Markdown渲染引擎"></a>更改默认Markdown渲染引擎</h2><a id="more"></a><p>Hexo的默认Markdown渲染引擎为hexo-renderer-marked，将其替换为hexo-renderer-kramed,对于这一步，网上的大部分教程是这么干的：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><p>也就是先卸载掉默认引擎，再安装新引擎。但是我的npm出了问题，而且我个人觉得npm实在是不好用，因此我下载了yarn，并执行：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-renderer-marked</span><br><span class="line">yarn add hexo-renderer-kramed</span><br></pre></td></tr></table></figure></p><p>但当我执行hexo clean时却出现了类似下面的错误：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">Error: hexo-renderer-marked is not installed , please install ....</span><br></pre></td></tr></table></figure></p><p>所以一直无法成功。<br>后来我想干脆不卸载marked渲染引擎，直接安装kramed：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-kramed</span><br></pre></td></tr></table></figure></p><hr><h2 id="安装MathJax"><a href="#安装MathJax" class="headerlink" title="安装MathJax"></a>安装MathJax</h2><p>卸载hexo-math：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-math</span><br></pre></td></tr></table></figure></p><p>再安装hexo-renderer-mathjax：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-mathjax -S</span><br></pre></td></tr></table></figure></p><hr><h2 id="解决行内公式语义冲突"><a href="#解决行内公式语义冲突" class="headerlink" title="解决行内公式语义冲突"></a>解决行内公式语义冲突</h2><p>在博客的根目录下找到$\color{red}{node_modules/kramed/lib/rules/inline.js}$<br>做如下两处更改：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inline = &#123;</span><br><span class="line">  <span class="hljs-comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,   第一处</span></span><br><span class="line">  <span class="hljs-built_in">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">  autolink: <span class="hljs-regexp">/^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/</span>,</span><br><span class="line">  url: noop,</span><br><span class="line">  html: <span class="hljs-regexp">/^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/</span>,</span><br><span class="line">  link: <span class="hljs-regexp">/^!?\[(inside)\]\(href\)/</span>,</span><br><span class="line">  reflink: <span class="hljs-regexp">/^!?\[(inside)\]\s*\[([^\]]*)\]/</span>,</span><br><span class="line">  nolink: <span class="hljs-regexp">/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/</span>,</span><br><span class="line">  reffn: <span class="hljs-regexp">/^!?\[\^(inside)\]/</span>,</span><br><span class="line">  strong: <span class="hljs-regexp">/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</span><br><span class="line">  <span class="hljs-comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,  第二处</span></span><br><span class="line">  em: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  code: <span class="hljs-regexp">/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/</span>,</span><br><span class="line">  br: <span class="hljs-regexp">/^ &#123;2,&#125;\n(?!\s*$)/</span>,</span><br><span class="line">  del: noop,</span><br><span class="line">  text: <span class="hljs-regexp">/^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/</span>,</span><br><span class="line">  math: <span class="hljs-regexp">/^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="更改Mathjax加载脚本"><a href="#更改Mathjax加载脚本" class="headerlink" title="更改Mathjax加载脚本"></a>更改Mathjax加载脚本</h2><p>找到$\color{red}{node-modules/hexo-renderer-mathjax/mathjax.html}$将最后一句改为：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>将改动部署到博客</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更改默认Markdown渲染引擎&quot;&gt;&lt;a href=&quot;#更改默认Markdown渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;更改默认Markdown渲染引擎&quot;&gt;&lt;/a&gt;更改默认Markdown渲染引擎&lt;/h2&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+icarus主题配置</title>
    <link href="https://www.ccyh.xyz/2019/04/29/Hexo+icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.ccyh.xyz/2019/04/29/Hexo+icarus主题配置/</id>
    <published>2019-04-29T17:31:10.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="下载icarus主题"><a href="#下载icarus主题" class="headerlink" title="下载icarus主题"></a>下载icarus主题</h2><ol><li>进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面<a id="more"></a></li><li><p>输入：</p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/ppoffice/hexo-theme-icarus themes/icarus</span><br></pre></td></tr></table></figure></li><li><p>打开themes文件夹，就会发现多了一个icarus文件夹，这就是主题的所有文件</p></li></ol><hr><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><ol><li><p>更改站点配置文件_config.yml,将主题改为icarus</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">theme:</span> <span class="hljs-string">icarus</span></span><br></pre></td></tr></table></figure></li><li><p>Icarus文件目录概览：<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429082811950.png" alt=""></p><blockquote><ul><li>$config.yml$是主题的配置文件</li><li>$/layout$ 文件夹中是主题各种模板文件</li><li>我们主要的超作就是在这两个文件中了</li></ul></blockquote></li></ol><hr><h3 id="主题配置文件（部分）"><a href="#主题配置文件（部分）" class="headerlink" title="主题配置文件（部分）"></a>主题配置文件（部分）</h3><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># Version of the Icarus theme that is currently used</span></span><br><span class="line"><span class="hljs-attr">version:</span> <span class="hljs-number">2.3</span><span class="hljs-number">.0</span></span><br><span class="line"><span class="hljs-comment"># 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中</span></span><br><span class="line"><span class="hljs-attr">favicon:</span> <span class="hljs-string">/images/favicons.ico</span></span><br><span class="line"><span class="hljs-comment"># Path or URL to RSS atom.xml</span></span><br><span class="line"><span class="hljs-attr">rss:</span> <span class="hljs-string">/atom.xml</span></span><br><span class="line"><span class="hljs-comment"># 显示在导航栏左侧的网站logo，同样可以自己制作</span></span><br><span class="line"><span class="hljs-attr">logo:</span> <span class="hljs-string">/images/gen.svg</span></span><br><span class="line"><span class="hljs-comment"># Open Graph metadata</span></span><br><span class="line"><span class="hljs-comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line"><span class="hljs-attr">open_graph:</span></span><br><span class="line">    <span class="hljs-comment"># Facebook App ID</span></span><br><span class="line"><span class="hljs-attr">    fb_app_id:</span> </span><br><span class="line">    <span class="hljs-comment"># Facebook Admin ID</span></span><br><span class="line"><span class="hljs-attr">    fb_admins:</span> </span><br><span class="line">    <span class="hljs-comment"># Twitter ID</span></span><br><span class="line"><span class="hljs-attr">    twitter_id:</span> </span><br><span class="line">    <span class="hljs-comment"># Twitter site</span></span><br><span class="line"><span class="hljs-attr">    twitter_site:</span> </span><br><span class="line">    <span class="hljs-comment"># Google+ profile link</span></span><br><span class="line"><span class="hljs-attr">    google_plus:</span> </span><br><span class="line"><span class="hljs-comment">#  导航栏</span></span><br><span class="line"><span class="hljs-attr">navbar:</span></span><br><span class="line">    <span class="hljs-comment">#菜单（显示名称：对应文件夹）</span></span><br><span class="line"><span class="hljs-attr">    menu:</span></span><br><span class="line">        <span class="hljs-string">主页:</span> <span class="hljs-string">/</span></span><br><span class="line">        <span class="hljs-string">归档:</span> <span class="hljs-string">/archives</span></span><br><span class="line">        <span class="hljs-string">分类:</span> <span class="hljs-string">/categories</span></span><br><span class="line">        <span class="hljs-string">标签:</span> <span class="hljs-string">/tags</span></span><br><span class="line">        <span class="hljs-string">关于:</span> <span class="hljs-string">/about</span>   </span><br><span class="line">    <span class="hljs-comment"># 导航栏右侧图标链接</span></span><br><span class="line"><span class="hljs-attr">    links:</span></span><br><span class="line">        <span class="hljs-string">My</span> <span class="hljs-attr">GitHub:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'你的gityhub地址'</span></span><br><span class="line"><span class="hljs-comment"># Footer section link settings</span></span><br><span class="line"><span class="hljs-attr">footer:</span></span><br><span class="line">    <span class="hljs-comment"># 页脚图标链接</span></span><br><span class="line"><span class="hljs-attr">    links:</span></span><br><span class="line">        <span class="hljs-string">Creative</span> <span class="hljs-attr">Commons:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'https://creativecommons.org/'</span></span><br><span class="line">        <span class="hljs-string">Attribution</span> <span class="hljs-number">4.0</span> <span class="hljs-attr">International:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons-by</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'https://creativecommons.org/licenses/by/4.0/'</span></span><br><span class="line">        <span class="hljs-string">Download</span> <span class="hljs-string">on</span> <span class="hljs-attr">GitHub:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'http://github.com/ppoffice/hexo-theme-icarus'</span></span><br><span class="line"><span class="hljs-comment"># 文章显示设置</span></span><br><span class="line"><span class="hljs-attr">article:</span></span><br><span class="line">    <span class="hljs-comment"># Code highlight theme</span></span><br><span class="line">    <span class="hljs-comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span></span><br><span class="line">    <span class="hljs-comment">#代码主题atom-one-light亮色，atom-one-dark暗色</span></span><br><span class="line"><span class="hljs-attr">    highlight:</span> <span class="hljs-string">atom-one-dark</span></span><br><span class="line">    <span class="hljs-comment"># 是否显示文章主图</span></span><br><span class="line"><span class="hljs-attr">    thumbnail:</span> <span class="hljs-literal">true</span></span><br><span class="line">    <span class="hljs-comment"># 是否显示估算阅读时间</span></span><br><span class="line"><span class="hljs-attr">    readtime:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 搜索插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Plugins</span></span><br><span class="line"><span class="hljs-attr">search:</span></span><br><span class="line">    <span class="hljs-comment"># Name of the search plugin</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">insight</span></span><br><span class="line"><span class="hljs-comment"># 评论插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Plugins</span></span><br><span class="line"><span class="hljs-attr">comment:</span></span><br><span class="line">    <span class="hljs-comment">#可选valine，disqus（科学上网）等</span></span><br><span class="line">    <span class="hljs-comment"># Name of the comment plugin</span></span><br><span class="line">    <span class="hljs-comment">#type: valine</span></span><br><span class="line">    <span class="hljs-comment">#app_id: 不为空</span></span><br><span class="line">    <span class="hljs-comment">#app_key: 不为空</span></span><br><span class="line">    <span class="hljs-comment">#notify: true</span></span><br><span class="line">    <span class="hljs-comment">#verify: true</span></span><br><span class="line">    <span class="hljs-comment">#placeholder:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">disqus</span></span><br><span class="line"><span class="hljs-attr">    shortname:</span> <span class="hljs-string">不能为空</span></span><br><span class="line"><span class="hljs-comment"># 打赏功能</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/</span></span><br><span class="line"><span class="hljs-attr">donate:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 阿里巴巴支付宝</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">alipay</span></span><br><span class="line">        <span class="hljs-comment"># 二维码图片</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">'/images/honbao.PNG'</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 微信</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">wechat</span></span><br><span class="line">        <span class="hljs-comment"># 二维码图片</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">'/images/yjtp.png'</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line"><span class="hljs-comment"># 分享插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Plugins</span></span><br><span class="line"><span class="hljs-attr">share:</span></span><br><span class="line">    <span class="hljs-comment"># 插件类型，有多种，可选，自行百度</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">sharejs</span></span><br><span class="line"><span class="hljs-comment"># Sidebar settings.</span></span><br><span class="line"><span class="hljs-comment"># Please be noted that a sidebar is only visible when it has at least one widget</span></span><br><span class="line"><span class="hljs-attr">sidebar:</span></span><br><span class="line">    <span class="hljs-comment"># 左侧边栏设置</span></span><br><span class="line"><span class="hljs-attr">    left:</span></span><br><span class="line">        <span class="hljs-comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line"><span class="hljs-attr">        sticky:</span> <span class="hljs-literal">false</span></span><br><span class="line">    <span class="hljs-comment"># 右侧边栏设置</span></span><br><span class="line"><span class="hljs-attr">    right:</span></span><br><span class="line">        <span class="hljs-comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line"><span class="hljs-attr">        sticky:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 边栏小部件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/</span></span><br><span class="line"><span class="hljs-attr">widgets:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 个人信息</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">profile</span></span><br><span class="line">        <span class="hljs-comment"># 部件位置（左）</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line">        <span class="hljs-comment"># 作者名（字符串）</span></span><br><span class="line"><span class="hljs-attr">        author:</span> <span class="hljs-string">飞鱼</span></span><br><span class="line">        <span class="hljs-comment"># 作者身份描述（字符串）</span></span><br><span class="line"><span class="hljs-attr">        author_title:</span> <span class="hljs-string">Student</span></span><br><span class="line">        <span class="hljs-comment"># 作者当前居住地</span></span><br><span class="line"><span class="hljs-attr">        location:</span> <span class="hljs-string">China,Fujian</span></span><br><span class="line">        <span class="hljs-comment"># 头像（可用本地图片或网络图片链接）</span></span><br><span class="line"><span class="hljs-attr">        avatar:</span> <span class="hljs-string">'/images/ava.png'</span></span><br><span class="line">        <span class="hljs-comment"># Email address for the Gravatar to be shown in the profile widget</span></span><br><span class="line"><span class="hljs-attr">        gravatar:</span> </span><br><span class="line">        <span class="hljs-comment"># 关注我的链接，可设为你的GitHub主页</span></span><br><span class="line"><span class="hljs-attr">        follow_link:</span> <span class="hljs-string">'https://github.com/yourname'</span></span><br><span class="line">        <span class="hljs-comment"># 个人介绍部件底部图标社交链接</span></span><br><span class="line"><span class="hljs-attr">        social_links:</span></span><br><span class="line"><span class="hljs-attr">            Github:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://github.com/yourname'</span></span><br><span class="line"><span class="hljs-attr">            Facebook:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-facebook</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://facebook.com'</span></span><br><span class="line"><span class="hljs-attr">            Twitter:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-twitter</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://twitter.com/yourname'</span></span><br><span class="line"><span class="hljs-attr">            RSS:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fas</span> <span class="hljs-string">fa-rss</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">/</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># Widget name</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">toc</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 分类</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">category</span></span><br><span class="line">        <span class="hljs-comment"># 位置指定</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 标签云</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">tagcloud</span></span><br><span class="line">        <span class="hljs-comment"># 位置</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 近期文章</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">recent_posts</span></span><br><span class="line">        <span class="hljs-comment"># 位置</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 归档</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">archive</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 标签</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">tag</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 外部链接</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">links</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line">        <span class="hljs-comment"># Links to be shown in the links widget</span></span><br><span class="line"><span class="hljs-attr">        links:</span></span><br><span class="line"><span class="hljs-attr">            Google:</span> <span class="hljs-string">'https://google.com'</span></span><br><span class="line"><span class="hljs-attr">            Baidu:</span> <span class="hljs-string">'https://baidu.com'</span></span><br></pre></td></tr></table></figure><p>上述设置已经让你的博客稍微有点属于你的样子了，下面来添加一些有意思的元素。</p><hr><h3 id="添加雪花飘落效果"><a href="#添加雪花飘落效果" class="headerlink" title="添加雪花飘落效果"></a>添加雪花飘落效果</h3><ul><li>在 $\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$目录下新建一个 snow.js 文件(若没有src/文件夹可以自己新建)，复制粘贴以下代码：<br><strong> 样式1：六边形雪花 </strong><figure class="highlight javascript hljs"><table><tr><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>)</span>&#123;</span><br><span class="line">$.fn.snow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> $flake = $(<span class="hljs-string">''</span>).css(&#123;<span class="hljs-string">'position'</span>: <span class="hljs-string">'absolute'</span>,<span class="hljs-string">'z-index'</span>:<span class="hljs-string">'9999'</span>, <span class="hljs-string">'top'</span>: <span class="hljs-string">'-50px'</span>&#125;).html(<span class="hljs-string">'❄'</span>),</span><br><span class="line">documentHeight = $(<span class="hljs-built_in">document</span>).height(),</span><br><span class="line">documentWidth= $(<span class="hljs-built_in">document</span>).width(),</span><br><span class="line">defaults = &#123;</span><br><span class="line">minSize: <span class="hljs-number">10</span>,</span><br><span class="line">maxSize: <span class="hljs-number">20</span>,</span><br><span class="line">newOn: <span class="hljs-number">1000</span>,</span><br><span class="line">flakeColor: <span class="hljs-string">"#AFDAEF"</span> <span class="hljs-comment">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span></span><br><span class="line">&#125;,</span><br><span class="line">options= $.extend(&#123;&#125;, defaults, options);</span><br><span class="line"><span class="hljs-keyword">var</span> interval= setInterval( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> startPositionLeft = <span class="hljs-built_in">Math</span>.random() * documentWidth - <span class="hljs-number">100</span>,</span><br><span class="line">startOpacity = <span class="hljs-number">0.5</span> + <span class="hljs-built_in">Math</span>.random(),</span><br><span class="line">sizeFlake = options.minSize + <span class="hljs-built_in">Math</span>.random() * options.maxSize,</span><br><span class="line">endPositionTop = documentHeight - <span class="hljs-number">200</span>,</span><br><span class="line">endPositionLeft = startPositionLeft - <span class="hljs-number">500</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">500</span>,</span><br><span class="line">durationFall = documentHeight * <span class="hljs-number">10</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5000</span>;</span><br><span class="line">$flake.clone().appendTo(<span class="hljs-string">'body'</span>).css(&#123;</span><br><span class="line">left: startPositionLeft,</span><br><span class="line">opacity: startOpacity,</span><br><span class="line"><span class="hljs-string">'font-size'</span>: sizeFlake,</span><br><span class="line">color: options.flakeColor</span><br><span class="line">&#125;).animate(&#123;</span><br><span class="line">top: endPositionTop,</span><br><span class="line">left: endPositionLeft,</span><br><span class="line">opacity: <span class="hljs-number">0.2</span></span><br><span class="line">&#125;,durationFall,<span class="hljs-string">'linear'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">$(<span class="hljs-keyword">this</span>).remove()</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, options.newOn);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    $.fn.snow(&#123; </span><br><span class="line">    minSize: <span class="hljs-number">5</span>, <span class="hljs-comment">/* 定义雪花最小尺寸 */</span></span><br><span class="line">    maxSize: <span class="hljs-number">50</span>,<span class="hljs-comment">/* 定义雪花最大尺寸 */</span></span><br><span class="line">    newOn: <span class="hljs-number">300</span>  <span class="hljs-comment">/* 定义密集程度，数字越小越密集 */</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">作者：donlex</span><br><span class="line">链接：http:<span class="hljs-comment">//www.imooc.com/article/272005</span></span><br></pre></td></tr></table></figure></li></ul><p><strong> 样式2：圆点状雪花 </strong><br><figure class="highlight javascript hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snowFall</span>(<span class="hljs-params">snow</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 可配置属性 */</span></span><br><span class="line">    snow = snow || &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.maxFlake = snow.maxFlake || <span class="hljs-number">200</span>;   <span class="hljs-comment">/* 最多片数 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.flakeSize = snow.flakeSize || <span class="hljs-number">10</span>;  <span class="hljs-comment">/* 雪花形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.fallSpeed = snow.fallSpeed || <span class="hljs-number">1</span>;   <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 兼容写法 */</span></span><br><span class="line">requestAnimationFrame = <span class="hljs-built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>&#123; setTimeout(callback, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>); &#125;;</span><br><span class="line"></span><br><span class="line">cancelAnimationFrame = <span class="hljs-built_in">window</span>.cancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.mozCancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.webkitCancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.msCancelAnimationFrame ||</span><br><span class="line"><span class="hljs-built_in">window</span>.oCancelAnimationFrame;</span><br><span class="line"><span class="hljs-comment">/* 开始下雪 */</span></span><br><span class="line">snowFall.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 创建画布 */</span></span><br><span class="line">    snowCanvas.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-comment">/* 创建雪花形状 */</span></span><br><span class="line">    createFlakes.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-comment">/* 画雪 */</span></span><br><span class="line">    drawSnow.apply(<span class="hljs-keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 创建画布 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snowCanvas</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 添加Dom结点 */</span></span><br><span class="line">    <span class="hljs-keyword">var</span> snowcanvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"canvas"</span>);</span><br><span class="line">    snowcanvas.id = <span class="hljs-string">"snowfall"</span>;</span><br><span class="line">    snowcanvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><br><span class="line">    snowcanvas.height = <span class="hljs-built_in">document</span>.body.clientHeight;</span><br><span class="line">    snowcanvas.setAttribute(<span class="hljs-string">"style"</span>, <span class="hljs-string">"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"</span>);</span><br><span class="line">    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>)[<span class="hljs-number">0</span>].appendChild(snowcanvas);</span><br><span class="line">    <span class="hljs-keyword">this</span>.canvas = snowcanvas;</span><br><span class="line">    <span class="hljs-keyword">this</span>.ctx = snowcanvas.getContext(<span class="hljs-string">"2d"</span>);</span><br><span class="line">    <span class="hljs-comment">/* 窗口大小改变的处理 */</span></span><br><span class="line">    <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        snowcanvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><br><span class="line">        <span class="hljs-comment">/* snowcanvas.height = window.innerHeight */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 雪运动对象 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakeMove</span>(<span class="hljs-params">canvasWidth, canvasHeight, flakeSize, fallSpeed</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * canvasWidth);   <span class="hljs-comment">/* x坐标 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.y = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * canvasHeight);  <span class="hljs-comment">/* y坐标 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-built_in">Math</span>.random() * flakeSize + <span class="hljs-number">2</span>;          <span class="hljs-comment">/* 形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.maxSize = flakeSize;                           <span class="hljs-comment">/* 最大形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.speed = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span> + fallSpeed;         <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.fallSpeed = fallSpeed;                         <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed;                             <span class="hljs-comment">/* Y方向速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velX = <span class="hljs-number">0</span>;                                      <span class="hljs-comment">/* X方向速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.stepSize = <span class="hljs-built_in">Math</span>.random() / <span class="hljs-number">30</span>;                 <span class="hljs-comment">/* 步长 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.step = <span class="hljs-number">0</span>                                       <span class="hljs-comment">/* 步数 */</span></span><br><span class="line">&#125;</span><br><span class="line">flakeMove.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>.x,</span><br><span class="line">        y = <span class="hljs-keyword">this</span>.y;</span><br><span class="line">    <span class="hljs-comment">/* 左右摆动(余弦) */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velX *= <span class="hljs-number">0.98</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.velY &lt;= <span class="hljs-keyword">this</span>.speed) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velX += <span class="hljs-built_in">Math</span>.cos(<span class="hljs-keyword">this</span>.step += <span class="hljs-number">.05</span>) * <span class="hljs-keyword">this</span>.stepSize;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">this</span>.y += <span class="hljs-keyword">this</span>.velY;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x += <span class="hljs-keyword">this</span>.velX;</span><br><span class="line">    <span class="hljs-comment">/* 飞出边界的处理 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.x &gt;= canvas.width || <span class="hljs-keyword">this</span>.x &lt;= <span class="hljs-number">0</span> || <span class="hljs-keyword">this</span>.y &gt;= canvas.height || <span class="hljs-keyword">this</span>.y &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.reset(canvas.width, canvas.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">/* 飞出边界-放置最顶端继续坠落 */</span></span><br><span class="line">flakeMove.prototype.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * width);</span><br><span class="line">    <span class="hljs-keyword">this</span>.y = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.maxSize + <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.speed = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span> + <span class="hljs-keyword">this</span>.fallSpeed;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velX = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 渲染雪花-随机形状（此处可修改雪花颜色！！！）</span></span><br><span class="line">flakeMove.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> snowFlake = ctx.createRadialGradient(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-keyword">this</span>.size);</span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">"rgba(255, 255, 255, 0.9)"</span>);  <span class="hljs-comment">/* 此处是雪花颜色，默认是白色 */</span></span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">.5</span>, <span class="hljs-string">"rgba(255, 255, 255, 0.5)"</span>); <span class="hljs-comment">/* 若要改为其他颜色，请自行查 */</span></span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">"rgba(255, 255, 255, 0)"</span>);    <span class="hljs-comment">/* 找16进制的RGB 颜色代码。 */</span></span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.fillStyle = snowFlake;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-keyword">this</span>.size, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    ctx.restore();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">/* 创建雪花-定义形状 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFlakes</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> maxFlake = <span class="hljs-keyword">this</span>.maxFlake,</span><br><span class="line">        flakes = <span class="hljs-keyword">this</span>.flakes = [],</span><br><span class="line">        canvas = <span class="hljs-keyword">this</span>.canvas;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; maxFlake; i++) &#123;</span><br><span class="line">        flakes.push(<span class="hljs-keyword">new</span> flakeMove(canvas.width, canvas.height, <span class="hljs-keyword">this</span>.flakeSize, <span class="hljs-keyword">this</span>.fallSpeed))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 画雪 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawSnow</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> maxFlake = <span class="hljs-keyword">this</span>.maxFlake,</span><br><span class="line">        flakes = <span class="hljs-keyword">this</span>.flakes;</span><br><span class="line">    ctx = <span class="hljs-keyword">this</span>.ctx, canvas = <span class="hljs-keyword">this</span>.canvas, that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-comment">/* 清空雪花 */</span></span><br><span class="line">    ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>; e &lt; maxFlake; e++) &#123;</span><br><span class="line">        flakes[e].update();</span><br><span class="line">        flakes[e].render(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/*  一帧一帧的画 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.loop = requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        drawSnow.apply(that);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 调用及控制方法 */</span></span><br><span class="line"><span class="hljs-keyword">var</span> snow = <span class="hljs-keyword">new</span> snowFall(&#123;<span class="hljs-attr">maxFlake</span>:<span class="hljs-number">60</span>&#125;);</span><br><span class="line">snow.start();</span><br><span class="line"></span><br><span class="line">作者：donlex</span><br><span class="line">链接：http:<span class="hljs-comment">//www.imooc.com/article/272005</span></span><br></pre></td></tr></table></figure></p><ul><li><p>最后在$\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$的$body$标签中添加代码：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- 雪花特效 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">var</span> windowWidth = $(<span class="hljs-built_in">window</span>).width();</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">if</span> (windowWidth &gt; <span class="hljs-number">480</span>) &#123;</span></span><br><span class="line"><span class="hljs-xml">        document.write('<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/src/snow.js"</span>&gt;</span><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">\</span>/<span class="hljs-attr">script</span>&gt;</span>');</span></span></span><br><span class="line"><span class="hljs-undefined">      &#125;</span></span><br><span class="line"><span class="hljs-undefined">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认雪花为白色，可自行更改颜色，效果可见本站</p></li></ul><hr><h3 id="网站访问量与访客量统计"><a href="#网站访问量与访客量统计" class="headerlink" title="网站访问量与访客量统计"></a>网站访问量与访客量统计</h3><ul><li>不蒜子官网：<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">http://busuanzi.ibruce.info/</a></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$模板文件的中添加如下代码：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_pv"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"theme-info"</span>&gt;</span></span><br><span class="line">  |  本站总访问量<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_pv"</span>&gt;</span>span&gt;次</span><br><span class="line"> span&gt;</span><br><span class="line"> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_uv"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"theme-info"</span>&gt;</span></span><br><span class="line">  |  本站访客数<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_uv"</span>&gt;</span>span&gt;人次</span><br><span class="line"> span&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="hljs-undefined">script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/_config.yml}$中添加：</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">busuanzi:</span></span><br><span class="line"><span class="hljs-attr">    enable:</span> <span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>最终效果：<br><div align="center"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429093801600.png" alt=""><br></div></p><h3 id="网站运行时间统计"><a href="#网站运行时间统计" class="headerlink" title="网站运行时间统计"></a>网站运行时间统计</h3></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$中添加：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"timeDate"</span>&gt;</span>载入天数...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"times"</span>&gt;</span>载入时分秒...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">                <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); </span></span><br><span class="line"><span class="hljs-javascript">                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createtime</span>(<span class="hljs-params"></span>) </span>&#123; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-keyword">var</span> grt= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"12/28/2018 12:49:00"</span>);<span class="hljs-comment">//此处修改你的建站时间或者网站上线时间 </span></span></span><br><span class="line"><span class="hljs-undefined">                    now.setTime(now.getTime()+250); </span></span><br><span class="line"><span class="hljs-javascript">                    days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = <span class="hljs-built_in">Math</span>.floor(days); </span></span><br><span class="line"><span class="hljs-javascript">                    hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = <span class="hljs-built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(hnum).length ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum); </span></span><br><span class="line"><span class="hljs-javascript">                    mnum = <span class="hljs-built_in">Math</span>.floor(minutes); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(mnum).length ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">"0"</span> + mnum;&#125; </span></span><br><span class="line"><span class="hljs-undefined">                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span></span><br><span class="line"><span class="hljs-javascript">                    snum = <span class="hljs-built_in">Math</span>.round(seconds); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(snum).length ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">"0"</span> + snum;&#125; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"timeDate"</span>).innerHTML = <span class="hljs-string">"本站已安全运行 "</span>+dnum+<span class="hljs-string">" 天 "</span>; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"times"</span>).innerHTML = hnum + <span class="hljs-string">" 小时 "</span> + mnum + <span class="hljs-string">" 分 "</span> + snum + <span class="hljs-string">" 秒"</span>; </span></span><br><span class="line"><span class="hljs-undefined">                &#125; </span></span><br><span class="line"><span class="hljs-javascript">            setInterval(<span class="hljs-string">"createtime()"</span>,<span class="hljs-number">250</span>);</span></span><br><span class="line"><span class="hljs-undefined">            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改自己的建站时间</p></li><li>最终效果：<div align="center"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429094726470.png" alt=""><br></div></li></ul><hr><h3 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h3><ul><li><p>在 $\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$中添加click.js文件，复制以下代码进去：</p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        c(<span class="hljs-string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),</span><br><span class="line">        o(),</span><br><span class="line">        r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;d.length;e++)</span><br><span class="line">            d[e].alpha&lt;=<span class="hljs-number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="hljs-number">1</span>)):(d[e].y--,d[e].scale+=<span class="hljs-number">.004</span>,d[e].alpha-=<span class="hljs-number">.013</span>,d[e].el.style.cssText=<span class="hljs-string">"left:"</span>+d[e].x+<span class="hljs-string">"px;top:"</span>+d[e].y+<span class="hljs-string">"px;opacity:"</span>+d[e].alpha+<span class="hljs-string">";transform:scale("</span>+d[e].scale+<span class="hljs-string">","</span>+d[e].scale+<span class="hljs-string">") rotate(45deg);background:"</span>+d[e].color+<span class="hljs-string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> t=<span class="hljs-string">"function"</span>==<span class="hljs-keyword">typeof</span> e.onclick&amp;&amp;e.onclick;</span><br><span class="line">        e.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            t&amp;&amp;t(),i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">"div"</span>);</span><br><span class="line">            a.className=<span class="hljs-string">"heart"</span>,d.push(&#123;<span class="hljs-attr">el</span>:a,<span class="hljs-attr">x</span>:e.clientX<span class="hljs-number">-5</span>,<span class="hljs-attr">y</span>:e.clientY<span class="hljs-number">-5</span>,<span class="hljs-attr">scale</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">color</span>:s()&#125;),t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">"style"</span>);a.type=<span class="hljs-string">"text/css"</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">catch</span>(t)&#123;</span><br><span class="line">            a.styleSheet.cssText=e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span><span class="hljs-string">"rgb("</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">","</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">","</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> d=[];</span><br><span class="line">    e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            setTimeout(e,<span class="hljs-number">1e3</span>/<span class="hljs-number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(),</span><br><span class="line">    n()</span><br><span class="line">&#125;</span><br><span class="line">(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>);</span><br></pre></td></tr></table></figure></li><li><p>最后在$\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$文件中的</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>的下一行添加：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/src/click.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>效果见本站</p></li></ul><hr><h3 id="看板娘插件"><a href="#看板娘插件" class="headerlink" title="看板娘插件"></a>看板娘插件</h3><ul><li>在博客主目录下进入点击进入<strong>Git Bash Here</strong></li><li><p>输入命令：</p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure></li><li><p>在网站配置文件或主题配置文件$\color{green}{_config.yml}$中添加：</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">live2d:</span></span><br><span class="line"><span class="hljs-attr">  enable:</span> <span class="hljs-literal">true</span>                                   <span class="hljs-comment">#开启看板娘</span></span><br><span class="line"><span class="hljs-attr">  scriptFrom:</span> <span class="hljs-string">local</span></span><br><span class="line"><span class="hljs-attr">  pluginRootPath:</span> <span class="hljs-string">live2dw/</span></span><br><span class="line"><span class="hljs-attr">  pluginJsPath:</span> <span class="hljs-string">lib/</span></span><br><span class="line"><span class="hljs-attr">  pluginModelPath:</span> <span class="hljs-string">assets/</span></span><br><span class="line"><span class="hljs-attr">  tagMode:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-attr">  log:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-attr">  model:</span></span><br><span class="line"><span class="hljs-attr">    use:</span> <span class="hljs-string">live2d-widget-model-z16</span>     <span class="hljs-comment">#指定模型任务</span></span><br><span class="line"><span class="hljs-attr">  display:</span></span><br><span class="line"><span class="hljs-attr">    position:</span> <span class="hljs-string">right</span>                              <span class="hljs-comment">#显示位置</span></span><br><span class="line"><span class="hljs-attr">    width:</span> <span class="hljs-number">200</span>                                   <span class="hljs-comment">#模型宽度</span></span><br><span class="line"><span class="hljs-attr">    height:</span> <span class="hljs-number">400</span>                                  <span class="hljs-comment">#模型高度</span></span><br><span class="line"><span class="hljs-attr">  mobile:</span></span><br><span class="line"><span class="hljs-attr">    show:</span> <span class="hljs-literal">true</span>                                  <span class="hljs-comment">#是否在移动端显示</span></span><br></pre></td></tr></table></figure></li><li><p>效果：见本站</p></li></ul><hr><h3 id="遇到的坑及解决方法"><a href="#遇到的坑及解决方法" class="headerlink" title="遇到的坑及解决方法"></a>遇到的坑及解决方法</h3><ul><li>..公式渲染问题</li><li>..</li><li>..<div align="center"><br>$\color{green}{Waiting….for….update….}$<br></div></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;下载icarus主题&quot;&gt;&lt;a href=&quot;#下载icarus主题&quot; class=&quot;headerlink&quot; title=&quot;下载icarus主题&quot;&gt;&lt;/a&gt;下载icarus主题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【算法】DP最大和问题</title>
    <link href="https://www.ccyh.xyz/2019/03/17/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://www.ccyh.xyz/2019/03/17/【算法】DP最大和问题/</id>
    <published>2019-03-17T19:55:27.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><hr><a id="more"></a><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><blockquote><p>给定一个整数数字序列（用数组表示），在这个数列中选择若干个互不相邻的数，使得这些数的和达到最大值。</p></blockquote><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><blockquote><p>属于01背包问题同类问题，对于每一个数，都有两种选择（选或不选）。假设给定数组set[]的长度为n，最终要求OPT(n-1)的结果,也就是从下标0到下标n-1这些数中能组成的最大和，而要求OPT(n-1)就分为两种情况：<br>1.选择set[n-1],因为不能出现相邻选项故OPT[n-1]的结果为set[n-1]与OPT[n-3]的和。<br>2.不选择set[n-1],则OPT[n-1]的结果就与OPT[n-2]相等。<br>判断出口：<br>不难看出，OPT[0] = set[0]，OPT[1] = max(set[0],set[1]);</p></blockquote><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317082529638.png" alt=""></p><h4 id="因此其状态转移方程为："><a href="#因此其状态转移方程为：" class="headerlink" title="因此其状态转移方程为："></a>因此其状态转移方程为：</h4><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317083401575.png" alt=""></p><hr><h4 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h4><p><em>递归实现：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">OPT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>];</span><br><span class="line"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>] ? <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]:<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> a = OPT(i<span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> b = OPT(i<span class="hljs-number">-2</span>)+<span class="hljs-built_in">set</span>[i];</span><br><span class="line"><span class="hljs-keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>DP实现：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">OPT_</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">set</span>[],<span class="hljs-keyword">int</span> m)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> *opt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//状态数组</span></span><br><span class="line">    <span class="hljs-comment">//出口</span></span><br><span class="line">opt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>];</span><br><span class="line">opt[<span class="hljs-number">1</span>] = <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>] ? <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]:<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a = opt[i<span class="hljs-number">-1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> b = opt[i<span class="hljs-number">-2</span>] + <span class="hljs-built_in">set</span>[i];</span><br><span class="line">opt[i] = a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> opt[m<span class="hljs-number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>测试：</em></p><blockquote><p>输入：{1,5,8,9,7,8,2,1,6,3}<br>输出：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317084336292.png" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Knapsack" scheme="https://www.ccyh.xyz/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>【算法】背包问题的DFS与DP解法</title>
    <link href="https://www.ccyh.xyz/2019/03/14/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84DFS%E4%B8%8EDP%E8%A7%A3%E6%B3%95/"/>
    <id>https://www.ccyh.xyz/2019/03/14/【算法】背包问题的DFS与DP解法/</id>
    <published>2019-03-14T20:03:54.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kanapsack-Problem"><a href="#Kanapsack-Problem" class="headerlink" title="Kanapsack Problem"></a>Kanapsack Problem</h3><hr><a id="more"></a><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><blockquote><p>有n件物品，每件物品重w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品总重量不超过背包限重的情况下，让背包内的物品总价值达到最大。</p></blockquote><h5 id="DFS解法："><a href="#DFS解法：" class="headerlink" title="DFS解法："></a>DFS解法：</h5><h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><blockquote><p>对于每件物品，有两种情况（选，或不选）。若选择该物品，则将更新背包内的总重与总价值量，若不选择该物品，则跳过它去判断下一件物品，当处理完n件物品后，此时记录的sumW和sumC就是所选物品的总质量和总价值。如果sumW不超过V且sumC比MaxValue还大，就更新MaxValue。</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Maxn 10</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,V,MaxValue = <span class="hljs-number">0</span>;<span class="hljs-comment">//n为物品的总件数，V为背包的容量，MaxValue为最大价值</span></span><br><span class="line"><span class="hljs-keyword">int</span> w[Maxn],c[Maxn];<span class="hljs-comment">//w[i]为每件物品的重量,c[i]为每件物品的价值</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Kanapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> sumW,<span class="hljs-keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == n)<span class="hljs-comment">//已完成对n件物品的选择</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(sumW &lt;= V &amp;&amp; sumC &gt; MaxValue)</span><br><span class="line">&#123;</span><br><span class="line">MaxValue = sumC;<span class="hljs-comment">//更新最大价值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW,sumC);<span class="hljs-comment">//不选择第index件物品</span></span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW + w[index],sumC + c[index]);<span class="hljs-comment">//选择第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-comment">//输入每件物品的重量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-comment">//输入每件的价值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//初始时为第0件物品，重量为0，价值为0;</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; MaxValue &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>由于每种物品有两种选择，因而易得上述算法的时间复杂度为$2^n$;<br>这显然很是糟糕，因为在上述算法中，总是把对n件物品的选择全部确定后才去更新最大价值，但是却忽略了背包容量总是不能超过V这个点，也就是说，我们可以把选择index物品放入对上述条件的判断之中，若选择index后重量不超过V则才选择它。</p></blockquote><h4 id="改进后的算法："><a href="#改进后的算法：" class="headerlink" title="改进后的算法："></a>改进后的算法：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Kanapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> sumW,<span class="hljs-keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW,sumC);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(sumW + w[index] &lt;= V)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(sumC + c[index] &gt; MaxValue)</span><br><span class="line">&#123;</span><br><span class="line">MaxValue = sumC + c[index];</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW+w[index],sumC+c[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kanapsack-Problem&quot;&gt;&lt;a href=&quot;#Kanapsack-Problem&quot; class=&quot;headerlink&quot; title=&quot;Kanapsack Problem&quot;&gt;&lt;/a&gt;Kanapsack Problem&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】全排列问题</title>
    <link href="https://www.ccyh.xyz/2019/03/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98(C++)/"/>
    <id>https://www.ccyh.xyz/2019/03/13/【算法】全排列问题(C++)/</id>
    <published>2019-03-13T12:32:26.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h4><a id="more"></a><blockquote><p>设定一个数组p用来存放当前排列，并用一个数组Hash用来标记已填入p中的数字。<br>按顺序将数字填入数组p中的第0位置第Max-1位，现在假设已经填好了p[0]~p[index-1]，正准备将数字填入index位置，若index位置未及Max（数组边界），则枚举0~Max-1；判断是否有数字未填入，若有则将其填入p中，同时在Hash中将该数字置为已填入。其后继续填入下一个位置index+1；当递归完成时，将Hash[i]还原为false（将i置为未填入）。</p></blockquote><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Max 10</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">//列举从0到Max-1的全排列</span></span><br><span class="line"><span class="hljs-keyword">int</span> p[Max];<span class="hljs-comment">//保存当前排列</span></span><br><span class="line"><span class="hljs-keyword">bool</span> Hash[Max] = &#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-comment">//标记i是否已填入p中，是为真，否为假；</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate_x</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == Max)<span class="hljs-comment">//递归边界，已生成一种排列可能</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; Max;i++)<span class="hljs-comment">//输出该排列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; Max;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(Hash[i] == <span class="hljs-literal">false</span>)<span class="hljs-comment">//判断i是否还未已填入p中</span></span><br><span class="line">&#123;</span><br><span class="line">p[index] = i;<span class="hljs-comment">//填入</span></span><br><span class="line">Hash[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记已填入</span></span><br><span class="line">generate_x(index+<span class="hljs-number">1</span>);<span class="hljs-comment">//填写下一个数</span></span><br><span class="line">Hash[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//处理完P[index] = i 的子问题，还原状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">generate_x(<span class="hljs-number">0</span>);<span class="hljs-comment">//从0开始填入</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><p><img src="/【算法】全排列问题(C++" alt="">/20190313012239824.png)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;算法思想：&quot;&gt;&lt;a href=&quot;#算法思想：&quot; class=&quot;headerlink&quot; title=&quot;算法思想：&quot;&gt;&lt;/a&gt;算法思想：&lt;/h4&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】数字黑洞</title>
    <link href="https://www.ccyh.xyz/2019/03/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/"/>
    <id>https://www.ccyh.xyz/2019/03/13/【算法】数字黑洞/</id>
    <published>2019-03-13T10:59:40.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【PAT】B1019"><a href="#【PAT】B1019" class="headerlink" title="【PAT】B1019"></a>【PAT】B1019</h3><hr><a id="more"></a><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/20190313110514051.png" alt=""><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">digs</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> dig[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> len;</span><br><span class="line">digs()</span><br><span class="line">&#123;</span><br><span class="line">dig[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line">len = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,digs &amp;d)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">d.dig[d.len++] = n%<span class="hljs-number">10</span>;</span><br><span class="line">n /= <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">to_number</span><span class="hljs-params">(digs d)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> i = d.len<span class="hljs-number">-1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--,t++)</span><br><span class="line">&#123;</span><br><span class="line">result = result + d.dig[i]*((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp_less</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a,<span class="hljs-keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">digs d;</span><br><span class="line">to_array(n,d);</span><br><span class="line">sort(d.dig,d.dig+d.len);</span><br><span class="line"><span class="hljs-keyword">int</span> min = to_number(d);</span><br><span class="line">sort(d.dig,d.dig+d.len,cmp_less);</span><br><span class="line"><span class="hljs-keyword">int</span> max = to_number(d);</span><br><span class="line">n = max - min;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%04d - %04d = %04d\n"</span>,max,min,n);</span><br><span class="line"><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">6174</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/*for(int i = 0;i &lt; d.len;i++)</span></span><br><span class="line"><span class="hljs-comment">&#123;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; d.dig[i]&lt;&lt; ' ';</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【PAT】B1019&quot;&gt;&lt;a href=&quot;#【PAT】B1019&quot; class=&quot;headerlink&quot; title=&quot;【PAT】B1019&quot;&gt;&lt;/a&gt;【PAT】B1019&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://www.ccyh.xyz/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】素数筛法</title>
    <link href="https://www.ccyh.xyz/2019/03/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    <id>https://www.ccyh.xyz/2019/03/12/【算法】素数筛法/</id>
    <published>2019-03-12T13:03:23.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Eratosthenes筛法"><a href="#Eratosthenes筛法" class="headerlink" title="Eratosthenes筛法"></a>Eratosthenes筛法</h3><hr><a id="more"></a><h4 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h4><blockquote><p>从小到大枚举所有数，对每一个素数，筛去其所有的倍数，剩下的就都是素数了。<br>比如：<br>已知2为素数，筛去2的倍数4,6,8,10……<br>继续枚举到3，筛去3的倍数6,9,12,15……<br>由于4已被筛去，故其不是素数，来到5，筛去5的倍数10,15…..<br>如此下去，即可得到一个素数表</p></blockquote><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">//素数筛法</span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Max = <span class="hljs-number">101</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> prime[Max],pNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//pNum存放素数个数</span></span><br><span class="line"><span class="hljs-keyword">bool</span> p[Max] = &#123;<span class="hljs-literal">false</span>&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; Max;i++)<span class="hljs-comment">//遍历从2到100的数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p[i] == <span class="hljs-literal">false</span>)<span class="hljs-comment">//若i为素数</span></span><br><span class="line">&#123;</span><br><span class="line">prime[pNum++] = i;<span class="hljs-comment">//将i添加到prime数组中</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+i;j &lt; Max;j+=i)<span class="hljs-comment">//筛掉i的倍数</span></span><br><span class="line">&#123;</span><br><span class="line">p[j] = <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">findPrime();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; pNum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,prime[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/20190313041655376.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Eratosthenes筛法&quot;&gt;&lt;a href=&quot;#Eratosthenes筛法&quot; class=&quot;headerlink&quot; title=&quot;Eratosthenes筛法&quot;&gt;&lt;/a&gt;Eratosthenes筛法&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】 字符串</title>
    <link href="https://www.ccyh.xyz/2019/03/11/String/"/>
    <id>https://www.ccyh.xyz/2019/03/11/String/</id>
    <published>2019-03-11T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><a id="more"></a><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 通常用一个字符数组来表示</span></span><br><span class="line"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">"hello"</span>;</span><br><span class="line"><span class="hljs-comment">// 数组str内存储的字符为&#123;'h','e','l','l','o','\0'&#125; ,故有6个数组元素，其中'\0'是串的结束标志，告知编译器串结束了。</span></span><br><span class="line"><span class="hljs-comment">// 但是串str的长度为5，“hello”，</span></span><br></pre></td></tr></table></figure><ul><li>【注】以上定义方式一般不用，因为用该方式单纯以 ‘\0’ 结尾的串如果要得到字符串的长度较为麻烦（需要遍历整个串，时间复杂度为O(n)，故一般情况下我们用自己定义的结构体来定义串，下面会谈到。</li></ul><hr><ul><li>【注】空格也是串中的元素，由一个或多个空格组成的串称为空格串，空格串不是“空串”。</li></ul><hr><ul><li>串的逻辑结构与线性表类似，串是限定了元素为字符的线性表。但从操作对象上来说，串与线性表有着很大的不同：线性表的主要操作对象是单个元素，而串的主要操作对象是该串的一个“<strong>子串</strong>”。</li></ul><hr><h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4><hr><p><strong>1. 定长顺序存储表示：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Str</span>&#123;</span></span><br><span class="line">  <span class="hljs-keyword">char</span> str[maxsize+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 用来存放字串的字符数组，maxsize 为字符串最大长度，maxsize+1为数组最大长度，+1 用于存储 '\0'.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> length; <span class="hljs-comment">// 字符串长度，可用Str.length方法直接访问 length &lt;= maxsize;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 动态分配存储表示：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LStr</span>&#123;</span></span><br><span class="line">  <span class="hljs-keyword">char</span> *ch; <span class="hljs-comment">// 指向malloc();动态分配存储区的首地址的指针</span></span><br><span class="line">  <span class="hljs-keyword">int</span> length; <span class="hljs-comment">// 字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h4><hr><p><strong>1. 赋值操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strassign</span><span class="hljs-params">(LStr&amp; str,<span class="hljs-keyword">char</span>* ch)</span></span>&#123; <span class="hljs-comment">// 需返回的变量带引用符号&amp;</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (str.ch)&#123;</span><br><span class="line">    <span class="hljs-built_in">free</span>(str.ch); <span class="hljs-comment">// 释放原有空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">char</span> *c = ch;</span><br><span class="line">  <span class="hljs-keyword">while</span>(c)&#123; <span class="hljs-comment">// 计算ch的长度</span></span><br><span class="line">    ++len;</span><br><span class="line">    ++c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> )&#123;</span><br><span class="line">    str.ch = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 如果ch为空，则直接返回一个空的串</span></span><br><span class="line">    str.len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    str.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(str.len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 用malloc函数分配一块连续的存储空间，str.len+1是为了容纳'\0'</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (str.ch == <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//分配失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      c = ch;</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len;i++)&#123; <span class="hljs-comment">//遍历并赋值</span></span><br><span class="line">        str.ch[i] = *c; <span class="hljs-comment">// *c 表示c指针所指的位置的值</span></span><br><span class="line">        ++c; <span class="hljs-comment">// c指针指向下一个位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      str.len = len; <span class="hljs-comment">// 被赋值的串长度等于ch的串长</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// successfully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 取串长度操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StrLength</span><span class="hljs-params">(LStr str)</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 有给串长度信息的情况：</span></span><br><span class="line">    <span class="hljs-keyword">return</span> str.len; <span class="hljs-comment">// 返回str串的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//在没有给出串长度信息的情况下：</span></span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">char</span> = *c;</span><br><span class="line">    c = str.ch;</span><br><span class="line">    <span class="hljs-keyword">while</span>(c)&#123;</span><br><span class="line">      ++len;</span><br><span class="line">      ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><strong>串的比较操作</strong>：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strCompare</span><span class="hljs-params">(LStr str1,LStr str2)</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">//啰嗦版:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str1.len &amp;&amp; i &lt; str2.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(str1.ch[i] - str2.ch[i] == <span class="hljs-number">0</span>) i++;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str1.ch[i] - str2.ch[i] &gt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &gt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &lt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str1.len - str2.len &gt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &gt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str1.len - str2.len &lt; <span class="hljs-number">0</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 &lt; str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"str1 = str2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-comment">// 简洁版：</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.len &amp;&amp; i &lt; str2.len ;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str1.ch[i] != str2.ch[i])&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> str1.ch[i] - str2.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> str1.len - str2.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>4. 串的连接操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">concat</span><span class="hljs-params">(LStr &amp;str,LStr str1,LStr str2)</span></span>&#123;  <span class="hljs-comment">// 将两个字符串连接并用一个新的字符串str返回</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(str.ch) &#123; <span class="hljs-comment">// 清除原有空间</span></span><br><span class="line">      <span class="hljs-built_in">free</span>(str.ch);</span><br><span class="line">      str.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      str.len = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(str1.len+str2.len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 分配连续空间，+1是为了多分配一个位置空间存放‘\0’</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(i &lt; str1.len)&#123; <span class="hljs-comment">// 插入str1;</span></span><br><span class="line">      str.ch[i] = str1.ch[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(j &lt;= str2.len)&#123; <span class="hljs-comment">// 插入str2，注意这里用"&lt;="是为了吧'\0' 也加到末尾</span></span><br><span class="line">      str.ch[i+j] = str2.ch[j];</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    str.len = str1.len + str2.len; <span class="hljs-comment">// 更新字符串长度</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 成功连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>5. 求子串操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subStr</span><span class="hljs-params">(LStr &amp;substr,LStr str,<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pos + len &gt; str.len || pos &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || pos &gt;= str.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//判断输入是否合法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (substr.ch)&#123; <span class="hljs-comment">// 清空原空间</span></span><br><span class="line">      <span class="hljs-built_in">free</span>(substr.ch);</span><br><span class="line">      substr.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 若子串长度为0.直接返回空子串</span></span><br><span class="line">      substr.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      substr.len = <span class="hljs-number">0</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">    substr.ch = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*(len+<span class="hljs-number">1</span>)); <span class="hljs-comment">// 分配连续的内存空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = pos;</span><br><span class="line">    <span class="hljs-keyword">while</span>(i&lt;len)&#123; <span class="hljs-comment">// 从pos处开始遍历并赋值给子串</span></span><br><span class="line">        substr.ch[i] = str.ch[j];</span><br><span class="line">        ++i;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    substr.ch[i] = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 这个千万别忘了加进去</span></span><br><span class="line">    substr.len = len; <span class="hljs-comment">// 更新子串长度</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="6"><li>串的清空操作：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 串的清空操作在上诉各函数中均有用到</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clearStr</span><span class="hljs-params">(LStr &amp;str)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (str.ch)&#123;</span><br><span class="line">      <span class="hljs-built_in">free</span>(str.ch);</span><br><span class="line">      str.ch = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str.len = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="串的模式匹配算法-重点"><a href="#串的模式匹配算法-重点" class="headerlink" title="串的模式匹配算法(重点)"></a>串的模式匹配算法(重点)</h4><h6 id="何为模式匹配："><a href="#何为模式匹配：" class="headerlink" title="何为模式匹配："></a>何为模式匹配：</h6><ul><li>对一个串中某子串的定位操作称为串的模式匹配，其中待匹配的子串称为“模式串”。<h6 id="串的模式匹配算法分为："><a href="#串的模式匹配算法分为：" class="headerlink" title="串的模式匹配算法分为："></a>串的模式匹配算法分为：</h6></li></ul><ol><li>简单模式匹配算法</li><li>KMP算法</li></ol><hr><p><strong>1. 简单模式匹配算法：</strong></p><ul><li><em>算法思想</em>：</li><li>从主串的第一个位置起开始遍历字符串，若该字符与模式串的第一个字符相同，则继逐一比较后续字符，   否则从主串的下一个位置开始，重复上一步操作，以此类推，直到比较完模式串的所有字符。若匹配成     功，返回模式串在主串中的位置。匹配失败 ……,随便你想咋样。<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subStr_Match</span><span class="hljs-params">(Lstr str,LStr substr)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (substr.ch == <span class="hljs-literal">NULL</span> || str.ch == <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">int</span> i ,j , pos = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> , j = <span class="hljs-number">0</span>;i &lt; str.len &amp;&amp; i &lt; substr.len; )&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str.ch[i] == substr.ch[j])&#123;</span><br><span class="line">        ++j;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 匹配失败，j 重新指向模式串起始位置</span></span><br><span class="line">      i = ++pos; <span class="hljs-comment">// pos 记录上一次匹配的起始位置，在匹配失败后将i指向上一轮匹配的初始位置pos的后面一个位置++pos开始新一轮匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (j &gt;= substr.len)&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> pos; <span class="hljs-comment">// 匹配成功，返回模式串在主串中的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li><strong><em>KMP算法</em></strong>：</li></ol><ul><li><em>算法思想解析</em> :</li><li>上述的匹配算法称为“简单模式匹配算法（BF）”，其时间复杂度为O(mn),其中m为主串长度，n为模式串长度。由此可知简单模式匹配算法虽然易于理解但是效率很低，无法满足当已知数据异常庞大时的效率要求。所以就诞生了接下来登场的KMP算法。</li><li>我们知道，在BF算法中每次发生不匹配i与j都要回溯到该轮匹配的初始位置，并且在回溯之后的后几次匹配同样有可能导致（不必要的）不匹配状态，这是导致算法效率低下的主要原因，那么如何直接跳过这些不必要的不匹配状态而直接到达可能解决不匹配位置的的状态呢？</li><li>解决办法就是利用匹配失败后的信息，那么如何利用呢？</li><li>为了使问题变得更加直观，我们假想匹配过程就是模式串在主串上的移动(实际上并不会移动，全是指针在变化)，如果在某一次匹配时在模式串的第j位置发生了不匹配（j位置前的所有元素都已匹配成功），如果照着BF算法来做，我们会抛弃掉j位置前的匹配“成果”直接将i与j回溯重新开始下一轮比较。但现在我们不这么做，因为我们完全可以将j之前的匹配成果利用起来</li><li>不不妨假设模式串为“ABABABB”，并且该模式串在与主串的一次匹配流程中第4个元素B与主串发生了不匹配，很显然这个时候主串i位置前的三个元素跟模式串是完全匹配的，为了利用这个成果，就是在模式串向后移动后尽可能地保留这些匹配成果，我们观察这三个元素“ABA”的特点，发现他的前缀与后缀出现了相同的字符序列“A”，这时候我们应该意识到，要时上一次的成果得到最大限度的保留，我们只能将模式串移动到前缀与后缀重合的状态，这样子就保留了一个匹配成果“A“，同时i根本就不需要回溯（原地不动就好），因为i无需从模式串头部重新开始与其匹配，而只需从保留的成果后开始匹配也就是模式串的第二个位置（A的后一个位置）开始匹配。</li><li>但问题又来了，怎么知道模式串该怎么移动呢，从上面的分析我们发现，对于模式串移动的分析完全没有涉及到主串，那我们是怎么做到视主串而不见的呢(它可是”主“串啊给点面子好不好)。事实上，我们用到他了，因为我们的假设是”j位置前的元素与主串完全匹配“，竟然这样那么不就说明j位置前的模式串部分与主串的那一部分完全一样吗，所以我们可以用一个所谓”假模式串“来代替主串，而模式串只要在这个”傀儡身上移动就好了。所以，模式串在哪个位置与主串发生不匹配后模式串应该怎么移动，这个问题就可以脱离主串而背单独拿出来分析了，这就是后面要谈到的next数组（用与存放当j位置发生不匹配时，j指针应该重新调整到那个位置上）。有了next数组，我们就可以知道当模式串在J处与主串发生不匹配之后，为了最大限度地保留之前的匹配成果，模式串该怎么移动（指针该怎么变化）。</li></ul><hr><p><strong>KMP算法代码</strong>：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span> <span class="hljs-params">(LStr str,LStr substr,<span class="hljs-keyword">int</span> next[])</span></span>&#123; <span class="hljs-comment">// 函数接受主串，模式串，next数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ,j = <span class="hljs-number">1</span>; <span class="hljs-comment">// i 扫描主串，j 扫描模式串</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (i &lt; str.len &amp;&amp; i &lt; substr.len)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || str.ch[i] == substr.ch[j])&#123;  </span><br><span class="line"><span class="hljs-comment">// j=0;的情况就是模式串中的第一个字符与主串中的第i个字符不匹配，应从</span></span><br><span class="line"><span class="hljs-comment">// 主串的下一个位置与模式串的第一个位置继续比较，故++i(主串的下一个位置);</span></span><br><span class="line"><span class="hljs-comment">// ++j(模式串第一个位置0+1=1(很强))</span></span><br><span class="line">        ++j;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      j = next[j]; <span class="hljs-comment">// j 被调整到合适位置，这里的i不需要回朔，这也是KMP算法的一大特点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (j &gt;= substr.len)&#123; <span class="hljs-comment">// j 的长度超过了模式串，显然匹配成功</span></span><br><span class="line">    <span class="hljs-keyword">return</span> i - substr.len; <span class="hljs-comment">// 匹配成功，返回模式串在主串中的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>next数组的求法</strong>:</p><ul><li>经过前面的分析我们知道，只需要模式串本身我们就可以求出next数组，并不需要主串的参与。所以我们可以定义一个函数将next数组一次性求出，从此一劳永逸……</li><li>这里我们要用到一个算法思想，那就是<strong>递推</strong>,我们知道数列就是一种有着递推关系的数的序列。现在假设等差数列{An},给你一个递推公式(实际上就是前一个元素与后一个元素的关系)：A(n+1) = An + 1;其中n={1,2,3,…}然后告诉你第一个元素A1 = 0(实际上告诉你任何一个位置上的元素值都可以); 有了这两个已知条件你可以知道这个数列的所有元素就是非负整数集{0,1,2,3, …}。</li><li>那我们如何在求解next数组上面应用这个思想呢？ 首先看看我们有什么已知条件？</li><li>显然我们需要知道两个相邻状态Sk与Sk+1之间的关系，假设模式串为p1～pm，问题转化为两个模式串之间的匹配问题。如果在Sk时，已经求得了next[j] = t；若要求得Sk+1状态的next[j+1]，我们需要分两种状态来考虑：</li></ul><ol><li>若Pj = Pt；则next[j+1] = t+1;</li><li>若Pj != pt;这时候就又回到了我们讨论模式串与主串匹配出现匹配失败的经典情形了，不匹配发生在t处，我们应该去查next数组看看t应该怎样调整位置了，显然next[t]我们已经求得了，所以令t = next[t],继续比较pj与pt，若不相等重复第二种情况，直到t = 0;或者pj = pt 满足第一种情况，从而求得next[j+i];</li></ol><hr><p><strong>next求数组代码</strong>:<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(LStr substr,<span class="hljs-keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 特殊情况，模式串的第一个位置发生不匹配</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(i &lt; substr.len)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span> || substr.ch[t] == substr.ch[j])&#123; <span class="hljs-comment">// t=0;是因为next数组中可能有0元素,也说明没有重合的前后缀</span></span><br><span class="line">            next[j+<span class="hljs-number">1</span>] = t+<span class="hljs-number">1</span>; </span><br><span class="line">            ++j;</span><br><span class="line">            ++t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            t = next[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="KMP-算法的改进"><a href="#KMP-算法的改进" class="headerlink" title="KMP 算法的改进"></a>KMP 算法的改进</h4><hr><ul><li>KMP算法就还有什么地方需要改进的？</li><li>为了回答这个问题我们先来看一种特殊情况：模式串为（A A A A A B）,该模式串所对应的next数组为{0,1,2,3,4,5}。可以遇见的是当在模式串第j=5个位置A处发生不匹配时，next数组指导j指向4；而4处的元素依然不匹配（因为4处元素与5处相等），j来到了3（同样不匹配），紧接着来到了2（不匹配），来到1（依然不匹配），最后j=0(++i,++j)到此才结束了之前陷入的“尴尬”局面。</li><li>由上分析我们不难想到，如何才能让j直接跳到0；而免去从1-4的多余的比较呢？这就是KMP算法需要改进的地方</li><li>也就是说，对KMP算法的改进主要就是对求next数组的方法的改进，于是就有了改进版的next数组，我们称之为 <strong>nextval 数组</strong></li></ul><hr><h5 id="getNextval-算法核心思想："><a href="#getNextval-算法核心思想：" class="headerlink" title="getNextval() 算法核心思想："></a>getNextval() 算法核心思想：</h5><hr><ul><li>通过上面那个特殊情况，我们知道当j处发生不匹配时，若next数组指导的下一个位置的值与j处的值是相等的，那么显然这次比较就是多余的（因为显然还是会不匹配），所以我们应该跳过next数组所指向的那个位置，换一种思路就是我们应该让next[j] 所指向的位置与Pj不相等，就是改变next[j] 的值；改变后的next数组就是nextval数组.</li><li>求解nextval数组的一般步骤：</li></ul><ol><li>当j等于1时，nextval[j]赋值为 0 ，作为特殊标记；</li><li>当j大于1 时：<br>   若Pj不等于P(next[j]),则nextval[j] 等于 next[j];<br>   若Pj等于P(next[j]),则nextval[j] 等于 nextval[next[j]];</li></ol><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNextval</span><span class="hljs-params">(LStr substr,<span class="hljs-keyword">int</span> nextval[])</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line">  nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span>(i&lt;substr.len)&#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || substr.sh[j] == substr.ch[t])&#123;</span><br><span class="line">          <span class="hljs-keyword">if</span>(substr.ch[j+i] != substr.ch[t+<span class="hljs-number">1</span>])</span><br><span class="line">              nextval[j+<span class="hljs-number">1</span>] = t+<span class="hljs-number">1</span>;</span><br><span class="line">          <span class="hljs-keyword">else</span></span><br><span class="line">              nextval[j+<span class="hljs-number">1</span>] = nextval[t+<span class="hljs-number">1</span>];</span><br><span class="line">              </span><br><span class="line">              ++j;</span><br><span class="line">              ++t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">else</span> </span><br><span class="line">          t = nextval[t];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;串的定义&quot;&gt;&lt;a href=&quot;#串的定义&quot; class=&quot;headerlink&quot; title=&quot;串的定义&quot;&gt;&lt;/a&gt;串的定义&lt;/h4&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="String" scheme="https://www.ccyh.xyz/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】栈与队列</title>
    <link href="https://www.ccyh.xyz/2019/03/10/QueueStack/"/>
    <id>https://www.ccyh.xyz/2019/03/10/QueueStack/</id>
    <published>2019-03-10T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h3><hr><a id="more"></a>    <h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><ol><li><em>栈的定义</em></li></ol><ul><li>只能在一端（栈顶Top）进行插入和删除操作的线性表</li><li>栈顶由一个称为栈顶指针的位置指示器top来指示，它是动态变化的</li><li>表的另一端栈底是固定不变的</li></ul><ol><li><em>栈的特点</em></li></ol><ul><li>先进先出（ＦＩＬＯ）</li><li>栈就如同一个狭窄的死胡同，最先进去的人（元素）只能够最后出来</li></ul><ol start="3"><li><em>栈的存储结构</em></li></ol><ul><li>可以用顺序表或者链表来存储栈：<br>  a) 顺序栈<br>  b) 链式栈</li></ul><ol start="4"><li><em>栈的数学性质</em></li></ol><ul><li>当ｎ个元素以某种顺序进栈，并且可以在任何时候出栈（在满足先进后出的前提下）时，所获得的元素排列的数目Ｎ恰好满足函数 Catalan() 的计算，即：<pre><code>$$N = { \dfrac{1} {n+1} }×C\binom{n} {2n}$$ </code></pre></li></ul><hr><h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><hr><ol><li><em>队列的定义</em></li></ol><ul><li>是一种操作受限的线性表，且只允许在表的一端进行插入，在另一端进行删除操作。</li><li>可以插入的一端称为队尾（ｒｅａｒ），可以删除的一端称为队头（ｆｒｏｎｔ）</li><li>插入元素称为进队，删除元素称为出队</li></ul><ol start="2"><li><em>队列的特点</em></li></ol><ul><li>先进先出（ＦＩＦＯ），就像食堂打饭要排队一样，先来的人先有饭吃</li></ul><ol start="3"><li><em>队列的存储结构</em></li></ol><ul><li>可用线性表或者链表来存储队列：<br>  a) 顺序队<br>  b) 链队</li></ul><hr><h3 id="栈和队列的存储结构、算法与应用"><a href="#栈和队列的存储结构、算法与应用" class="headerlink" title="栈和队列的存储结构、算法与应用"></a>栈和队列的存储结构、算法与应用</h3><hr><ol><li><p><strong>顺序栈的定义</strong></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data[Maxsize]; <span class="hljs-comment">//一维数组用来存储数据</span></span><br><span class="line">  <span class="hljs-keyword">int</span> top;　<span class="hljs-comment">// ｔｏｐ指针用来指向栈顶元素,规定top=-1　为栈空，top=Maxsize-1 为栈满</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链栈结点的定义</strong></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">// 数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">// 指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>顺序队列的定义</strong></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqQueue</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data[Maxsize]; <span class="hljs-comment">//数组存放数据</span></span><br><span class="line">  <span class="hljs-keyword">int</span> front;　　<span class="hljs-comment">// 队首指针</span></span><br><span class="line">  <span class="hljs-keyword">int</span> rear;　　<span class="hljs-comment">// 队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链队的定义</strong><br>a) 链队结点定义：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span>&#123;</span></span><br><span class="line">      <span class="hljs-keyword">int</span> date; <span class="hljs-comment">//数据域</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指针域</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>b) 链队类型定义：   </p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 定义一个只包含两个指针域的结点来存放队头与队尾指针</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LiQueue</span>&#123;</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">front</span>;</span> <span class="hljs-comment">// 队首指针</span></span><br><span class="line">      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span> *<span class="hljs-title">rear</span>;</span>  <span class="hljs-comment">//　队尾指针</span></span><br><span class="line">    &#125;　<span class="hljs-comment">// 链队类型定义</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><hr><h5 id="顺序栈的几个关键要素："><a href="#顺序栈的几个关键要素：" class="headerlink" title="顺序栈的几个关键要素："></a>顺序栈的几个关键要素：</h5><ol><li><strong>三个状态</strong><ul><li>栈空状态：<strong>st.top = -1</strong>;</li><li>栈满状态：<strong>st.top = Maxsize - 1</strong>;</li><li>非法状态：栈满却继续入栈发生<strong>上溢</strong>；栈空继续出栈发生<strong>下溢</strong>；</li></ul></li><li><strong>两个操作</strong><ul><li>元素进栈：++(st.top); st.data[st.top]=x;</li><li>元素出栈：x=st.data[st.top]; –(st.top);</li></ul></li></ol><hr><h5 id="初始化栈："><a href="#初始化栈：" class="headerlink" title="初始化栈："></a>初始化栈：</h5><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 初始化一个栈，只需将栈顶指针置为－１即可</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断栈空代码："><a href="#判断栈空代码：" class="headerlink" title="判断栈空代码："></a>判断栈空代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EmptyStack</span><span class="hljs-params">(SqStack ss)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>)</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 栈空返回１；</span></span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">// 栈非空返回０；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进栈代码："><a href="#进栈代码：" class="headerlink" title="进栈代码："></a>进栈代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#defined Error 0</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(SqStack &amp;ss, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error; <span class="hljs-comment">// 栈满时返回错误，无法入栈</span></span><br><span class="line">  ss.top++;</span><br><span class="line">  ss.data[ss.top] = x;</span><br><span class="line">  <span class="hljs-comment">// 也可一句话解决：　ss.data[++ss.top] = x;</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;　<span class="hljs-comment">//入栈成功返回１</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈代码："><a href="#出栈代码：" class="headerlink" title="出栈代码："></a>出栈代码：</h5><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(SqStack &amp;ss,<span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ss.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error; <span class="hljs-comment">// 栈空不能出栈</span></span><br><span class="line">  e = ss.data[ss.top];</span><br><span class="line">  --ss.top;</span><br><span class="line">  <span class="hljs-comment">//　也可一句话解决：　e = ss.data[ss.top--];</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注】:<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">对于自增操作，入++a;总是比a++;的执行效率要高一些，因此在使用二者都可以的情况下优先选择++a;</span><br></pre></td></tr></table></figure></p><hr><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><hr><h6 id="以下链栈都由带头结点的链表表示"><a href="#以下链栈都由带头结点的链表表示" class="headerlink" title="以下链栈都由带头结点的链表表示"></a>以下链栈都由带头结点的链表表示</h6><hr><h5 id="顺序栈的几个关键要素：-1"><a href="#顺序栈的几个关键要素：-1" class="headerlink" title="顺序栈的几个关键要素："></a>顺序栈的几个关键要素：</h5><ol><li>两个状态<ul><li>栈空状态：lst –&gt; next = NULL;</li><li>栈满状态：不存在栈满状态，因为单链表的内存空间是动态分配的</li></ul></li><li>两个操作<ul><li>元素（由指针ｐ所指）的进栈操作：p -&gt; next = lst -&gt; next; lst -&gt; next = p;//其实     就是头插法建立单链表的操作</li><li>出栈操作：s = lst -&gt; next; x = s -&gt; data; lst -&gt; next = s -&gt; next;           free(s); //其实就是单链表的删除操作</li></ul></li></ol><hr><h4 id="链栈的初始化代码："><a href="#链栈的初始化代码：" class="headerlink" title="链栈的初始化代码："></a>链栈的初始化代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 实际上，链栈的初始化与单链表的初始化并无不同</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initLStack</span><span class="hljs-params">(LNode *&amp;lst)</span></span>&#123;</span><br><span class="line">  lst = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode)); <span class="hljs-comment">//制造一个头结点</span></span><br><span class="line">  lst -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">// 将链栈滞空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈空代码：-1"><a href="#判断栈空代码：-1" class="headerlink" title="判断栈空代码："></a>判断栈空代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LNode lst)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (lst -&gt; next == <span class="hljs-literal">NULL</span>) </span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//栈空返回１；</span></span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">// 栈不空返回０；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈代码：-1"><a href="#进栈代码：-1" class="headerlink" title="进栈代码："></a>进栈代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(LNode &amp;lst,<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  LNode s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">  s -&gt; data = x;</span><br><span class="line">  s -&gt; next = lst -&gt; next;</span><br><span class="line">  lst -&gt; next = s;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈代码：-1"><a href="#出栈代码：-1" class="headerlink" title="出栈代码："></a>出栈代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(LNode &amp;lst, <span class="hljs-keyword">int</span> &amp;e)</span></span>&#123; <span class="hljs-comment">// 用e返回出栈元素的值</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (lst -&gt; next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  e = lst -&gt; next -&gt; data;</span><br><span class="line">  LNode *s = lst -&gt; next;</span><br><span class="line">  lst -&gt; next = s -&gt; next;</span><br><span class="line">  <span class="hljs-built_in">free</span>(s);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><hr><h6 id="栈的主要应用有："><a href="#栈的主要应用有：" class="headerlink" title="栈的主要应用有："></a>栈的主要应用有：</h6><ol><li>括号匹配</li><li>表达式求值</li><li>逆波兰转换算法</li></ol><hr><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><hr><h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><ul><li>扫描整个表达式，判断当前符号是否为括号</li><li>如果不是，继续扫描下一个字符</li><li>如果是，判断是左括号还是右括号，是左括号将其入栈，是右括号就判断栈是否为空</li><li>若栈为空，说明此表达式的右括号多与左夸号</li><li>若栈不空则判断当前操作符是否和栈顶操作符匹配，若不匹配说明左右括号不匹配，若匹配则继续判断     下一个操作符。最后，判断栈是否为空，若不空则说明左括号多余右括     号，栈为空说明匹配成功。</li></ul><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">initStack(Stack <span class="hljs-built_in">stack</span>)&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i ;i&lt;<span class="hljs-built_in">strlen</span>(str);i++)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'&#123;'</span> || str[i]==<span class="hljs-string">'['</span> || str[i]==<span class="hljs-string">'('</span>)&#123;</span><br><span class="line">      push(<span class="hljs-built_in">stack</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'&#123;'</span> &amp;&amp; getTopStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">'&#125;'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'['</span> &amp;&amp; getToPStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">']'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'('</span> &amp;&amp; getTopStack(<span class="hljs-built_in">stack</span>) == <span class="hljs-string">')'</span>)</span><br><span class="line">          pop(<span class="hljs-built_in">stack</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 最后，若栈空则匹配成功，否则失败</span></span><br><span class="line">  <span class="hljs-keyword">if</span>(isEmpty() == <span class="hljs-literal">true</span>)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"括号匹配成功　！！！"</span>　&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"匹配失败　！！！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><hr><h5 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h5><ul><li>扫描表达式，当扫描到数时将其推入栈中，当扫描到一个运算符时，将该运算符作用于位于栈顶的两个数上，并将所得结果推入栈中</li><li>以下将给出后缀表达式的求值程序</li></ul><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calcExp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-built_in">exp</span> , Stack s)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span>[i] != <span class="hljs-string">'\0'</span>)&#123; <span class="hljs-comment">//</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; <span class="hljs-built_in">exp</span>[i]&lt;=<span class="hljs-string">'9'</span>)&#123;</span><br><span class="line">        s.push(s , <span class="hljs-built_in">exp</span>[i]-<span class="hljs-string">'0'</span>); <span class="hljs-comment">//　若为数字，推入栈中</span></span><br><span class="line">      &#125;</span><br><span class="line">      else if(exp[i] == '运算符')&#123;</span><br><span class="line">          <span class="hljs-keyword">int</span> m = s.gettop(); <span class="hljs-comment">//　取栈顶元素后将其出栈</span></span><br><span class="line">          s.pop();</span><br><span class="line">          <span class="hljs-keyword">int</span> n = s.gettop(); <span class="hljs-comment">//　取栈顶元素后将其出栈</span></span><br><span class="line">          s.pop;</span><br><span class="line">          s.push(s, n[运算符]m); <span class="hljs-comment">//　将运算结果推入栈中</span></span><br><span class="line">      &#125; </span><br><span class="line">      i++; <span class="hljs-comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> s.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="逆波兰转换算法"><a href="#逆波兰转换算法" class="headerlink" title="逆波兰转换算法"></a>逆波兰转换算法</h4><hr><h5 id="算法思想：-2"><a href="#算法思想：-2" class="headerlink" title="算法思想："></a>算法思想：</h5><ul><li>设立一个栈，存放运算符，初始栈为空，编译程序从左往右扫描中缀表达式，若遇到数字，直接输出，并输出一个空格为两个操作数之间的分隔符；</li><li>若遇到运算符，则与栈顶比较，若运算符级别比栈顶级别高则进栈，否则退出栈顶元素并输出，之后输出一个空额作分隔符</li><li>所遇到左括号，紧张；</li><li>若遇到右括号，则一直退栈粗出知道退出第一个左括号为止</li><li>当栈为空时，输出的结果即为<strong>后缀表达式</strong></li></ul><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tranfExp</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-built_in">exp</span> , Stack s)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span>[i] != <span class="hljs-string">'\0'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; <span class="hljs-built_in">exp</span>[i] &lt;= <span class="hljs-string">'9'</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为数字，直接输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] == <span class="hljs-string">'('</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为左括号，进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] == <span class="hljs-string">')'</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">//　若为右括号，出栈直至第一个左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">        else if (exp[i] == '运算符')&#123;</span><br><span class="line">            <span class="hljs-comment">//　判断与栈顶元素的优先级大小</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>[i] &gt; s.gettop())</span><br><span class="line">                s.push(<span class="hljs-built_in">exp</span>[i]);  <span class="hljs-comment">// 优先级大于栈顶运算符，将该运算符进栈</span></span><br><span class="line">            <span class="hljs-keyword">else</span>  <span class="hljs-comment">//　优先级小于栈顶运算符，退出栈顶元素并且输出</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (s.isEmpty() == <span class="hljs-literal">false</span>)</span><br><span class="line">        pop();<span class="hljs-comment">//　把栈中剩余元素全部退出并输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="顺序队"><a href="#顺序队" class="headerlink" title="顺序队"></a>顺序队</h3><hr><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><hr><h5 id="循环队列的基本要素"><a href="#循环队列的基本要素" class="headerlink" title="循环队列的基本要素"></a>循环队列的基本要素</h5><ol><li>两个状态：<ul><li>队空状态：qu.rear = qu.front;</li><li>队满状态：(qu.rear+1)%front == qu.front ;</li></ul></li><li>两个操作：<ul><li>元素x进队操作：qu.rear = (qu.rear+1)%MaxSize; qu.data[qu.rear] = x;</li><li>出队操作：qu.front = (qu.front+1)%MaxSize; elem = qu.data[qu.front];//elem 保     存出队的元素</li></ul></li></ol><hr><h4 id="循环队列的基本操作实现"><a href="#循环队列的基本操作实现" class="headerlink" title="循环队列的基本操作实现"></a>循环队列的基本操作实现</h4><ol><li><p>初始化队列算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(Queue &amp;qu)</span></span>&#123;</span><br><span class="line">  qu.front = <span class="hljs-number">0</span>; </span><br><span class="line">  qu.rear = <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断队空算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isQEmpty</span><span class="hljs-params">(Queue qu)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (qu.front == qu.rear)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进队算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enterQueue</span><span class="hljs-params">(Queue &amp;qu , <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> ((qu.rear+<span class="hljs-number">1</span>)%MaxSize == front)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队列已满"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qu.rear = (qu.rear+<span class="hljs-number">1</span>)%MaxSize;</span><br><span class="line">  qu.data[qu.rear] = x;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出队算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">outQueue</span><span class="hljs-params">(Queue &amp;qu , <span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (qu.rear == qu.front)&#123;</span><br><span class="line">      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队空无法出队"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qu.front = (qu.front+<span class="hljs-number">1</span>)%MaxSize;</span><br><span class="line">  e = qu.data[qu.front];</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><hr><h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><h6 id="采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限"><a href="#采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限" class="headerlink" title="采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限"></a>采用链式存储方式来实现队列，特点是假设内存无限大的情况下不存在队满上限</h6><hr><h5 id="链队的基本要素"><a href="#链队的基本要素" class="headerlink" title="链队的基本要素"></a>链队的基本要素</h5><ol><li>两个状态：<ul><li>队满状态： 不存在队满状态</li><li>队空状态：que.rear = NULL || que.front = NULL (两个满足一个即可)</li></ul></li><li>两个操作：<ul><li>元素q进队操作：　分两种情况<pre><code>1. 当前队为空：que --&gt; rear = que --&gt; front = q;2. 当前队不空：que --&gt; rear --&gt; next = p;que --&gt; rear = p;</code></pre></li><li>元素出队操作： s = que –&gt; front;  que –&gt; front = s –&gt; next;elem = s –&gt;                      data; free(s);</li></ul></li></ol><hr><h4 id="链队的基本操作实现"><a href="#链队的基本操作实现" class="headerlink" title="链队的基本操作实现"></a>链队的基本操作实现</h4><p>1.初始化链队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initLiQueue</span><span class="hljs-params">(LiQueue *&amp;que)</span></span>&#123;</span><br><span class="line">    que = (LiQueue*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LiQueue));</span><br><span class="line">    que -&gt; rear = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    que -&gt; front = <span class="hljs-literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.判断队空算法：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LiQueue que)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (que.rear = <span class="hljs-literal">NULL</span> || que.front = <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队列为空"</span>　&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.入队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enterLiQueue</span><span class="hljs-params">(LiQueue &amp;que ， <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LQNode* s = (LQNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LQNode));</span><br><span class="line">    <span class="hljs-keyword">if</span> (isEmpty(que))&#123;  <span class="hljs-comment">// 若队列为空，进队操作比较特别</span></span><br><span class="line">        que -&gt; front = que -&gt; rear = s;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        que -&gt; rear -&gt; next = s;</span><br><span class="line">        que -&gt; rear = s;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.出队算法：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">outLiQueue</span><span class="hljs-params">(LiQueue &amp;que , <span class="hljs-keyword">int</span> &amp;elem)</span></span>&#123;</span><br><span class="line">    LQNode* s = que -&gt; front;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"队为空，无法出队"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (que -&gt; front == que -&gt; rear)&#123; <span class="hljs-comment">// 若队列只有一个元素，出队操作比较特别</span></span><br><span class="line">        que -&gt; front = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        que -&gt; rear = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    que -&gt; front = s -&gt; next;</span><br><span class="line">    elem = s -&gt; data;</span><br><span class="line">    <span class="hljs-built_in">free</span>(s);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;栈和队列的基本概念&quot;&gt;&lt;a href=&quot;#栈和队列的基本概念&quot; class=&quot;headerlink&quot; title=&quot;栈和队列的基本概念&quot;&gt;&lt;/a&gt;栈和队列的基本概念&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="List" scheme="https://www.ccyh.xyz/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】线性表</title>
    <link href="https://www.ccyh.xyz/2019/03/06/linearList/"/>
    <id>https://www.ccyh.xyz/2019/03/06/linearList/</id>
    <published>2019-03-06T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="线性表的基本概念与实现"><a href="#线性表的基本概念与实现" class="headerlink" title="线性表的基本概念与实现"></a>线性表的基本概念与实现</h3><a id="more"></a><p>1.　<strong>线性表的定义:</strong><br>    线性表是具有相同特性数据元素的一个有限序列，重点在“<strong>有限序列</strong>”。线性表可以是有序的，也可以是无序的。<br>2.　<strong>线性表的逻辑特性:</strong><br>    除了表头和表尾的数据元素“结点”，所有元素都有一个<em>直接前驱</em>与一个<em>直接后继</em>。表头无前驱，表尾无后继。</p><ol><li><strong>线性表的存储结构：</strong></li></ol><pre><code>* 顺序存储结构：（顺序表）    1. 存储空间连续（空间为*一次性*分配的）    2. 可以随机存取，也可以顺序存取    3. 插入删除时平均需要移动近一半的元素，时间复杂度为:__O((n-1)/2)=O(n)__    4. 存储密度为１* 链式存储结构：（链表）    1. 存储空间可以不连续（存储空间是*动态*分配的）    2. 每一个结点不仅包含数据还包含指向下一个结点的指针    3. 只能够进行顺序存储    4. 存储密度&lt;1    5. 插入删除时不需要移动元素，只需修改*指针*即可,时间复杂度为:__O(1)__</code></pre><ol><li><strong>线性表的定义与实现：</strong><br>a) <em>顺序表的定义：</em></li></ol><p><em>结构体定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#defined MaxSize 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> sturct Sqlist &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> data[MaxSize]; <span class="hljs-comment">//线性表最多能容纳的元素个数，即分配的空间大小</span></span><br><span class="line">    <span class="hljs-keyword">int</span> length ;　<span class="hljs-comment">//元素的个数</span></span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure></p><p><em>用的最多的简单定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> A[MaxSize]; <span class="hljs-comment">//直接利用数组就是顺序表的一种这一特性</span></span><br><span class="line"><span class="hljs-keyword">int</span> length;</span><br></pre></td></tr></table></figure></p><hr><p> 　  <em>b) 单链表的结点定义：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">//指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure></p><hr><p>  <em>c) 双链表结点定义：</em></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNOde</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNOde</span> *<span class="hljs-title">prior</span>;</span>　<span class="hljs-comment">// 指向前驱结点的指针</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span> *<span class="hljs-title">next</span>;</span>　<span class="hljs-comment">//　指向后继结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>【注】　为结点分配存储空间：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">LNode *A = (LNOde*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="hljs-comment">//malloc 函数返回一个空间的地址，让指针Ａ来指向它</span></span><br></pre></td></tr></table></figure></p><h3 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h3><hr><ul><li><p>查找操作：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findElem</span> <span class="hljs-params">(Sqlist a, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;l.length;++i)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//找到了，返回所在的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<span class="hljs-comment">//　没找到，返回０</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">insertElem</span><span class="hljs-params">(Sqlist &amp;L,<span class="hljs-keyword">int</span> i ,<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || i &gt; L.length)&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//如果插入位置不合法，返回－１</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (L.length == MaxSize)&#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> newL[L.length+MaxSize]</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;L.length;++j)&#123;</span><br><span class="line">          newL[j] = L[j]; <span class="hljs-comment">//如果发现顺序表已经满了，就构造一个更大的顺序表并把原顺序表的元素放进去</span></span><br><span class="line">      &#125;</span><br><span class="line">  L = newL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = L.length<span class="hljs-number">-1</span>; k&gt;=i; --k)&#123;</span><br><span class="line">      L[k+<span class="hljs-number">1</span>] = L[k];　<span class="hljs-comment">//从某位开始将插入位置至末尾的元素向后移动一个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  L[i] = x;　<span class="hljs-comment">// 插入ｘ到ｉ处</span></span><br><span class="line">  L.length++; <span class="hljs-comment">// 插入后该表表的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//　通过索引下标删除元素，并返回所删元素的值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteElem_by_index</span> <span class="hljs-params">(Sqlist &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> q = L[i];　<span class="hljs-comment">// 保留ｉ位置的元素</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;L.length;++j)&#123;</span><br><span class="line">        L[j<span class="hljs-number">-1</span>] = L[j]; <span class="hljs-comment">//　从待删除元素的右边开始每个元素向左移动一个位置，覆盖掉ｉ位置的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length--; <span class="hljs-comment">//　顺序表长度减一，完成删除操作</span></span><br><span class="line">    <span class="hljs-keyword">return</span> q; <span class="hljs-comment">//　返回被删除元素的值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 通过值来删除元素，并返回所删元素的下标</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteElem_by_value</span> <span class="hljs-params">(Sqlist &amp;L, <span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> index = findElem(L,e); <span class="hljs-comment">//利用findELem() 函数找到要删除元素的下标</span></span><br><span class="line">    <span class="hljs-keyword">int</span> value = L[index]; </span><br><span class="line">    deliteElem_by_index (L,index);　<span class="hljs-comment">// 用下标索引法删除元素</span></span><br><span class="line">    <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化顺序表：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initList</span> <span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;</span><br><span class="line">    L.length = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求指定位置元素：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getElem</span> <span class="hljs-params">(Sqlist L , <span class="hljs-keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; L.length<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> Error;</span><br><span class="line">    rerurn L[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单链表的相关操作"><a href="#单链表的相关操作" class="headerlink" title="单链表的相关操作"></a>单链表的相关操作</h3><hr><h6 id="以下所有的算法用的都是带头结点的单链表"><a href="#以下所有的算法用的都是带头结点的单链表" class="headerlink" title="以下所有的算法用的都是带头结点的单链表"></a>以下所有的算法用的都是带头结点的单链表</h6><hr><ul><li><p>尾插法建立单链表：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 给定数组ａ[] 为数据源，建立单链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatListR</span><span class="hljs-params">(LNode *&amp;C , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    LNode *s,*r; <span class="hljs-comment">//用ｓ指向新建的结点，ｒ始终指向链表的尾部结点</span></span><br><span class="line">    C = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">// 建立链表头结点</span></span><br><span class="line">    C -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//　将链表滞空</span></span><br><span class="line">    r = C;　<span class="hljs-comment">// r 指向头结点，也就是空链表的头结点</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;length ; ++i)&#123;</span><br><span class="line">        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">//　用malloc函数循环分配结点空间</span></span><br><span class="line">        s -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">//　尾插法的核心算法：</span></span><br><span class="line">        r -&gt; next = s;</span><br><span class="line">        </span><br><span class="line">        r = r -&gt; next; <span class="hljs-comment">//r 指向当前尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// r -&gt; next ==　NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>头插法建立单链表：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatListH</span><span class="hljs-params">(LNode *&amp;C ,<span class="hljs-keyword">int</span> a[] ,<span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));　<span class="hljs-comment">// 建立链表头结点</span></span><br><span class="line">    C -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//　将链表滞空</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; length ; ++i)&#123;</span><br><span class="line">        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">// 头插法的核心算法：</span></span><br><span class="line">        s -&gt; next = C --&gt; next;</span><br><span class="line">        C -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除结点：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 按值索引删除链表结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(LNode &amp;L , <span class="hljs-keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="hljs-keyword">if</span> (L -&gt; next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//如果链表为空，返回０；</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (p -&gt; next != <span class="hljs-literal">NULL</span>)&#123;　<span class="hljs-comment">// 循环遍历链表结点</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (p -&gt; next -&gt; data == elem)&#123;　<span class="hljs-comment">// 如果ｐ指向的结点的下一个结点的数据域与带删除数据相等，删除该下一个结点，释放空间</span></span><br><span class="line">           <span class="hljs-comment">// 删除操作的核心算法：</span></span><br><span class="line">            q = p -&gt; next;</span><br><span class="line">            p -&gt; next = p -&gt; next -&gt; next;</span><br><span class="line">          　</span><br><span class="line">            <span class="hljs-built_in">free</span>(q);　<span class="hljs-comment">// 释放内存</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;　<span class="hljs-comment">//删除成功，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;　<span class="hljs-comment">//该节点不是待删除结点，令ｐ指向下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入结点：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 在链表的指定元素前插入结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(LNode &amp;L , <span class="hljs-keyword">int</span> we,<span class="hljs-keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    LNode *r;</span><br><span class="line">    r = L;</span><br><span class="line">    LNode *s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));</span><br><span class="line">    q -&gt; data = we;</span><br><span class="line">    q -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (r -&gt; next != <span class="hljs-literal">NULL</span> )&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (r -&gt; next -&gt; data == e)&#123;</span><br><span class="line">        <span class="hljs-comment">//插入操作的核心算法：</span></span><br><span class="line">            s -&gt; next = r -&gt; next;</span><br><span class="line">            r -&gt; next = s;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="双链表的相关操作"><a href="#双链表的相关操作" class="headerlink" title="双链表的相关操作"></a>双链表的相关操作</h3><hr><ul><li><p>尾插法建立双链表：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//　给定数据源数组，建立双链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatDListR</span> <span class="hljs-params">(DLNode ＆L , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    DLNode *s,*r; <span class="hljs-comment">//用ｒ始终指向链表末尾结点，ｓ接受新分配的结点</span></span><br><span class="line">    L = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));　<span class="hljs-comment">// 申请头结点空间，并将链表滞空</span></span><br><span class="line">    L -&gt; prior = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    r = L;　<span class="hljs-comment">//r 指向头结点</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        s = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">// 尾插发的关键步骤：</span></span><br><span class="line">        s -&gt; prior = r;</span><br><span class="line">        r -&gt; next = s;</span><br><span class="line">        r = r -&gt; next; <span class="hljs-comment">// r = s;　令ｒ　指向下一个结点</span></span><br><span class="line">        r -&gt; next = <span class="hljs-literal">NULL</span>;　<span class="hljs-comment">//滞空末尾结点的ｎｅｘｔ指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>头插法建立双链表：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatDListH</span> <span class="hljs-params">(DLNode ＆L , <span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    DLNode *s ;</span><br><span class="line">    L = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));　<span class="hljs-comment">// 申请头结点空间，并将链表滞空</span></span><br><span class="line">    L -&gt; prior = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;length; ++i)&#123;</span><br><span class="line">        s = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));</span><br><span class="line">        s -&gt; data = a[i];</span><br><span class="line">        <span class="hljs-comment">//关键步骤：</span></span><br><span class="line">        s -&gt; next = L -&gt; next;</span><br><span class="line">        L -&gt; next -&gt; prior = s;</span><br><span class="line">        s -&gt; prior = L;</span><br><span class="line">        L -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找结点的算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 在双链表中查找第一个值为ｘ的结点，从第一个结点开始，边扫描边比较，若找到返回该结点的指针，没找到返回　ＮＵＬＬ</span></span><br><span class="line"><span class="hljs-function">DLNode* <span class="hljs-title">findNode</span><span class="hljs-params">(DLNode *L, <span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    DLNode *p;</span><br><span class="line">    p = L -&gt; next;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p -&gt; data == x)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入结点的算法：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//在双链表中ｐ所指结点后插入新的结点ｓ</span></span><br><span class="line"><span class="hljs-comment">//关键步骤如下：</span></span><br><span class="line">              s -&gt; next = p -&gt; next;</span><br><span class="line">              s -&gt; prior = p;</span><br><span class="line">              p -&gt; next -&gt; prior = s;</span><br><span class="line">              p -&gt; next = s;</span><br></pre></td></tr></table></figure></li><li><p>删除结点：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//在双链表中的删除指针ｐ所指结点的后继结点,并用ｓ指针返回被删除的结点</span></span><br><span class="line"><span class="hljs-comment">//关键步骤如下：</span></span><br><span class="line">              s = p -&gt; next ;</span><br><span class="line">              s -&gt; next -&gt; prior = p;</span><br><span class="line">              p -&gt; next = s -&gt; next;</span><br><span class="line">              <span class="hljs-built_in">free</span>(s);</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;线性表的基本概念与实现&quot;&gt;&lt;a href=&quot;#线性表的基本概念与实现&quot; class=&quot;headerlink&quot; title=&quot;线性表的基本概念与实现&quot;&gt;&lt;/a&gt;线性表的基本概念与实现&lt;/h3&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="List" scheme="https://www.ccyh.xyz/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】树</title>
    <link href="https://www.ccyh.xyz/2019/03/05/BinaryTree/"/>
    <id>https://www.ccyh.xyz/2019/03/05/BinaryTree/</id>
    <published>2019-03-05T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><a id="more"></a><hr><p><strong>树的定义：</strong><br>前面所提到的线性结构的元素是一种一对一的关系，而树是一种一对多的非线性结构，下面将通过一个具体的树的例子讲解到底什么样的结构才是树以 及树的一些相关术语：</p><p><img src="https://i.loli.net/2019/01/28/5c4e5b7679982.png" alt=""></p><p>上图就是个树结构的概图了，我们可以看到它是由唯一的一个根节点和若干棵互不相交的子树组成的，由此可知树的定义是地柜的，即在树的定义中又用到了树的定义。这里需要注意的是，树的结点数可以是零，若为零时，称为一棵<strong>空树</strong>。<br><strong>结点：</strong>上图中的每一个橙色圆圈都是结点，结点中不仅有数据域，还存在几个或零个指向其子树的指针；<br><strong>结点的度：</strong>该节点所引申出的分支数目，如上图中的B结点，向下引申出了E和F，故其度为2；<br><strong>树的度：</strong>树的度为树中所有结点的度的最大值，如上图树的度为A结点的度为3；<br><strong>叶子结点：</strong>又称为<em>终端结点</em>，指的是度为零的结点<br><strong>非终端结点：</strong>又称为分支结点，指的是度不为零的结点，上图中的ABCDEG都是非终端结点。另外，非终端结点除去根节点A之外的所有结点又称为<em>内部结点</em>。<br><strong>祖先：</strong>从树的根节点到某一节点的路径上的所有结点都成为该结点的祖先结点，如E的祖先节点为：<br>A和B，因为路径为：A–B–E；<br><strong>层次：</strong>根处为第一层，以此类推……，如上图树的层次为4层；<br><strong>结点的深度和高度：</strong>联系实际，只需记住，高度是从底往上数；而深度是从上往下数；比如结点B的高度为3；而深度为2。根节点A的高度为树的高度为4；<br><strong>有序树：</strong>树中结点的子树从左到右都是有次序的不能交换<br><strong>无序树：</strong>树中结点的子树没有次序，可以任意交换<br><strong>丰满树：</strong>理想的平衡树，要求除了最底层外，其他层都是满的<br><strong>森林：</strong>若干棵互不相交的树的集合，若吧上图中的根节点A去掉，就成了一个森林</p><hr><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>顺序存储：<br>双亲存储结构，亦称双亲表示法(克鲁斯卡尔算法)</li><li>链式存储：<br>孩子存储结构（孩子表示法）<br>孩子兄弟存储结构（孩子兄弟表示法）</li></ul><hr><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul><li>二叉树的五种基本形式</li><li>满二叉树的概念</li><li>完全二叉树的概念<h4 id="二叉树的几个重要性质"><a href="#二叉树的几个重要性质" class="headerlink" title="二叉树的几个重要性质"></a>二叉树的几个重要性质</h4></li><li><strong>性质一：</strong>非空二叉树上叶子结点的数量等于双分支结点数加 1，即为$ n_0 = n_2 + 1$；</li><li><strong>性质二：</strong>二叉树的第$i$层上最多有$2^{i-1}$;</li><li><strong>性质三：</strong>高度（或深度）为$k$的二叉树最多有$2^k-1$个结点，换句话说就是一个深度为k的满二叉树的结点为$2^k-1$.</li><li><strong>性质四：</strong>该性质与二叉树的顺序存储结构相关，在下面会提到，这里不再赘述；</li><li><strong>性质五：</strong>函数$Catalan( ):$给定$n$个结点，能构成$h(n)$种不同的二叉树，其中：$h(n)=\frac{1}{n+1}×C_{2n}^n$ ;</li><li><strong>性质六：</strong>具有$n$个结点的完全二叉树的高度（或深度）为$[\log_2{n}]+1$(向下取整)；</li></ul><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul><li><strong>顺序存储结构：</strong><br>用一个数组来存储<em>完全二叉树</em>，将完全二叉树的结点值按编号依次存入一个一维数组中。<br><img src="https://i.loli.net/2019/01/28/5c4e5b768378b.png" alt=""></li></ul><p>如果要从一维数组中还原二叉树的本来结构，按照以下规则：<br>$i$ 为某结点的编号，若$i\not=1$，则该结点的双亲结点的编号为$i/2$向下取整；<br>如果$2i\leq n$,则该结点的左孩子编号为$2i$,否则该结点没有左孩子；<br>如果$2i+1 \leq n$,则该结点的右孩子编号为$2i+1$;否则该结点无右孩子；<br>下面给出将数组还原成二叉链树的代码：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatBTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> BT[],<span class="hljs-keyword">int</span> n,BTNode *&amp;e)</span></span>&#123;</span><br><span class="line">  BTNode *BTNode_array[maxsize];</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i )&#123;</span><br><span class="line">    BTNode_array[i] = (BTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));</span><br><span class="line">    BTNode_array[i] -&gt; data = BT[i];</span><br><span class="line">    BTNode_array[i] -&gt; lchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    BTNode_array[i] -&gt; rchild = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= n )&#123;</span><br><span class="line">      BTNode_array[i] -&gt; lchild = BTNode_array[<span class="hljs-number">2</span>*i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>((<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>) &lt;= n)&#123;</span><br><span class="line">      BTNode_array[i] -&gt; rchild = BTNode_array[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  e = BTNode_array[<span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>链式存储结构：</strong><br>为了能够存储任意形式的二叉树结构，且根据二叉树一对多的非线性关系，设计出了二叉树的链式存储结构，结点定义如下：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">lchild</span>;</span><span class="hljs-comment">//指向左孩子的指针</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//指向右孩子的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树的遍历算法-递归实现-："><a href="#二叉树的遍历算法-递归实现-：" class="headerlink" title="二叉树的遍历算法(递归实现)："></a>二叉树的遍历算法(递归实现)：</h4><p><strong>深度优先遍历：</strong></p><ul><li><p>前序遍历：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">Visit(p);</span><br><span class="line">preorder(p -&gt; lchild);</span><br><span class="line">preorder(p -&gt; rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">inorder(p -&gt; lchild);</span><br><span class="line">Visit(p);</span><br><span class="line">inorder(p -&gt; rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">postorder(p -&gt; lchild);</span><br><span class="line">postorder(p -&gt; rchild);</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>广度优先遍历：</strong></p><ul><li>算法流程图解：<br><img src="https://i.loli.net/2019/01/28/5c4e5b76a92a2.png" alt=""><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">level</span> <span class="hljs-params">(BTNode *p)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">BTNode *que[maxsize];</span><br><span class="line"><span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;</span><br><span class="line">BTNode *q;</span><br><span class="line">rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">que[rear] = p;</span><br><span class="line"><span class="hljs-keyword">while</span>(front != rear)&#123;</span><br><span class="line">front = (front + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">q = que[front];</span><br><span class="line">Visit(q);</span><br><span class="line"><span class="hljs-keyword">if</span>(q -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">que[rear] = q -&gt; lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(q -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">rear = (rear + <span class="hljs-number">1</span>)%maxsize;</span><br><span class="line">que[rear] = q -&gt; rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="二叉树的遍历算法-非递归实现"><a href="#二叉树的遍历算法-非递归实现" class="headerlink" title="二叉树的遍历算法(非递归实现)"></a>二叉树的遍历算法(非递归实现)</h4><p><img src="https://i.loli.net/2019/01/28/5c4e5b768378b.png" alt=""></p><h6 id="上图而查处将作为例子方便讲解下面的算法"><a href="#上图而查处将作为例子方便讲解下面的算法" class="headerlink" title="上图而查处将作为例子方便讲解下面的算法"></a>上图而查处将作为例子方便讲解下面的算法</h6><hr><p><strong>深度优先遍历算法：</strong></p><ul><li><p>先序遍历：<br><img src="https://i.loli.net/2019/01/28/5c4e5b76b04b4.png" alt=""></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">BTNode *Stack[maxsize];</span><br><span class="line"><span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">BTNode *p;</span><br><span class="line">Stack[++top] = bt;</span><br><span class="line"><span class="hljs-keyword">while</span>(top != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">    p = Stack[top--];</span><br><span class="line">    Visit(p);</span><br><span class="line">    <span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        Stack[++top] = p -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        Stack[++top] = p -&gt; lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：<br>先序遍历算法遍历例子二叉树将得到：A B D E C F G<br>后序遍历例子二叉树：D E B F G C A<br>将后序遍历序列逆置：A C G F B E D<br>可以发现，如果将先序遍历序列中对左右子树的遍历顺序交换一下，就可以得到逆后序遍历序列，再将逆后序序列逆置即可得到后序遍历序列。<br><img src="https://i.loli.net/2019/01/28/5c4e5b7746fce.png" alt=""></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">BTNode Stack1[maxsize];</span><br><span class="line">BTNode Stack2[maxsize];</span><br><span class="line"><span class="hljs-keyword">int</span> top1 = <span class="hljs-number">-1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> top2 = <span class="hljs-number">-1</span>;</span><br><span class="line">BTNode *p = <span class="hljs-literal">NULL</span>;</span><br><span class="line">Stack1[++top1] = bt;</span><br><span class="line"><span class="hljs-keyword">while</span>(top1 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">p = Stack1[top--];</span><br><span class="line">Stack2[++top] = p;</span><br><span class="line"><span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">Stack1[++top] = p -&gt; lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(p -&gt; rchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">Stack1[++top] = p -&gt; rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span>(top2 != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">p = Stack2[top--];</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：<br><img src="https://i.loli.net/2019/01/28/5c4e5b775c25b.png" alt=""></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderNonrecursion</span><span class="hljs-params">(BTNode *bt)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(bt != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">BTNode *Stack[maxsize];</span><br><span class="line"><span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;</span><br><span class="line">BTNode *p;</span><br><span class="line">p = bt;</span><br><span class="line"><span class="hljs-keyword">while</span>(top != <span class="hljs-number">-1</span> || p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">Stack[++top] = p;</span><br><span class="line">p = p -&gt; lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(top != <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">p = Stack[top--];</span><br><span class="line">Visit(p);</span><br><span class="line">p = p -&gt; rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><hr><p>对于二叉链表存储结构，$n$个结点的二叉树有$n+1$个空链域，能不能把这些空链域有效地利用起来，使二叉树的遍历更加高效呢？答案是肯定的，这就是线索二叉树的由来。</p><ul><li><p>线索二叉树的优势：二叉树被线索化后近似于一个线性结构，分支结构的遍历操作就被转化成了近似线性结构的遍历操作，通过线索的辅助使得寻找当前结点的前驱或者后继的效率大大提高。<br><strong>线索二叉树的构造：</strong><br><img src="https://i.loli.net/2019/01/28/5c4e5b7758a61.png" alt=""><br><strong>结点定义：</strong></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> data; <span class="hljs-comment">// 数据域</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">lchild</span>;</span> <span class="hljs-comment">// 左孩子（前驱结点）指针</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBTNode</span> *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">// 右孩子（后继结点）指针</span></span><br><span class="line"><span class="hljs-keyword">int</span> ltag , rtag; <span class="hljs-comment">//线索标记</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>根据二叉树的遍历方式的不同，线索二叉树可以分为先序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中的所有结点的空指针按照某种遍历方式加上线索的过程叫做二叉树的线索化，被线索化的二叉树就称为线索二叉树。<br><strong>通过中序遍历对二叉树线索化代码：</strong></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">InThread(p -&gt; lchild,pre); <span class="hljs-comment">// 递归地线索化左子树</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p -&gt; lchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立当前结点前驱线索</span></span><br><span class="line">p -&gt; lchild = pre;</span><br><span class="line">p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// 建立前驱结点的后继线索</span></span><br><span class="line">pre -&gt; rchild = p;</span><br><span class="line">pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = p; <span class="hljs-comment">// pre 跟上 p，之后p会指向下一个结点</span></span><br><span class="line">InThread(p -&gt; rchild,pre); <span class="hljs-comment">// 递归地线索化右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>通过中序遍历线索二叉树的主程序如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creatTBTNode</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line">TBTNode *pre = <span class="hljs-literal">NULL</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">InThread(root,pre); <span class="hljs-comment">//递归建立线索二叉树</span></span><br><span class="line">pre -&gt; rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处理最后一个结点</span></span><br><span class="line">pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>遍历中序线索二叉树：</strong><br><em>寻找中序线索二叉树 root 的第一个遍历结点：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">First</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>( root -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">root = root -&gt; lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>在中序线索二叉树中，求结点p在中序下的后继结点的算法：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">TBTNode *<span class="hljs-title">Next</span><span class="hljs-params">(TBTNode *p)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> First(p -&gt; rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> p -&gt; rchild;  <span class="hljs-comment">// rtag = 1; 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>在中序线索二叉树上执行中序遍历：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inoreder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (TBTNode *p = First(root);p != <span class="hljs-literal">NULL</span>;p = Next(p))&#123;</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>通过前序遍历对二叉树线索化</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preInThread</span><span class="hljs-params">(TBTNode *p,TBTNode *&amp;pre)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p -&gt; lchild != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">p -&gt; lchild = pre;</span><br><span class="line">p -&gt; ltag = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre -&gt; rchild == <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">pre -&gt; rchild = p;</span><br><span class="line">pre -&gt; rtag = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = p;</span><br><span class="line"><span class="hljs-keyword">if</span> (p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">preThread(p -&gt; lchild,pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (p -&gt; rtag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">preThread(p -&gt; rchild,pre);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>遍历前序线索二叉树算法：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TBTNode *root)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">TBTNode *p = root;</span><br><span class="line"><span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(p -&gt; ltag == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">Visit(p);</span><br><span class="line">p = p -&gt; lchild;</span><br><span class="line">&#125;</span><br><span class="line">Visit(p);</span><br><span class="line">p = p -&gt; rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="树与森林的互相转换"><a href="#树与森林的互相转换" class="headerlink" title="树与森林的互相转换"></a>树与森林的互相转换</h4><hr><hr><h4 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h4><hr><h5 id="二叉排序树与二叉平衡树"><a href="#二叉排序树与二叉平衡树" class="headerlink" title="二叉排序树与二叉平衡树"></a>二叉排序树与二叉平衡树</h5><hr><h5 id="赫夫曼树与赫夫曼编码"><a href="#赫夫曼树与赫夫曼编码" class="headerlink" title="赫夫曼树与赫夫曼编码"></a>赫夫曼树与赫夫曼编码</h5><hr><p><strong>赫夫曼树的相关概念及介绍：</strong><br>赫夫曼树又被称为最优二叉树，它的特点是<strong>带权路径最短</strong>。下面介绍几个相关概念：</p><ul><li><strong>路径：</strong>指从树中一个结点到另一个结点的分支所构成的路线</li><li><strong>路径长度：</strong>路径上的分支数目</li><li><strong>树的路径长度：</strong>从根到<strong>每个结点</strong>的路径长度之和</li><li><strong>带权路径长度：</strong>结点具有<strong>权值</strong>，从该结点到<strong>根结点</strong>的路径长度乘于该结点的权值就是该结点的带权路径长度</li><li><strong>树的带权路径长度（WPL）：</strong>树中所有<strong>叶子结点</strong>的带权路径长度之和</li></ul><p><strong>赫夫曼树的构造方法：</strong><br>给定$n$个权值，用这些个权值来构造赫夫曼树：<br>首先了解一下赫夫曼树的一些特点：</p><ul><li>权值越大的结点距离根节点越近</li><li>树中没有度为1的结点</li><li>树的带权路径长度最短</li></ul><p>根据上述特点反推我们是如何来构造一个赫夫曼树：</p><ul><li>从最底层开始构造</li><li>最底层结点离根节点月远故其路径长度最大，而为使其带权路径长度最短，应选择权值最小的结点作为最底层结点</li><li>权值最大的结点离根节点最近</li></ul><p>有了上述导论我们就可以开始构造一棵赫夫曼树了：<br><img src="https://i.loli.net/2019/01/28/5c4e5b7780558.png" alt=""><br>上图构建的赫夫曼树的WPL为：$8×1+7×2+5×3+4×4+2×4=61$,这是这些结点所能构造的所有不同的树中树的带权路径长度最小的构造方式。</p><h5 id="赫夫曼编码："><a href="#赫夫曼编码：" class="headerlink" title="赫夫曼编码："></a>赫夫曼编码：</h5><hr><h6 id="利用赫夫曼树的特点来对文件进行压缩存储"><a href="#利用赫夫曼树的特点来对文件进行压缩存储" class="headerlink" title="* 利用赫夫曼树的特点来对文件进行压缩存储"></a>* 利用赫夫曼树的特点来对文件进行压缩存储</h6><hr><p>看个例子：如果有这样一串字符将要被存储于计算机中$AECCBCDEEDECCCBAEEEBECDDBB$<br>选三位长度的二进制数为A到E编码：<br><img src="https://i.loli.net/2019/01/28/5c4e5b7755d25.png" alt=""><br>根据上表我们可以将该字符串编码为：<br>$000100010010001010011100100011100010010010001000100100100001000100100100001100010011011001001$<br>解码时每三位一个字符解码<br>总共需要78位来存储这个字符串，是否有根节省空间的编码形式呢？</p><p>答案是肯定的，我们统计一下这个字符串中各个字符出现的频率（权值）：<br><img src="https://i.loli.net/2019/01/28/5c4e5bf2c8c41.png" alt=""><br>利用上表的信息构建一棵霍夫曼树，并将树中每个结点的左右分支进行编号（左0右1）：<br><img src="https://i.loli.net/2019/01/28/5c4e5bf2d25e8.png" alt=""><br>到此我们得到了对A到E的霍夫曼编码规则：<br><img src="https://i.loli.net/2019/01/28/5c4e5bf2c9721.png" alt=""><br>根据上表的编码规则可将字符串编码为：<br>$1110010101101011110011110101010110111000011001011111111110110$<br>只需61位的空间就能存储该字符串，可以直观地发现比普通编码短了很多。</p><p><strong>解码霍夫曼编码：</strong><br>解码霍夫曼编码需要用到上诉的那棵霍夫曼树，从左至右依次读取字符串编码，从根结点开始，读取到1则向右分支走，读取到0则向左分支走，直到走到叶子结点并读取该结点。</p><hr><ul><li>[注] <em>对于同一组结点，构造出的霍夫曼树是不唯一的。但是，得到的不同的霍夫曼树的WPL却是相同的</em></li></ul><h5 id="霍夫曼-n-叉树"><a href="#霍夫曼-n-叉树" class="headerlink" title="霍夫曼$n$叉树"></a>霍夫曼$n$叉树</h5><ul><li><em>霍夫曼树不都是二叉树，霍夫曼二叉树只是霍夫曼$n$叉树的一种特例</em></li></ul><hr><p>构造霍夫曼$n$叉树的逻辑与构造霍夫曼二叉树并无二异，我们知道对于结点数目大于等于2的待处理序列都可以构造霍夫曼二叉树。但却不一定能用来构造霍夫曼n叉树，构造n叉树的结点数目要求为大于等于3的奇数，若非奇数可以加上一个权值为0的结点。<br><img src="https://i.loli.net/2019/01/28/5c4e5bf2d661c.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;树的基本概念&quot;&gt;&lt;a href=&quot;#树的基本概念&quot; class=&quot;headerlink&quot; title=&quot;树的基本概念&quot;&gt;&lt;/a&gt;树的基本概念&lt;/h4&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移后的发布测试</title>
    <link href="https://www.ccyh.xyz/2019/03/05/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%90%8E%E7%9A%84%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.ccyh.xyz/2019/03/05/博客迁移后的发布测试/</id>
    <published>2019-03-05T15:25:42.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试文章发布是否正常"><a href="#测试文章发布是否正常" class="headerlink" title="测试文章发布是否正常"></a>测试文章发布是否正常</h1><blockquote><p>迁移过程之后会整理出来<br><a id="more"></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;测试文章发布是否正常&quot;&gt;&lt;a href=&quot;#测试文章发布是否正常&quot; class=&quot;headerlink&quot; title=&quot;测试文章发布是否正常&quot;&gt;&lt;/a&gt;测试文章发布是否正常&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;迁移过程之后会整理出来&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【数据结构】数组、矩阵、和广义表</title>
    <link href="https://www.ccyh.xyz/2019/03/01/arrayandlist/"/>
    <id>https://www.ccyh.xyz/2019/03/01/arrayandlist/</id>
    <published>2019-03-01T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><a id="more"></a><ol><li><p>常见的数组有一维数组和二维数组，二维数组是元素可以看成是一维数组的一维数组。对于数组主要考察元素下标计算的问题。对于一维数组较为简单，而对于二维数组的元素位置计算较为复杂，要考虑行优先和列优先两种情况。</p></li><li><p>二维数组的行优先和列优先存储：</p></li></ol><ul><li><p>行优先：从起始行开始一行一行地存入连续空间中<br><img src="https://i.loli.net/2019/01/28/5c4e6390a5c03.png" alt=""></p></li><li><p>列优先：从起始列开始一列一列地存入连续空间中<br><img src="https://i.loli.net/2019/01/28/5c4e6390a5e44.png" alt=""></p></li></ul><hr><h4 id="矩阵的压缩存储："><a href="#矩阵的压缩存储：" class="headerlink" title="矩阵的压缩存储："></a>矩阵的压缩存储：</h4><hr><h5 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h5><ul><li>矩阵一般用一个二维数组A[m][n]表示，表示一个m行n列的矩阵</li><li>其中m n 必须为常量，或者为预先定义的宏常量，如下：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> m 5</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 6</span></span><br><span class="line"><span class="hljs-keyword">int</span> A[m][n];</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="矩阵的一般操作与实现"><a href="#矩阵的一般操作与实现" class="headerlink" title="矩阵的一般操作与实现"></a>矩阵的一般操作与实现</h5><ol><li><p>矩阵的转置：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[][maxsize],<span class="hljs-keyword">int</span> B[][maxsize],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; ++i)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n ; ++j)&#123;</span><br><span class="line">B[j][i] = A[i][j]; <span class="hljs-comment">// 矩阵转置操作，元素关于主对角线互换位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩阵相加:</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[][max],<span class="hljs-keyword">int</span> B[][max],<span class="hljs-keyword">int</span> C[][max],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; ++i)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n)&#123;</span><br><span class="line">c[i][j] = A[i][j] + B[i][j]; <span class="hljs-comment">//对应位置元素相加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩阵相乘：</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[m][n],<span class="hljs-keyword">int</span> B[n][k],<span class="hljs-keyword">int</span> C[m][k],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;k;++j)&#123;</span><br><span class="line">C[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;h&lt;n;++h)&#123;</span><br><span class="line">C[i][j] += A[i][h] * B[h][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="特殊矩阵和稀疏矩阵"><a href="#特殊矩阵和稀疏矩阵" class="headerlink" title="特殊矩阵和稀疏矩阵"></a>特殊矩阵和稀疏矩阵</h4><hr><ul><li>矩阵中绝大多数元素都是0的矩阵称为稀疏矩阵(国外教材)</li><li>相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵(严版)</li></ul><hr><ol><li><strong>特殊矩阵</strong>：<br>a) 对称矩阵</li></ol><ul><li>矩阵中的元素满足A[i][j] = A[j][i] 的矩阵称为对称矩阵<br><img src="https://i.loli.net/2019/01/28/5c4e6390bcb16.png" alt=""></li><li>如上图所示，只需要存储一半的元素就可以了，要还原出另一半只需根据A[i][j] = A[j][i]这个条件就行了。</li><li>将一个n×n的对称矩阵存储在一维数组中，所需的存储空间为 $ \dfrac{(1+n)·n}{2}$</li><li>需要保存的元素为：<br><img src="https://i.loli.net/2019/01/28/5c4e6390c2474.png" alt=""></li><li>按照行优先来存储，保存在一维数组中，如下图所示：<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2019/01/28/5c4e6390a79d5.png" alt=""></h2>b)三角阵</li><li><em>上三角矩阵</em> 为矩阵下三角部分(不包括对角线)元素全为零</li><li><em>下三角矩阵</em> 为矩阵上三角部分(不包括对角线)元素全为零</li><li>三角矩阵的存储方式与对称矩阵类似，以下三角矩阵的存储为例，只需存储对角线及其以下部分的元素和其上三角中的一个元素C即可，如下图：<br><img src="https://i.loli.net/2019/01/28/5c4e639143171.png" alt=""></li></ul><hr><p>c)对角矩阵</p><ul><li>如下图所示的对角矩阵，其特点为除了主对角线以及其上下两条带状区域的元素外，其余元素都为C ( C可以为0)：<br><img src="https://i.loli.net/2019/01/28/5c4e63916c70f.png" alt=""></li><li>下面介绍如何求出第i行带状区域内的第一个元素在一维数组中的下标，假设c存在数组的最后一位：</li><li>当i=1时，带状区域内的第一个元素为矩阵当中的第一个元素，其在一维数组中的下标为0；</li><li><p>当i&gt;1时，第i行之前的元素个数为 $2+(i-2)×3$，则带状区域的第一个元素在一维数组中的下标为 $2+(i-2)×3$<br>2.<strong>稀疏矩阵</strong></p></li><li><p>稀疏矩阵中的相同元素c不像特殊矩阵中的相同元素的位置分布那么有规律可循，故必须为其设计一些特殊的存储结构</p></li><li><strong>稀疏矩阵的顺序存储及其相关操作：</strong><br>常用的稀疏矩阵顺序存储方法有三元组表示法，和伪地址表示法。</li></ul><hr><ol><li>三元组表示法：<br>三元组数据结构为一个长度为n，表内每个元素都有三个分量的线性表，其三个分量分别为：“值”、“行下标”、“列下标”。<br>元素结构体定义如下：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trimat</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> val; <span class="hljs-comment">// 值</span></span><br><span class="line"><span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 行下标</span></span><br><span class="line"><span class="hljs-keyword">int</span> j; <span class="hljs-comment">// 列下标</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></li></ol><p>结构体示意图：<br><img src="https://i.loli.net/2019/01/28/5c4e639149062.png" alt=""><br>结构题数组的定义：<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Trimat trimat[maxterms + 1]; // maxterms + 1;因为从第 1 行才开始存储元素</span><br></pre></td></tr></table></figure></p><p>但是，为了方便起见，一般不用上诉结构体来定义三元组，直接申请一个二维数组就可以了：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> trimat[maxterms + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-comment">// 如要求其他类型，可将int替换掉</span></span><br><span class="line"><span class="hljs-comment">// 需要注意的是，如果矩阵是float型的（或者其他非整型的数据类型）</span></span><br><span class="line"><span class="hljs-comment">// 则此时用一个数组来表示三元组应该写成如下形式：</span></span><br><span class="line"><span class="hljs-keyword">float</span> trimat[maxterms + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-comment">// 这个时候若要取当前非零元素的所在位置应该这么做：</span></span><br><span class="line">(<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">1</span>];</span><br><span class="line">(<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-comment">// 就是将float 型的元素造型成int型，这样就可以避免很多不必要的问题的发生</span></span><br></pre></td></tr></table></figure></p><p>上诉定义方式中：trimat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值<br>trimat[k][1]、trimat[k][2]表示第k个非零元素在矩阵中的位置。事实上，trimat此时就是一个maxterms 行 3 列的二维数组，我们规定第0行的三个元素分别用来存储原矩阵中的非零元素个数，以及矩阵的行数与列数。<br>示意图如下：<br><img src="https://i.loli.net/2019/01/28/5c4e639152b65.png" alt=""></p><hr><ul><li>给定一个二维数组存储的矩阵，要求设计算法将其转化为三元组存储：</li><li><p>算法分析：<br>建立一个三元组的核心问题在于求矩阵的非零元素个数以及非零元素的值，还有其在矩阵（原数组）中的位置，故只需扫描所给矩阵的二维数组即可得到相关数据，进而建立三元组。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 建立三元组时，结点间的次序行按元素在矩阵中的行优先顺序排列</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creattrimat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> A[][max],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">float</span> B[][<span class="hljs-number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="hljs-comment">// m,n 表示所给矩阵的规模为m×n</span></span><br><span class="line"><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;++j)&#123; <span class="hljs-comment">// 双重循环扫描矩阵</span></span><br><span class="line"><span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 若矩阵的[i][j] 上的元素不为零，将该元素连同其位置信息存入三元组中</span></span><br><span class="line">B[k][<span class="hljs-number">0</span>] = A[i][j];</span><br><span class="line">B[k][<span class="hljs-number">1</span>] = i;</span><br><span class="line">B[k][<span class="hljs-number">2</span>] = j;</span><br><span class="line">k++; <span class="hljs-comment">// k 指向三元组的下一个空间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = k<span class="hljs-number">-1</span>; <span class="hljs-comment">// 将矩阵的基本信息存入三元组的第0行</span></span><br><span class="line">B[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = m;</span><br><span class="line">B[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计算法打印出所给三元组存储的矩阵：</p></li><li>算法分析：<br>读取三元组的第0行，得到矩阵的相关信息<br>循环按行打印，若下标与三元组中的非零元素下标信息匹配则打印该非零元素，否则，打印0；<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">float</span> trimat[][<span class="hljs-number">3</span>])</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> m = trimat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> n = trimat[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; <span class="hljs-comment">// 非零元素从第一行开始存储</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123; <span class="hljs-comment">// 双重循环打印矩阵</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123; <span class="hljs-comment">// 循环过程中检查第[i][j]下标是否与三元组中的非零元素相同，若相同打印该非零元素，若不同打印 0 ；</span></span><br><span class="line"><span class="hljs-keyword">if</span>(i = (<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">1</span>] &amp;&amp; j == (<span class="hljs-keyword">int</span>)trimat[k][<span class="hljs-number">2</span>])&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; trimat[k][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line">++k; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0 "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li>伪地址表示法：<br>伪地址表示法与三元组表示法在本质上并无差别，只不过是三元组表示法的每一行用两个存储单元来存放原矩阵非零元素的位置标记，而伪地址表示法可以只用一个存储单元来存放位置标记，原因是因为对于一个$ m·n $的矩阵，伪地址表示法将元素位置下标的两个整数用一个公式映射( $ n·(i-1) +j $)到了一个整数上，同样利用该公式也可还原原i和j的值。<br>我们来看一个例子：<br><img src="https://i.loli.net/2019/01/28/5c4e63917d8a6.png" alt=""></li></ol><hr><ul><li><strong>稀疏矩阵的链式存储及相关操作：</strong></li></ul><hr><ol><li>邻接表表示法：<br>邻接表表示法将矩阵中每一行的非零元素串联成一个单链表，链表结点中有三个分量：元素值、所在列、指针域<br>结点的定义如下：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listmat</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> data;</span><br><span class="line"><span class="hljs-keyword">int</span> col;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listmat</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>示意图如下：<br><img src="https://i.loli.net/2019/01/28/5c4e63f53599f.png" alt=""><br>上图中最左端为一个指针数组，用来存储指向每一行非零元素单链表的头指针，数组下标为表示行标号。</p><ol start="2"><li>十字链表表示法：<br>在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点有 5 个分量：行分量、列分量、数据域、指向下方结点的指针域、指向右方结点的指针域；结构图如下：<br><img src="https://i.loli.net/2019/01/28/5c4e63f53b90a.png" alt=""><br>普通结点定义：<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> row;</span><br><span class="line"><span class="hljs-keyword">int</span> col;</span><br><span class="line"><span class="hljs-keyword">int</span> data;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">down</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>头结点定义:<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CrossList</span>&#123;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> *<span class="hljs-title">rhead</span>,*<span class="hljs-title">cheard</span>;</span> <span class="hljs-comment">// 指向两头结点数组的指针</span></span><br><span class="line"><span class="hljs-keyword">int</span> m,n,k; <span class="hljs-comment">// 矩阵行数、列数、非零结点总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于十字链表存储结构比较复杂，我们将通过其结构图例来深入了解它，图中附有详细的注释：</p><p><img src="https://i.loli.net/2019/01/28/5c4e63f57d237.png" alt=""><br>上图中，银灰色的结点为行头结点数组与列头结点数组，他们的定义如下：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 其中的m n 为矩阵的行数和列数</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rhead</span>&#123;</span> <span class="hljs-comment">// 行头结点数组</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> <span class="hljs-title">Rhead</span>[<span class="hljs-title">m</span>];</span>  <span class="hljs-comment">// 元素为matNode结点的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chead</span>&#123;</span> <span class="hljs-comment">// 列头结点数组</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matNode</span> <span class="hljs-title">Chead</span>[<span class="hljs-title">n</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><ul><li>在理解了十字链表存储结构后，我们来看一个实际的应用：<br>给定一个float型二维数组存储的稀疏矩阵，建立其对应的十字链表结构。<br><strong>算法分析</strong>：<br>首先应该建立整体框架，也就是十字链表头结点以及行、列头结点数组。然后，按行优先顺序遍历矩阵数组，若发现不为零的元素，分配一个结点空间将其值存入，调整行、列头结点的指针域指向该结点，如此直到结束遍历<figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">creatCrossListmat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> A[][maxsize],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k,CrossList &amp;M)</span></span>&#123;</span><br><span class="line"><span class="hljs-comment">//============================================</span></span><br><span class="line"><span class="hljs-comment">// 搭建基本框架操作</span></span><br><span class="line"><span class="hljs-comment">//============================================</span></span><br><span class="line"><span class="hljs-comment">// 清空处理：</span></span><br><span class="line"><span class="hljs-keyword">if</span> (M.rhead) <span class="hljs-built_in">free</span>(M.rhead);</span><br><span class="line"><span class="hljs-keyword">if</span> (M.chead) <span class="hljs-built_in">free</span>(M.chead);</span><br><span class="line"><span class="hljs-comment">// 将矩阵信息存入十字链表头结点：</span></span><br><span class="line">M.m = m;</span><br><span class="line">M.n = n;</span><br><span class="line">M.k = k;</span><br><span class="line"><span class="hljs-comment">// 申请行、列头结点数组空间：</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(M.rhead = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode)*m)))</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(M.chead = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode)*n)))</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">// 将行、列头结点数组的right和down指针置空：</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m ; ++i)&#123;</span><br><span class="line">M.rhead[i].right = <span class="hljs-literal">NULL</span>;</span><br><span class="line">M.rhead[i].down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n ;++i)&#123;</span><br><span class="line">M.chead[i].right = <span class="hljs-literal">NULL</span>;</span><br><span class="line">M.chead[i].down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//===================================================</span></span><br><span class="line"><span class="hljs-comment">// 核心算法</span></span><br><span class="line"><span class="hljs-comment">//===================================================</span></span><br><span class="line"><span class="hljs-comment">// 建立链表的辅助指向列头结点的指针数组：</span></span><br><span class="line">matNode *temp_r[maxsize];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">temp_r[i] = &amp;(M.chead[i]); <span class="hljs-comment">// 引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 行优先顺序遍历矩阵数组构建十字链表：</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m ;++i)&#123;</span><br><span class="line">matNode *c = &amp;(M.rhead[i]);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>)&#123;</span><br><span class="line">matNode *p = (matNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(matNode));</span><br><span class="line">p -&gt; row = i;</span><br><span class="line">p -&gt; col = j;</span><br><span class="line">p -&gt; val = A[i][j];</span><br><span class="line">p -&gt; down = <span class="hljs-literal">NULL</span>;</span><br><span class="line">p -&gt; right = <span class="hljs-literal">NULL</span>;</span><br><span class="line"><span class="hljs-comment">// 如果某行（列）中已经连接了元素，那么就让这个元素充当该行（列）的头部，这样能使十字链表的行（列）头结点数组中的结点避免重复指向，覆盖；所以下面的代码所要做的事情很重要。</span></span><br><span class="line">c -&gt; right = p; </span><br><span class="line">c = p;</span><br><span class="line">temp_r[j] -&gt; down = p;</span><br><span class="line">temp_r[j] = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子类型的元素，也可以是广义表的一种线性表</li></ul><hr><h5 id="三个重要概念："><a href="#三个重要概念：" class="headerlink" title="三个重要概念："></a>三个重要概念：</h5><ul><li><strong>广义表的长度</strong>：表中最上层元素的个数</li><li><strong>广义表的深度</strong>：表中括号的最大层数，求解时应将所有的子表展开在分析</li><li><strong>表头(Head)和表尾(Tail)</strong>：当表非空时，第一个元素为广义表的表头，其余元素组成广义表的表尾<h5 id="两种存储结构："><a href="#两种存储结构：" class="headerlink" title="两种存储结构："></a>两种存储结构：</h5></li><li><strong>头尾链表存储结构</strong>：<br>这种存储结构有两种结点，即原子结点和广义表结点。原子结点有两个域：标记域、数据域。广义表结点有三个域：标记域、头指针域、尾指针域<br>其中头指针指向一个原子结点或广义表结点，尾指针为空或者指向 <strong>本层中</strong> 的下一个广义表结点，而标记域用来区分广义表结点(1)与原子结点(0);<br><strong>示意图入下：</strong><br><img src="https://i.loli.net/2019/01/28/5c4e63f53c096.png" alt=""></li><li><strong>扩展线性表结构</strong>：<br>该种存储结构同样有两种结点，与头尾链表存储结构不同的是这里的原子结点有三个域：标记域、数据域、尾指针域。<br><strong>示意图如下：</strong><br><img src="https://i.loli.net/2019/01/28/5c4e63f537beb.png" alt=""></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;数组：&quot;&gt;&lt;a href=&quot;#数组：&quot; class=&quot;headerlink&quot; title=&quot;数组：&quot;&gt;&lt;/a&gt;数组：&lt;/h4&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Array" scheme="https://www.ccyh.xyz/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>【算法】String实现大数运算算法汇总</title>
    <link href="https://www.ccyh.xyz/2019/02/28/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://www.ccyh.xyz/2019/02/28/【算法】大数运算算法汇总/</id>
    <published>2019-02-28T21:19:31.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法:"></a>大数加法:</h3><a id="more"></a><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max 1000</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bign</span>//定义一个结构体表示大数</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> dig[max];<span class="hljs-comment">//由低位到高位存放大数的低位到高位的各位数值</span></span><br><span class="line"><span class="hljs-keyword">int</span> len;<span class="hljs-comment">//保存大数的位数</span></span><br><span class="line">bign()&#123;<span class="hljs-comment">//初始化函数</span></span><br><span class="line">dig[max] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line">len = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s_to_array</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s,bign &amp;d)</span><span class="hljs-comment">//字符串转数组</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> s_len = (<span class="hljs-keyword">int</span>)s.size();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = s_len<span class="hljs-number">-1</span>;j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; max;i++,j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(s[j]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; s[j]&lt;=<span class="hljs-string">'9'</span>)</span><br><span class="line">d.dig[i] = (<span class="hljs-keyword">int</span>)(s[j] - <span class="hljs-string">'0'</span>);</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">throw</span> invalid_argument(<span class="hljs-string">"无效的输入，只能由数字构成！！！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">d.len = s_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(bign &amp;a,bign &amp;b,bign &amp;ans)</span><span class="hljs-comment">//大数加法函数</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span></span><br><span class="line"><span class="hljs-keyword">int</span> re;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; a.len || i &lt; b.len;i++)</span><br><span class="line">&#123;</span><br><span class="line">re = a.dig[i] + b.dig[i] + carry;</span><br><span class="line">ans.dig[ans.len++] = re%<span class="hljs-number">10</span>;<span class="hljs-comment">//取个位</span></span><br><span class="line">carry = re/<span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans.dig[ans.len++] = carry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">string</span> num;</span><br><span class="line"><span class="hljs-built_in">string</span> num1;</span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; num &gt;&gt; num1)</span><br><span class="line">&#123;</span><br><span class="line">bign a,b;</span><br><span class="line">bign ans;</span><br><span class="line"><span class="hljs-keyword">try</span>&#123;</span><br><span class="line">s_to_array(num,a);</span><br><span class="line">s_to_array(num1,b);</span><br><span class="line">&#125;<span class="hljs-keyword">catch</span>(invalid_argument err)&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please Try Again"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.len<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; a.dig[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"+"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b.len<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; b.dig[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">add(a,b,ans);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = ans.len<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; ans.dig[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="大数减法"><a href="#大数减法" class="headerlink" title="大数减法:"></a>大数减法:</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">char</span> s1[],<span class="hljs-keyword">char</span> s2[],<span class="hljs-keyword">char</span> t[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i,l1,l2,k;</span><br><span class="line">    l1 = <span class="hljs-built_in">strlen</span>(s1);</span><br><span class="line">    l2 = <span class="hljs-built_in">strlen</span>(s2);</span><br><span class="line">    t[l1] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">    l1--;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=l2<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--,l1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s1[l1]-s2[i] &gt;= <span class="hljs-number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[l1] = s1[l1] - s2[i] + <span class="hljs-string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t[l1] = <span class="hljs-number">10</span> + s1[l1] - s2[i] + <span class="hljs-string">'0'</span>;</span><br><span class="line">            s1[l1<span class="hljs-number">-1</span>] = s1[l1<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k = l1;</span><br><span class="line">    <span class="hljs-keyword">while</span>(s1[k]&lt;<span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s1[k] += <span class="hljs-number">10</span>;</span><br><span class="line">        s1[k<span class="hljs-number">-1</span>] -= <span class="hljs-number">1</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span>(l1&gt;<span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[l1] = s1[l1];</span><br><span class="line">        l1--;</span><br><span class="line">    &#125;</span><br><span class="line">loop:</span><br><span class="line">    <span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        l1 = <span class="hljs-built_in">strlen</span>(s1);</span><br><span class="line">        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;l1<span class="hljs-number">-1</span>;i++)</span><br><span class="line">            t[i] = t[i+<span class="hljs-number">1</span>];</span><br><span class="line">        t[l1<span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">        <span class="hljs-keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(t) == <span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[<span class="hljs-number">0</span>] = <span class="hljs-string">'0'</span>;</span><br><span class="line">        t[<span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> c[<span class="hljs-number">1000</span>],t[<span class="hljs-number">1000</span>],sum[<span class="hljs-number">1000</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> m;</span><br><span class="line">    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>,c,t))</span><br><span class="line">    &#123;</span><br><span class="line">        sub(c,t,sum);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法:"></a>大数乘法:</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mult</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a[],<span class="hljs-keyword">char</span> b[],<span class="hljs-keyword">char</span> s[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i,j,k=<span class="hljs-number">0</span>,alen,blen,sum=<span class="hljs-number">0</span>,res[<span class="hljs-number">65</span>][<span class="hljs-number">65</span>]=&#123;<span class="hljs-number">0</span>&#125;,flag=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">char</span> result[<span class="hljs-number">65</span>];</span><br><span class="line">    alen = <span class="hljs-built_in">strlen</span>(a);</span><br><span class="line">    blen = <span class="hljs-built_in">strlen</span>(b);</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;alen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;blen;j++)</span><br><span class="line">            res[i][j] = (a[i]-<span class="hljs-string">'0'</span>)*(b[j]-<span class="hljs-string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=alen<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(j=blen<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum + res[i+blen-j<span class="hljs-number">-1</span>][j];</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"res = %d\n"</span>,res[i+blen-j<span class="hljs-number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        result[k] = sum%<span class="hljs-number">10</span>;</span><br><span class="line">        k++;</span><br><span class="line">        sum /= <span class="hljs-number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(sum)</span><br><span class="line">    &#123;</span><br><span class="line">        result[k] = sum;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i] += <span class="hljs-string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = result[k<span class="hljs-number">-1</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[k] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(s) != <span class="hljs-built_in">strlen</span>(a) &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>)</span><br><span class="line">            <span class="hljs-built_in">strcpy</span>(s,s+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> c[<span class="hljs-number">1000</span>],t[<span class="hljs-number">1000</span>],sum[<span class="hljs-number">1000</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> m;</span><br><span class="line">    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>,c,t))</span><br><span class="line">    &#123;</span><br><span class="line">        mult(c,t,sum);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="大数除以小数"><a href="#大数除以小数" class="headerlink" title="大数除以小数:"></a>大数除以小数:</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringToNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str,<span class="hljs-keyword">int</span> num[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//字符串转int数组</span></span><br><span class="line"><span class="hljs-keyword">int</span> len = str.length();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i+<span class="hljs-number">1</span>] = str[i] - <span class="hljs-string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">num[<span class="hljs-number">0</span>] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> div[],<span class="hljs-keyword">int</span> ans[],<span class="hljs-keyword">int</span> divisor)</span><span class="hljs-comment">//得到div除于divisor的结果</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//int carry = 0;</span></span><br><span class="line"><span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<span class="hljs-comment">//保存上一步的余数</span></span><br><span class="line"><span class="hljs-keyword">int</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= div[<span class="hljs-number">0</span>];i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp*<span class="hljs-number">10</span> + div[i];</span><br><span class="line"><span class="hljs-keyword">if</span>(temp &lt; divisor) ans[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//不够除，ans[i]为0</span></span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//够除</span></span><br><span class="line">ans[i] = temp/divisor;<span class="hljs-comment">//ans[i]为商</span></span><br><span class="line">temp = temp % divisor;<span class="hljs-comment">//更新余数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//保存长度标记</span></span><br><span class="line"><span class="hljs-keyword">return</span> temp;<span class="hljs-comment">//返回余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">string</span> str;</span><br><span class="line"><span class="hljs-keyword">int</span> dividend[<span class="hljs-number">1001</span>];<span class="hljs-comment">//被除数</span></span><br><span class="line"><span class="hljs-keyword">int</span> ans[<span class="hljs-number">1001</span>];<span class="hljs-comment">//结果</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">StringToNum(str,dividend);</span><br><span class="line">DecToBinary(dividend,ans);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = ans[<span class="hljs-number">0</span>];i &gt; <span class="hljs-number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">int carry = DivideTwo(dividend,ans);</span></span><br><span class="line"><span class="hljs-comment">for(int i=1;i &lt; ans[0];i++)</span></span><br><span class="line"><span class="hljs-comment">&#123;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; ans[i];</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br><span class="line"><span class="hljs-comment">ans[1001] = &#123;0&#125;;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; ".............."&lt;&lt;carry&lt;&lt; endl;</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="大数阶乘"><a href="#大数阶乘" class="headerlink" title="大数阶乘:"></a>大数阶乘:</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> *)</span></span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> b[<span class="hljs-number">10000</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        factorial(n,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> b[<span class="hljs-number">10000</span>])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">long</span> a[<span class="hljs-number">10000</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> i,j,l,c,m=<span class="hljs-number">0</span>,w;</span><br><span class="line">    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c=<span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[j] * i + c;</span><br><span class="line">            c = a[j]/<span class="hljs-number">10000</span>;</span><br><span class="line">            a[j] = a[j]%<span class="hljs-number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m++;</span><br><span class="line">            a[m] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w = m*<span class="hljs-number">4</span> + <span class="hljs-built_in">log10</span>(a[m])+<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; a[m];</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="大整数乘以小数"><a href="#大整数乘以小数" class="headerlink" title="大整数乘以小数:"></a>大整数乘以小数:</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mult</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c[],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">char</span> t[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(c);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[len-i<span class="hljs-number">-1</span>] = c[i] - <span class="hljs-string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> flag,add=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> k = s[i] * m + add;</span><br><span class="line">        <span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = k % <span class="hljs-number">10</span>;</span><br><span class="line">            add = k / <span class="hljs-number">10</span>;</span><br><span class="line">            flag = <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = k;</span><br><span class="line">            add = <span class="hljs-number">0</span>;</span><br><span class="line">            flag = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span>(add)</span><br><span class="line">    &#123;</span><br><span class="line">        s[len++] = add % <span class="hljs-number">10</span>;</span><br><span class="line">        add /= <span class="hljs-number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)</span><br><span class="line">        t[len-i<span class="hljs-number">-1</span>] = s[i] + <span class="hljs-string">'0'</span>;</span><br><span class="line">    t[len] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//大数加小数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addt</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a[],<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">char</span> c[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(a);</span><br><span class="line">    <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)</span><br><span class="line">        s[len-i<span class="hljs-number">-1</span>] = a[i] - <span class="hljs-string">'0'</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(i&gt;=len)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = <span class="hljs-number">0</span>;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> k = s[i] + b % <span class="hljs-number">10</span> + add;</span><br><span class="line">        b /= <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = k%<span class="hljs-number">10</span>;</span><br><span class="line">            add = k/<span class="hljs-number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = k;</span><br><span class="line">            add = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span> &amp;&amp; add==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[len-i<span class="hljs-number">-1</span>] =  s[i] + <span class="hljs-string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[len] = <span class="hljs-string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> c[<span class="hljs-number">1000</span>],t[<span class="hljs-number">1000</span>],sum[<span class="hljs-number">1000</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> m;</span><br><span class="line">    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        mult(c,m,t);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,t);</span><br><span class="line">        addt(c,m,sum);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;大数加法&quot;&gt;&lt;a href=&quot;#大数加法&quot; class=&quot;headerlink&quot; title=&quot;大数加法:&quot;&gt;&lt;/a&gt;大数加法:&lt;/h3&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【底层原理】浮点数在计算机中的表示</title>
    <link href="https://www.ccyh.xyz/2019/02/22/%E3%80%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>https://www.ccyh.xyz/2019/02/22/【底层原理】浮点数在计算机中的表示/</id>
    <published>2019-02-22T13:26:52.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一道C语言题："><a href="#一道C语言题：" class="headerlink" title="一道C语言题："></a>一道C语言题：</h1><a id="more"></a><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> num = <span class="hljs-number">9</span>;</span><br><span class="line">    <span class="hljs-keyword">float</span> *pFloat = &amp;num;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"num 的值为：%d\n"</span>,num);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*pFloat 的值为：%f\n"</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">    *pFloat = <span class="hljs-number">9.0</span>;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"num 的值为：%d\n"</span>,num);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*pFloat 的值为：%f\n"</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/20190222014746020.png" alt=""></p><p><strong>产生上述结果的原因：浮点数在计算机中的表示与整数在计算机中的表示存在差异</strong></p><hr><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="整数在计算机中的表示："><a href="#整数在计算机中的表示：" class="headerlink" title="整数在计算机中的表示："></a>整数在计算机中的表示：</h4><figure class="highlight c hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> num = <span class="hljs-number">9</span>;</span><br></pre></td></tr></table></figure><p>上面这条语句声明并定义了一个整型int变量num为9；在普通的32位计算机中，用四个字节表示int，其二进制表示为：</p><blockquote><blockquote><p>00000000 00000000 00000000 00001001</p></blockquote></blockquote><h4 id="浮点数在计算机中的表示："><a href="#浮点数在计算机中的表示：" class="headerlink" title="浮点数在计算机中的表示："></a>浮点数在计算机中的表示：</h4><p>根据国际标准IEEE 754，任意一个二进制浮点数V可以表示为下面这种形式：</p><blockquote><blockquote><p> $ V = (-1)^{s} · M · 2^{E} $</p><ul><li>s表示符号位，s=0为正，s=1为负；</li><li>M为有效数字，$1&lt;= M &lt;2$;</li><li>$2^E$表示指数位； </li></ul></blockquote></blockquote><p>如题例，十进制的 $ 9.0 $ ,写成二进制位$1001.0$,相当于：$ 1.001 · 2^{3} $,其中$ s=0,M=1.001,E=3 $;<br>十进制的$ -9.0 $,写成二进制为$ -1001.0 $,相当于：$ -1.001 · 2^{3} $,其中$ s=1,M=1.001,E=3 $;</p><p><strong>有效数字M：</strong></p><p>IEEE 745规定，对于32位的浮点数，最高的一位是符号位s，接着的8位是指数E，剩下的23位为有效数字M：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/20190222022411070.png" alt="32bIt"><br>对于64位的浮点数来说，最高的一位仍为符号位s，接着的11位是指数E，剩下的52位为有效数字M：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/20190222023402771.png" alt="64bit"><br>另外，前面提到，$1&lt;= M &lt;2$,也就是说M可以写成$1.x_1x_2x_3x_4$的形式，其中$x_1x_2x_3x_4$表示小数部分。IEEE 754规定，在计算机内包存M时， 默认这个数的第一位为 1，因此可以被舍去，这样子就可以节省一位有效数字位，使得32（64）位浮点数可以保存24（53）位的有效数字。</p><p><strong>指数E的情况稍微复杂一些：</strong></p><p>首先，E是一个无符号整数（unsign int ）,着意味着当E为8位时，其取值范围为0到255；若E为11位其取值范围为0到2047。但是我们知道，科学计数法中的E可以是负数，因此，E的真实值必须减去一个中间值。对于8位的E应减去127，对于11位的E应减去1023；</p><p>比如说，$ 2^{9} $ 的E是9，所以保存成32位浮点数时，必须保存为$E = 9+127=136$,即$10001000$。</p><p><strong>还原E的真实值时还可以分成3种情况：</strong></p><ol><li>E不全为0或不全为1:。这时可直接用E减去127（1023）即可得到E的真实值。</li><li>E全为0。这时浮点数的指数E为1-127（1-1023），有效数字M不再加上第一位，而是还原成$0.x_1x_2x_3x_4$的小数。这样做是为了表示$\pm0$,以及接近于0的很小的数字。</li><li>E全为1。这时如果有效数字M全为0，则表示$\pm$无穷大（取决于符号位s）；如果有效数字M不全为0，表示这个数是一个$NaN$。</li></ol><hr><p>到此，回顾最初的问题。</p><ol><li><p>为什么$00000000 00000000 00000000 00001001$还原成浮点数就变成了$0.000000$ 呢???<br>首先：00000000 00000000 00000000 00001001的符号位s为0表示其为正；<br>再者：00000000 00000000 00000000 00001001的指数位E为00000000（全为0），符合第2种情况，还原后的E的真实值为：$E=1-127=-126$；<br>最后：00000000 00000000 00000000 00001001的有效数字位为：$000 0000 0000 0000 0000 1001$。<br>综上：$V = (-1)^{0} · 0.00000000000000000001001 · 2^{-126} = 1.001 · 2^{-146}$<br>可以看出这是一个很小的数，故用十进制表示为0.000000.</p></li><li><p>浮点数9.0如何用二进制表示，还原成十进制后为何是1092567616 呢？<br>首先：浮点数9.0的二进制表示为1001.0，即为$1.001 · 2^3$；符号位s=0；<br>再者：有效数字M=100 0000 0000 0000 0000 0000（共23位（100后加上20个0）其中最高位1默认被省略）。<br>最后：指数E=3+127=130，即$E = 10000010_{BIN}$。<br>综上：浮点数9.0在计算机内的表示为：$0 10000010 00100000000000000000000$，将其转化为十进制就是：1091567616<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/20190222033629845.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一道C语言题：&quot;&gt;&lt;a href=&quot;#一道C语言题：&quot; class=&quot;headerlink&quot; title=&quot;一道C语言题：&quot;&gt;&lt;/a&gt;一道C语言题：&lt;/h1&gt;
    
    </summary>
    
      <category term="底层原理" scheme="https://www.ccyh.xyz/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://www.ccyh.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello Friend</title>
    <link href="https://www.ccyh.xyz/2019/02/01/hello-world/"/>
    <id>https://www.ccyh.xyz/2019/02/01/hello-world/</id>
    <published>2019-02-01T18:46:04.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="hljs-string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>90后的他月薪4000，存款百万！，为什么？</title>
    <link href="https://www.ccyh.xyz/2019/01/30/90%E5%90%8E%E7%9A%84%E4%BB%96%E6%9C%88%E8%96%AA4000%EF%BC%8C%E5%AD%98%E6%AC%BE%E7%99%BE%E4%B8%87%EF%BC%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.ccyh.xyz/2019/01/30/90后的他月薪4000，存款百万！，为什么？/</id>
    <published>2019-01-30T13:02:50.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<center>他叫阿彪（化名），来自河南某十八线小县城。2014年，大专毕业的他独自来到北京开始了北漂生涯。</center><br><center>住的是空气中都透着霉味的狭窄到只能容纳一张板床的小破房</center><br><center>干过销售，送过快递，受过白眼，尝尽疾苦与无奈。</center><center>这不是他想要的生活，他觉得他的人生应当有更多可能。</center><br><center>于是</center><br><center>他回到了熟悉的小县城</center><br><center></center><hr><a id="more"></a><hr><hr><hr><hr><hr><hr><hr><hr><h1 id="继承了他爸的百万遗产"><a href="#继承了他爸的百万遗产" class="headerlink" title="继承了他爸的百万遗产"></a><center>继承了他爸的百万遗产</center></h1><div align="center"><br><img src="https://img.116s.com/2016-08/28/14723594920005.jpg" alt=""><br></div>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;他叫阿彪（化名），来自河南某十八线小县城。2014年，大专毕业的他独自来到北京开始了北漂生涯。&lt;/center&gt;&lt;br&gt;&lt;center&gt;住的是空气中都透着霉味的狭窄到只能容纳一张板床的小破房&lt;/center&gt;&lt;br&gt;&lt;center&gt;干过销售，送过快递，受过白眼，尝尽疾苦与无奈。&lt;/center&gt;

&lt;center&gt;这不是他想要的生活，他觉得他的人生应当有更多可能。&lt;/center&gt;&lt;br&gt;&lt;center&gt;于是&lt;/center&gt;&lt;br&gt;&lt;center&gt;他回到了熟悉的小县城&lt;/center&gt;&lt;br&gt;&lt;center&gt;&lt;/center&gt;

&lt;hr&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.ccyh.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Boring" scheme="https://www.ccyh.xyz/tags/Boring/"/>
    
  </entry>
  
  <entry>
    <title>【随笔】2018年终总结</title>
    <link href="https://www.ccyh.xyz/2018/12/30/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://www.ccyh.xyz/2018/12/30/【随笔】2018年终总结/</id>
    <published>2018-12-30T16:49:57.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的2018"><a href="#我的2018" class="headerlink" title="我的2018"></a>我的2018</h1><hr><a id="more"></a><p>9102年已经过去快一半了，一直能坐下来好好的对2018做一个总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我的2018&quot;&gt;&lt;a href=&quot;#我的2018&quot; class=&quot;headerlink&quot; title=&quot;我的2018&quot;&gt;&lt;/a&gt;我的2018&lt;/h1&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.ccyh.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://www.ccyh.xyz/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【工具】HexoEditor编辑器的安装配置及使用</title>
    <link href="https://www.ccyh.xyz/2018/12/27/HexoEditor/"/>
    <id>https://www.ccyh.xyz/2018/12/27/HexoEditor/</id>
    <published>2018-12-27T21:09:02.000Z</published>
    <updated>2019-05-30T07:37:05.817Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。<br>GitHub：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HexoEditor</a></p></blockquote><a id="more"></a><hr><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h3><p> <strong>安装 HexoEditor:</strong></p><ul><li>下载链接：<a href="https://github.com/zhuzhuyule/HexoEditor/releases" target="_blank" rel="noopener">Download</a></li><li>支持 Linux 、Windows 、MacOS</li></ul><hr><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h3><p> <strong>简单设置：</strong><br><img src="https://i.loli.net/2019/01/27/5c4db8d20de92.png" alt=""></p><ul><li style="list-style: none"><input type="checkbox"> Hexo配置文件选择网站根目录下的_config.yml文件</li><li style="list-style: none"><input type="checkbox"> Tag模板目录选择网站很目录下的 /scaffolds 文件夹</li></ul><hr><p><img src="https://i.loli.net/2019/01/27/5c4db8d214477.png" alt=""></p><ul><li style="list-style: none"><input type="checkbox"> 主题随意选择</li></ul><hr><p>  <img src="https://i.loli.net/2019/01/27/5c4db8d206a24.png" alt=""></p><ul><li style="list-style: none"><input type="checkbox"> 默认资源库可在网站根目录source文件夹内新建文件夹来存放文章图片资源</li><li style="list-style: none"><input type="checkbox"> 云图类型可默认，SM.MS云图为免费云端，也可自选其他云端服务</li></ul><hr><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h3><p><strong>撰写文章：</strong></p><ul><li><p>点击新建Post可生成新的模板文档，开始写作。<br><img src="https://i.loli.net/2019/01/27/5c4db8d201aba.png" alt=""></p></li><li><p>在预览试图中右键点击所插入的图片，点击上传至SM.MS可将本地图片上传至云端，之后会发现文章中的图片Path变为URL链接。<br><img src="https://i.loli.net/2019/01/27/5c4dbb2b8a0ce.png" alt=""><br><img src="https://i.loli.net/2019/01/27/5c4dbb2b8e9d0.png" alt=""></p></li></ul><hr><h3 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a>Step4:</h3><p><strong>发布文章：</strong></p><ul><li>右键  –&gt; Hexo –&gt; 部署网站</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;HexoEditor 是一款多平台Markdown开源写作神器，在搭建完Hexo博客之后苦于发布博文的过程过于繁琐，而HexoEditor完美地解决了这一大痛点。其让写作与发布实现无缝衔接。&lt;br&gt;GitHub：&lt;a href=&quot;https://github.com/zhuzhuyule/HexoEditor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HexoEditor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.ccyh.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Tools" scheme="https://www.ccyh.xyz/tags/Tools/"/>
    
  </entry>
  
</feed>
