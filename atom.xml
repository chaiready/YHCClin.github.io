<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code·Hub</title>
  
  <subtitle>FlyingFish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ccyh.xyz/"/>
  <updated>2020-01-23T07:50:10.307Z</updated>
  <id>https://www.ccyh.xyz/</id>
  
  <author>
    <name>lyh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分图最大匹配问题(匈牙利算法)</title>
    <link href="https://www.ccyh.xyz/2019/11/25/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98(%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95)/"/>
    <id>https://www.ccyh.xyz/2019/11/25/二分图最大匹配问题(匈牙利算法)/</id>
    <published>2019-11-25T20:33:10.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>&emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 <strong>奇环</strong> (边为奇数的环路)， 如果一个图没有 <strong>奇环</strong> ,那么它就一定是 二分图。</p><a id="more"></a><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/bm.PNG#pic_center" alt="二分图"><br></center><h2 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h2><p>&emsp;给定一个二分图 G , 在 G 的一个子图 M 中， M 的边集 { E } 中的任意两条边都不依附于同一个顶点， 则称 M 是一个匹配。 翻译成人话就是 在图 G 中找到一些边构成一个集合， 这个集合中的任意一条边所连接的两个顶点都只属于这条边的连个端点，即每条边的顶点都不与其他边共用。如下图： 边集合 E = {(1,5),(3,6),(4,7)} 构成了一个匹配。</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/match.PNG#pic_center" alt="匹配"><br></center><h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p> &emsp;顾名思义，就是最大化满足上述规定的边集 E 。如上图的一个最大匹配结果为：</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/maxmatch.PNG#pic_center" alt="最大匹配"><br></center><hr><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>&emsp;此算法由美国数学家 <strong>哈罗德·库恩</strong> 于1955年提出该算法。先介绍两个概念：<br>&emsp;<strong>交替路</strong>： 从一个未匹配顶点出发，依次经过非匹配边、匹配边、非匹配边 … 形成的路径叫作 交替路。<br>&emsp;<strong>增广路</strong>： 从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路就称为增广路(agumenting path)，且增广路中非匹配边的数目要大于匹配边的数目。 如下图：图中已匹配点带蓝色标记，红色箭头边为一条匹配边，黑色箭头边为非匹配边。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/m.PNG#pic_center" alt=""><br></center><p>&emsp;展开来就是这样的一条 <strong>增广路</strong>：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/road.PNG#pic_center" alt=""><br></center><p>&emsp;如果此时将上述增广路的 匹配边与非匹配边<strong>对调</strong> ：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/nroad.PNG#pic_center" alt=""><br></center><p>&emsp;不难发现，匹配边多了一条（两条变三条），并且新增了两个匹配顶点。如此一来，边集 E 内不就多了一条边吗，符合我们的目标（最大化边集 E）。因此，匈牙利算法的 <strong>核心</strong> 就是 <strong>不断地寻找增广路径</strong> ，以便可以不断扩大边集 E，得到一个更大的匹配。</p><p><strong>总结增广路的定义：</strong></p><ul><li>其路径长度必定为奇数，且第一条边与最后一条边必定都不属于 M（最大匹配子图）。</li><li>该路径经过取反操作（匹配变不匹配，不匹配变匹配）后可以得到一个更大的匹配 M’。</li><li>M 为 G 的最大匹配当且仅当不存在相对于 M 的增广路径。</li></ul><hr><h3 id="算法概述："><a href="#算法概述：" class="headerlink" title="算法概述："></a>算法概述：</h3><ol><li>从 X 集合中选一个未匹配点 u 作为起点。选一条非匹配边(u,v), 到 Y中的点 v。</li><li>如果 v 是为匹配点， 说明找到了一条增广路。</li><li>否则若 v 是匹配点，下一步走匹配边，v 恰好和一条匹配边邻接。 设另一端为 left[v], 可以理解为 u 直接走到了 left[v], 也是 X 中的点。<ul><li>如果始终没有找到未匹配点（找不到最后一条非匹配边）,最后会扩展出一棵匈牙利树（root 是未匹配点， 叶子节点都是匹配点），从 root 到 leaf 的路径都不是增广路。</li></ul></li><li>每次选择一个未匹配点 u 进行 DFS。 如果找不到以 u 开头的增广路，就换一个未匹配点来进行 DFS， 且以后再也不从 u 出发找增广路了。<ul><li>如果以后存在一个从 u 出发的增广路，那么现在肯定找得到。</li></ul></li></ol><hr><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 0x00ff</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPM</span> &#123;</span>  <span class="hljs-comment">// 二分图的最大奇数匹配</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, e; <span class="hljs-comment">// 左右顶点个数, 边数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; G;      <span class="hljs-comment">// G[x][y] == 1,表示存在边 x - y</span></span><br><span class="line"><span class="hljs-keyword">int</span> *left;    <span class="hljs-comment">// left[i] 为右边（Y 集合）第i个顶点的匹配顶点编号</span></span><br><span class="line"><span class="hljs-keyword">bool</span> *T;  <span class="hljs-comment">// T[i] = true 表示第i个顶点已经被标记已访问</span></span><br><span class="line"></span><br><span class="line">BPM() </span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; e;</span><br><span class="line">T = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[maxn];</span><br><span class="line">left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxn];</span><br><span class="line">G = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(maxn,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(maxn,<span class="hljs-literal">false</span>));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> t1, t2;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">G[t1][t2] = <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-built_in">memset</span>(left, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> <span class="hljs-comment">// 匈牙利算法</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; m ; v++) <span class="hljs-comment">// 遍历右边 Y 集合中的顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(G[u][v] &amp;&amp; !T[v])</span><br><span class="line">&#123;</span><br><span class="line">T[v] = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(left[v] == <span class="hljs-number">-1</span> || match(left[v]))<span class="hljs-comment">// left[v] != -1, left[v] 是 v 的匹配边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 若 v 未匹配就将它与 u 匹配(相当于找到了一条增广路 u -&gt; v)，否则通过 v 的匹配点继续找未匹配点</span></span><br><span class="line">left[v] = u;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> <span class="hljs-comment">// 求最大匹配</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 匹配数</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; u++) <span class="hljs-comment">// 遍历左边顶点寻找增广路</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-keyword">if</span>(match(u))</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"--"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">ans++; <span class="hljs-comment">// 找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二分图&quot;&gt;&lt;a href=&quot;#二分图&quot; class=&quot;headerlink&quot; title=&quot;二分图&quot;&gt;&lt;/a&gt;二分图&lt;/h2&gt;&lt;p&gt;&amp;emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 &lt;strong&gt;奇环&lt;/strong&gt; (边为奇数的环路)， 如果一个图没有 &lt;strong&gt;奇环&lt;/strong&gt; ,那么它就一定是 二分图。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Graph" scheme="https://www.ccyh.xyz/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Tarjan算法求图的强连通分量</title>
    <link href="https://www.ccyh.xyz/2019/11/21/Tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>https://www.ccyh.xyz/2019/11/21/Tarjan算法求图的强连通分量/</id>
    <published>2019-11-21T21:58:23.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强连通分量简介"><a href="#强连通分量简介" class="headerlink" title="强连通分量简介"></a>强连通分量简介</h2><p>&emsp;&emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p><a id="more"></a><p>&emsp;&emsp;比如下图：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/%E8%BF%9E%E9%80%9A%E5%9B%BE.PNG#pic_center" alt=""><br></center><hr><h2 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h2><p>&emsp;Tarjan算法是用来求强连通分量的，它是一种基于DFS（深度优先搜索）的算法，每个强连通分量为搜索树中的一棵子树。并且运用了数据结构栈。由于栈的先进先出的性质可以保证当前在栈中的结点中先入栈的结点必然有一条通路通往后入栈的结点，这样一来判断后入栈的结点是否有一条路径通向先入栈结点就成了算法要解决的主要问题。<br><strong>算法思路：</strong><br>&emsp;首先引入两个数组 dfn[maxn] 和 low[maxn], 其中 dfn[i] 表示编号为 i 的节点被访问时的时间戳；low[i] 表示从编号为 i 的节点可追溯到（到达）的最早被访问到的节点的时间戳。下面通过上述例子跑一遍算法，描绘出每个时刻的DFS树状态和栈中的内容。</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/1.PNG#pic_center" alt="第一步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/2.PNG#pic_center" alt="第二步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/3.PNG#pic_center" alt="第三步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/4.PNG#pic_center" alt="第四步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/5.PNG#pic_center" alt="第五步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/6.PNG#pic_center" alt="第六步"><br><br></center><p>&emsp;由上述过程可得该图由三个连通分量：{5}，{4}，{2,3,1,0}</p><hr><h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><blockquote><p>代码中有详细注释，可结合上述图例分析</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*  求强连通分量： Tarjan算法</span></span><br><span class="line"><span class="hljs-comment">    Tarjan 算法， 以Robert Tarjan的名字命名的算法</span></span><br><span class="line"><span class="hljs-comment">    该算法用来在线性时间内求解图的连通性问题</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ssc</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;</span><br><span class="line">    Ssc(<span class="hljs-keyword">int</span> n_, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;g) : n(n_) &#123;         <span class="hljs-comment">// InitializeMG</span></span><br><span class="line">        graph = g;</span><br><span class="line">        dfn = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        low = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        scc = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n,<span class="hljs-literal">false</span>);</span><br><span class="line">        time = <span class="hljs-number">0</span>;</span><br><span class="line">        sscnum = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;   Sscs;     <span class="hljs-comment">// 所有连通分量</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;  graph;     <span class="hljs-comment">// 有向图的邻接矩阵</span></span><br><span class="line">    <span class="hljs-keyword">int</span>                      n;     <span class="hljs-comment">// 顶点总数</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  dfn;               <span class="hljs-comment">// 时间戳数组</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  low;               <span class="hljs-comment">// 最小时间戳数组（能够追溯到的最早栈中节点时间戳）</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; scc;               <span class="hljs-comment">// 在栈内标记数组</span></span><br><span class="line">    <span class="hljs-keyword">int</span>         time,               <span class="hljs-comment">// 时间</span></span><br><span class="line">              sscnum;               <span class="hljs-comment">// 连通分量数</span></span><br><span class="line">    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;           stk;       <span class="hljs-comment">// 遍历栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Ssc::Tarjan(<span class="hljs-keyword">int</span> root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>( dfn[root] ) <span class="hljs-keyword">return</span>;                     <span class="hljs-comment">// 访问过了，直接返回</span></span><br><span class="line">    dfn[root] = low[root] = ++time;</span><br><span class="line">    stk.push(root);                             <span class="hljs-comment">// 入栈</span></span><br><span class="line">    scc[root] = <span class="hljs-literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;v &lt; n;v++)                    <span class="hljs-comment">// 遍历 root 所指节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!dfn[v] &amp;&amp; graph[root][v])           <span class="hljs-comment">// v 还未被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[root] = min(low[root], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scc[v] &amp;&amp; graph[root][v])       <span class="hljs-comment">// 如果 v 还在栈内</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[root] = min(low[root], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(low[root] == dfn[root])                  <span class="hljs-comment">// 后代不能找到更浅的节点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        sscnum ++;                              <span class="hljs-comment">// 记数</span></span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sc;                         <span class="hljs-comment">// 保存当前连通分量</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)                             <span class="hljs-comment">// 依次退栈至 root</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> x = stk.top();</span><br><span class="line">            scc[x] = <span class="hljs-literal">false</span>;</span><br><span class="line">            stk.pop();</span><br><span class="line">            sc.push_back(x);</span><br><span class="line">            <span class="hljs-keyword">if</span>(x == root) <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Sscs.push_back(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-function">Ssc <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-number">6</span>, graph)</span></span>;</span><br><span class="line">    S.Tarjan(<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : S.Sscs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SSC ("</span> &lt;&lt; index++ &lt;&lt; <span class="hljs-string">") : "</span>; </span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The Number of SSC : "</span> &lt;&lt; S.sscnum &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/Tarjan.PNG#pic_center" alt="Result"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强连通分量简介&quot;&gt;&lt;a href=&quot;#强连通分量简介&quot; class=&quot;headerlink&quot; title=&quot;强连通分量简介&quot;&gt;&lt;/a&gt;强连通分量简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&amp;gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其改进</title>
    <link href="https://www.ccyh.xyz/2019/11/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/"/>
    <id>https://www.ccyh.xyz/2019/11/19/快速排序及其改进/</id>
    <published>2019-11-19T22:37:51.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><a id="more"></a><h2 id="简单快速排序算法"><a href="#简单快速排序算法" class="headerlink" title="简单快速排序算法"></a>简单快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">Partition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = p, j = r+<span class="hljs-number">1</span>;</span><br><span class="line">Type x = a[p]; <span class="hljs-comment">// 确定主元</span></span><br><span class="line"><span class="hljs-comment">// 划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r); <span class="hljs-comment">// 从左往右寻找比 x 大的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>(a[--j] &gt; x);<span class="hljs-comment">// 从右往左寻找比 x 小的元素</span></span><br><span class="line"><span class="hljs-keyword">if</span>(i &gt;= j)</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[p] = a[j];<span class="hljs-comment">// j 最终停留在一个比 x 小的数上面</span></span><br><span class="line">a[j] = x;<span class="hljs-comment">// 将主元放到最终位置</span></span><br><span class="line"><span class="hljs-keyword">return</span> j;<span class="hljs-comment">// 返回枢轴元素下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)<span class="hljs-comment">// 递归出口，只有一个元素时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = Partition(a, p, r); <span class="hljs-comment">// 得到划分位置</span></span><br><span class="line">QuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">QuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//-----------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><hr><p> 快速排序在平均情况下时间复杂度为 O(nlog n)<br> 最坏情况下(如待排序列有序)为 O(n^2)<br> 要使得在最坏情况下时间复杂度为 O(nlog n)<br> 容易看到，快速排序的性能取决于划分的 对称性<br> 可以每次都将问题划分为相等规模的两个子问题<br> 即 T(n) = 2T(n/2) + n<br> 由主定理解得 T(n) = O(nlog n)<br> 因此可以用一个算法选取当前序列的中位数将其作为主元(pivot)，将子问题划分为原问题的一半规模</p><h2 id="随机选择快速排序算法"><a href="#随机选择快速排序算法" class="headerlink" title="随机选择快速排序算法"></a>随机选择快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 随机选择快速排序算法在当数组还没有被划分时随机第从 a[p:r] 中选择主元作为划分基准</span></span><br><span class="line"><span class="hljs-comment">// 从而可以期望划分是较对称的</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (rand() % (r-p+<span class="hljs-number">1</span>))+ p;<span class="hljs-comment">// 生成 [p,r] 区间内的随机整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">RandomizedPartition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = Random(p, r);<span class="hljs-comment">// 产生一个属于 [p:r] 区间的随机数</span></span><br><span class="line">swap(a[i], a[p]);</span><br><span class="line"><span class="hljs-keyword">return</span> Partition(a, p, r);<span class="hljs-comment">// 调用划分函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">RandomizedQuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line">RandomizedQuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">RandomizedQuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机线性时间选择算法"><a href="#随机线性时间选择算法" class="headerlink" title="随机线性时间选择算法"></a>随机线性时间选择算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 由于RandomizedSelect中使用了RandomizedPartition产生的划分基准是随机的</span></span><br><span class="line"><span class="hljs-comment">// 在这个条件下可以证明，算法RandomizedSelect可以在 O(n) 的平均时间内找出n个输入的第 k 小元素</span></span><br><span class="line"><span class="hljs-comment">// 但其在最坏情况下的时间复杂度为 O(n^2),比如在找最小元素时(k=1),总是在最大元素处划分</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"> <span class="hljs-title">Type</span> <span class="hljs-title">RandomizedSelect</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)   // 返回第 <span class="hljs-title">k</span> 小的数</span></span><br><span class="line"><span class="hljs-class"> &#123;</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(p == r)</span><br><span class="line"> <span class="hljs-keyword">return</span> a[p];</span><br><span class="line"> <span class="hljs-keyword">int</span> i = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line"> <span class="hljs-keyword">int</span> j = i - p + <span class="hljs-number">1</span>;<span class="hljs-comment">// 计算前半部分子序列长度</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(k &lt;= j)<span class="hljs-comment">// 如果 j &gt;= k ,说明第 k 小的元素在前半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, p, i, k);</span><br><span class="line"> <span class="hljs-keyword">else</span><span class="hljs-comment">// 否则, 第 k 小的元素在右半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, i+<span class="hljs-number">1</span>, r, k-j);<span class="hljs-comment">// 从右半部分中寻找第 k - j 小的元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h2><p>下面讨论一个最坏情况下可以在 O(n) 时间内找到第 k 小的元素的线性时间选择算法<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// </span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> *1. 将 n 个元素划分成 n/5 个分组， 每组 5 个元素， 除可能有一个组不是 5 个元素外。用任意一种排序算法，</span></span><br><span class="line"><span class="hljs-comment"> *   将每组中的元素排好序，并去除每组的中位数，共 n/5 个。</span></span><br><span class="line"><span class="hljs-comment"> *2. 递归调用 Select 函数找出这 n/5 个元素的中位数。 如果 n/5 为偶数，就找他的两个中位数中较大的一个</span></span><br><span class="line"><span class="hljs-comment"> *   然后以这个元素作为划分基准。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],  <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span><span class="hljs-comment">// 插入排序</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p+<span class="hljs-number">1</span>; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j]; j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j], a[j + <span class="hljs-number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">Type</span> <span class="hljs-title">Select</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(r - p &lt; <span class="hljs-number">75</span>)</span><br><span class="line">&#123;</span><br><span class="line">insertSort(a,p,r);<span class="hljs-comment">// 简单插入排序</span></span><br><span class="line"><span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<span class="hljs-comment">// 返回中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 将 a[p + 5 * i] 至 a[p + 5 * i + 4] 的第三小元素与 a[p + i] 交换位置</span></span><br><span class="line">Type x = Select(a, p, p + (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<span class="hljs-comment">// 找出中位数中的中位数，r-p-4 即为 n-5</span></span><br><span class="line"><span class="hljs-keyword">int</span> m = Partition(a, p, r, x) , j = i - p + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(k &lt;= j)</span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, p, m, k);</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, m+<span class="hljs-number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三路划分快速排序"><a href="#三路划分快速排序" class="headerlink" title="三路划分快速排序"></a>三路划分快速排序</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort3Way</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">left</span>, <span class="hljs-title">int</span> <span class="hljs-title">right</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">Type x = a[right];<span class="hljs-comment">// 取尾元素为主元(基准)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// i 指向序列头元素的前一个元素(不存在)</span></span><br><span class="line"><span class="hljs-comment">// j 指向序列尾元素</span></span><br><span class="line"><span class="hljs-comment">// p 与 i 相同</span></span><br><span class="line"><span class="hljs-comment">// q 与 j 相同</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>, j = right, p = left - <span class="hljs-number">1</span>, q = right;</span><br><span class="line"><span class="hljs-comment">// 开始划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>( a[++i] &lt; x );<span class="hljs-comment">// 从左往右找大于x的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>( a[--j] &gt; x ) <span class="hljs-keyword">if</span>( j == left ) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 从右往左找小于x的元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-comment">// i j 未交错</span></span><br><span class="line">&#123;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[i] == x) &#123; p++; swap( a[p], a[i] ); &#125;<span class="hljs-comment">// 将与主元相等的元素交换到两侧</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[j] == x) &#123; q--; swap( a[q], a[j] ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">// i j 交错， i 为主元最终位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(a[i], a[right]);<span class="hljs-comment">// 将主元交换到最终位置</span></span><br><span class="line">j = i - <span class="hljs-number">1</span>;</span><br><span class="line">i = i + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">// 此时 p，q 指向两侧与主元相等元素的最内侧元素</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">如下图：x 为主元</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">x x x x x x x a d d t g e w x d i s e s x x x x</span></span><br><span class="line"><span class="hljs-comment">            |             |   |         |</span></span><br><span class="line"><span class="hljs-comment">            p             j   i         q</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = left;  k &lt;= p; k++, j--) swap( a[k], a[j] );<span class="hljs-comment">// 将左侧相等元素交换到主元左边</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = right - <span class="hljs-number">1</span>; k &gt;= q; k--, i++) swap( a[i], a[k] );<span class="hljs-comment">// 将右侧相等元素交换到主元右边</span></span><br><span class="line"><span class="hljs-comment">// 一次划分结束</span></span><br><span class="line"></span><br><span class="line">QuickSort3Way(a, left,  j);</span><br><span class="line">QuickSort3Way(a, i, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">28</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">65</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">63</span>,<span class="hljs-number">78</span>,<span class="hljs-number">23</span>,<span class="hljs-number">61</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>&#125;;</span><br><span class="line"><span class="hljs-comment">//RandomizedQuickSort(a,0,19);</span></span><br><span class="line"><span class="hljs-keyword">time_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">QuickSort3Way(a, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>);</span><br><span class="line">end   = clock();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">1.0</span> * (end - start)/CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">" s "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">20</span>;i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="QuickSort" scheme="https://www.ccyh.xyz/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>侯捷C++学习笔记[未整理版]</title>
    <link href="https://www.ccyh.xyz/2019/11/13/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5B%E6%9C%AA%E6%95%B4%E7%90%86%E7%89%88%5D/"/>
    <id>https://www.ccyh.xyz/2019/11/13/侯捷C++学习笔记[未整理版]/</id>
    <published>2019-11-13T22:13:59.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还没有整理过的笔记，有点乱</p></blockquote><a id="more"></a><h1 id="C-程序设计II-兼谈对象模型"><a href="#C-程序设计II-兼谈对象模型" class="headerlink" title="C++ 程序设计II 兼谈对象模型"></a>C++ 程序设计II 兼谈对象模型</h1><hr><h2 id="Conversion-function-转换函数-operator-type"><a href="#Conversion-function-转换函数-operator-type" class="headerlink" title="Conversion function - 转换函数 operator type()"></a>Conversion function - 转换函数 operator type()</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// this type -&gt; other type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类，分数可以被看成double</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数，不唯一，合理就行</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    <span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 operator double() 将 f 转换成 double</span></span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 4.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// non-explicit-one-argument constructor</span></span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/* 当下面operator type() 函数同时存在时，会迷惑编译器，出错 ambiguous</span></span><br><span class="line"><span class="hljs-comment">    // 因为有两条路可行：</span></span><br><span class="line"><span class="hljs-comment">        1. 将 4 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        2. 将 f 转double 在将 4.6 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        从而产生歧义</span></span><br><span class="line"><span class="hljs-comment">    operator double() const // 最好加const </span></span><br><span class="line"><span class="hljs-comment">    &#123;</span></span><br><span class="line"><span class="hljs-comment">        return ((double)m_numerator / m_denominator);</span></span><br><span class="line"><span class="hljs-comment">    &#125; // 转换函数</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 non-explicit ctor 将 4 转换成 Fraction,然后调用operator+()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// explicit-one-argument constructor</span></span><br><span class="line">    explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) &#123;&#125; // 90% 的 explicit 用在构造函数上</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数</span></span><br><span class="line">    */</span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// [Error] conversion from double to Fraction requested, 4 不能自动转为Fraction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span>&lt;bool, Alloc&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-keyword">typedef</span> __bit_reference reference;</span><br><span class="line">    <span class="hljs-keyword">protected</span>:</span><br><span class="line">        reference <span class="hljs-keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> *(begin() + defference_type(n));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>* p;</span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask;</span><br><span class="line">    ...</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !(!(*p &amp; mask)); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于智能指针"><a href="#pointer-like-classes-关于智能指针" class="headerlink" title="pointer-like classes, 关于智能指针"></a>pointer-like classes, 关于智能指针</h2><hr><blockquote><blockquote><p>一个 class 产生出来的对象像一个指针(do more then pointer, such as auto pointer)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-comment">// 固定写法</span></span><br><span class="line">        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *px;&#125;</span><br><span class="line">        T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> px;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">shared_ptr</span>(T* p) : px(px) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        T*    px; <span class="hljs-comment">// 指向 T 的指针</span></span><br><span class="line">        <span class="hljs-keyword">long</span>* pn;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; sp(<span class="hljs-keyword">new</span> Foo); <span class="hljs-comment">// 初始化sp为指向Foo的智能指针,即sp内部的px指向Foo</span></span><br><span class="line">    <span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(*sp)</span></span>; <span class="hljs-comment">// *p 调用 operator*()</span></span><br><span class="line">    sp -&gt; method(); <span class="hljs-comment">// 调用 method 函数 等价于 调用operator-&gt;() 再调用 px -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于迭代器-一种特别的智能指针"><a href="#pointer-like-classes-关于迭代器-一种特别的智能指针" class="headerlink" title="pointer-like classes, 关于迭代器(一种特别的智能指针)"></a>pointer-like classes, 关于迭代器(一种特别的智能指针)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// list 链表节点设计</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> __<span class="hljs-title">list_node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">void</span>* prev;</span><br><span class="line">    <span class="hljs-keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;lass T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ref</span>, <span class="hljs-title">class</span> <span class="hljs-title">Ptr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> __<span class="hljs-title">list_iterator</span> &#123;</span> <span class="hljs-comment">// 链表的迭代器实现</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_node&lt;T&gt;* link_type; <span class="hljs-comment">// 指向链表节点的指针类型</span></span><br><span class="line">    link_type node; <span class="hljs-comment">// node 为指向链表节点的指针</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node != x.node;&#125;</span><br><span class="line">    <span class="hljs-comment">// 本节重点</span></span><br><span class="line">    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; ++*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; --*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">list</span>&lt;Foo&gt;::iterator it;</span><br><span class="line">    *it; <span class="hljs-comment">// 获得一个Foo对象</span></span><br><span class="line">    it -&gt; method();</span><br><span class="line">    <span class="hljs-comment">// 调用Foo::method()</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (*it).method();</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (&amp;(*it)) -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-like-classes-所谓-仿函数-像函数的类"><a href="#function-like-classes-所谓-仿函数-像函数的类" class="headerlink" title="function-like classes, 所谓 仿函数 (像函数的类)"></a>function-like classes, 所谓 仿函数 (像函数的类)</h2><blockquote><blockquote><p>() 函数调用操作符 function call<br>一般只要看到class内重载了()操作符，那他的用意就是想要变成一个function,其构造的对象称为函数对象<br>标准库中，仿函数会继承一些奇特的基类如：unary_function , binary_function</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 大小为零</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>, <span class="hljs-title">class</span> <span class="hljs-title">Result</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">identity</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> T&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> T&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-comment">// 重载了函数调用操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt; // 源代码暗示你给他一个 <span class="hljs-title">pair</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select1st</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::first_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select2nd</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::second_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::second_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; p(<span class="hljs-string">'a'</span>,<span class="hljs-number">97</span>);</span><br><span class="line">    <span class="hljs-keyword">char</span> ch = select1st(p);</span><br><span class="line">    <span class="hljs-keyword">int</span> in  = select2nd(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="namespase-经验谈"><a href="#namespase-经验谈" class="headerlink" title="namespase 经验谈"></a>namespase 经验谈</h2><hr><blockquote><blockquote><p>避免命名冲突</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> jj01 &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_member_template</span><span class="hljs-params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span></span><br><span class="line">namespase jj02 &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line">    <span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_template_param</span><span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ----------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 可以将所有测试函数放在一个main里面执行</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    jj01::test_member_template();</span><br><span class="line">    jj02::test_template_param();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-template-模板类-泛型编程"><a href="#class-template-模板类-泛型编程" class="headerlink" title="class template, 模板类(泛型编程)"></a>class template, 模板类(泛型编程)</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line">    T a;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function">T <span class="hljs-title">getA</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="function-template-函数模板"><a href="#function-template-函数模板" class="headerlink" title="function template, 函数模板"></a>function template, 函数模板</h2><blockquote><blockquote><p>编译器会对 function template 进行 实参推导 (augument deduction)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stone</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    stone (<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> we)</span><br><span class="line">    : _w(w), _h(h), _weight(we) &#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> stone&amp; ths) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> _weight &lt; rhs._weight;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">min</span>(<span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">a</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">b</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">return</span> b &lt; a ? b : a; <span class="hljs-comment">// 实参推导的结果，T 为stone，于是调用 stone::operator&lt;()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="member-template-成员模板-令构造函数更有弹性"><a href="#member-template-成员模板-令构造函数更有弹性" class="headerlink" title="member template, 成员模板(令构造函数更有弹性)"></a>member template, 成员模板(令构造函数更有弹性)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 成员模板(是成员又是模板)</span></span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>, <span class="hljs-title">class</span> <span class="hljs-title">U2</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">pair</span>(<span class="hljs-title">const</span> <span class="hljs-title">pair</span>&lt;U1, U2&gt;&amp; <span class="hljs-title">p</span>) // 构造函数 <span class="hljs-title">U1</span>,<span class="hljs-title">U2</span> 必须(可转型为)继承于 <span class="hljs-title">T1</span>,<span class="hljs-title">T2</span></span></span><br><span class="line"><span class="hljs-class">    :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived1</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p); <span class="hljs-comment">// 可以</span></span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; b;</span><br><span class="line">pair&lt;Derived1, Derived2&gt; b2(b); <span class="hljs-comment">// 不可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_ptr</span> :</span> <span class="hljs-keyword">public</span> __shared_ptr&lt;_Tp&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1* ptr = <span class="hljs-keyword">new</span> Derived1; <span class="hljs-comment">// up-cast 向上造型</span></span><br><span class="line"><span class="hljs-built_in">shared_ptr</span>&lt;Base1&gt; sptr(<span class="hljs-keyword">new</span>  Derived1); <span class="hljs-comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure><h2 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization, 模板特化"></a>specialization, 模板特化</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>&gt; // 绑定</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">hash</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; hash&lt;<span class="hljs-keyword">int</span>&gt; () (<span class="hljs-number">1000</span>); <span class="hljs-comment">// 临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partial-specialization-模板偏特化-–-个数上的偏"><a href="#partial-specialization-模板偏特化-–-个数上的偏" class="headerlink" title="partial specialization, 模板偏特化 – 个数上的偏"></a>partial specialization, 模板偏特化 – 个数上的偏</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = ...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>, Alloc&gt; <span class="hljs-comment">// 绑定第一个模板参数，必须从左到右依次指定，不可跳跃</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// --------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 范围上的偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure><h2 id="template-template-parameter-模板模板参数"><a href="#template-template-parameter-模板模板参数" class="headerlink" title="template template parameter, 模板模板参数"></a>template template parameter, 模板模板参数</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">// Container为模板模板参数</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> &gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">list</span>&gt; my1st1; <span class="hljs-comment">// Error list本身是模板，未定义</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, Lst&gt; my1st2; <span class="hljs-comment">// 可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmatPtr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    SmatPtr&lt;T&gt; sp;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    XCls() : sp(<span class="hljs-keyword">new</span> T) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">shared_ptr</span>&gt; p1; <span class="hljs-comment">// ok</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unique_ptr</span>&gt; p2; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, weak_ptr&gt; p3; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">auto_ptr</span>&gt; p4; <span class="hljs-comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="这个不是-template-template-parameter"><a href="#这个不是-template-template-parameter" class="headerlink" title="这个不是 template template parameter"></a>这个不是 template template parameter</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> = <span class="hljs-title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">stack</span> &#123;</span></span><br><span class="line">    pass</span><br><span class="line"><span class="hljs-keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1;</span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; s2; <span class="hljs-comment">// 已经指定list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于-C-标准库"><a href="#关于-C-标准库" class="headerlink" title="关于 C++ 标准库"></a>关于 C++ 标准库</h2><hr><blockquote><blockquote><p>Iterator   迭代器<br>Container  容器<br>Algorithm  算法<br>Functors   仿函数</p></blockquote></blockquote><p>查看标准库，并实验每一个已经实现的标准库功能。</p><hr><h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h1><hr><h2 id="variadic-templates-数量不定的模板参数-since-C-11"><a href="#variadic-templates-数量不定的模板参数-since-C-11" class="headerlink" title="variadic templates  数量不定的模板参数 (since C++11)"></a>variadic templates  数量不定的模板参数 (since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// ... 也是语法的一部分</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg, <span class="hljs-keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// &lt;&lt; 须重载</span></span><br><span class="line">    print(args...); <span class="hljs-comment">// 递归调用，每次分为firstArg和后面 Types... (其他的多个)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 调用</span></span><br><span class="line">print(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">337</span>), <span class="hljs-number">42</span>);</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">7.5</span></span><br><span class="line"><span class="hljs-comment">hello</span></span><br><span class="line"><span class="hljs-comment">0000000101111001</span></span><br><span class="line"><span class="hljs-comment">42</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 通过 sizeof(args...) 可以得到后面一包是几个</span></span><br></pre></td></tr></table></figure><h2 id="auto-语法糖-since-c-11"><a href="#auto-语法糖-since-c-11" class="headerlink" title="auto 语法糖(since c++11)"></a>auto 语法糖(since c++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; c;</span><br><span class="line"><span class="hljs-keyword">auto</span> ite = find(c.begin(), c.end(), target); </span><br><span class="line"><span class="hljs-comment">// 让编译器自动帮你推断类型，但前提是你得有assign语句，不然编译器不知道怎么推</span></span><br><span class="line"><span class="hljs-keyword">auto</span> it; <span class="hljs-comment">// 不能这样写，编译器不知道it是什么类型</span></span><br><span class="line">it = find(c.begin(), c.end(),target); <span class="hljs-comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="range-base-for-语法糖-since-C-11"><a href="#range-base-for-语法糖-since-C-11" class="headerlink" title="range-base for 语法糖(since C++11)"></a>range-base for 语法糖(since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : container) <span class="hljs-comment">// 逐个取出，copy到 i 上 (pass by value)</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : container) <span class="hljs-comment">// pass by reference 更改了container 中的值</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;) <span class="hljs-comment">// 新语法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference-引用-代表-实际上是指针实现的"><a href="#reference-引用-代表-实际上是指针实现的" class="headerlink" title="reference 引用(代表),实际上是指针实现的"></a>reference 引用(代表),实际上是指针实现的</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span>* p = &amp;x; <span class="hljs-comment">// p pointer to x</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r = x;  <span class="hljs-comment">// r reference to x , r 代表 x, r 从一而终，不能再代表其它对象了</span></span><br><span class="line"><span class="hljs-keyword">int</span> x2 = <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 编译器制造的假象</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">sizeof</span>(r) == <span class="hljs-keyword">sizeof</span>(x)) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true 但其实 r 是一个指针</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (&amp;r == &amp;x) &lt;&lt; <span class="hljs-built_in">endl</span>;               <span class="hljs-comment">// true 假象</span></span><br><span class="line"></span><br><span class="line">r = x2;      <span class="hljs-comment">// r 不能从新代表其它对象，只是把 r 代表的 x 的值变成 x2 的值罢了</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r2 = r; <span class="hljs-comment">// r2 reference to r (r2 代表 r, 亦相当于代表 x)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 不管是内置类型还是自定义类型都符合上述结论</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)的描述.</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T *pobj)</span> </span>&#123;pobj -&gt; xxx();&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T pobj)</span> </span>&#123;pobj.xxx();&#125; <span class="hljs-comment">// 须拷贝，传递较慢</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(T&amp; pobj)</span> </span>&#123;pobj.xxx();&#125;</span><br><span class="line"></span><br><span class="line">T obj;</span><br><span class="line">func1(&amp;obj);<span class="hljs-comment">// 调用接口不同，困扰</span></span><br><span class="line">func2(obj); <span class="hljs-comment">// 调用接口相同，很好</span></span><br><span class="line">func3(obj);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特别注意，写函数重载时，以下两种(same signature)不能并存</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> im)</span></span>; <span class="hljs-comment">// Ambiguous</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Q : const 是不是函数签名的一部分，即是否能作为重载的指标？<br>A : 是！</p></blockquote></blockquote><h1 id="Object-Model-对象模型"><a href="#Object-Model-对象模型" class="headerlink" title="Object Model 对象模型"></a>Object Model 对象模型</h1><hr><h2 id="Part-I-的承接"><a href="#Part-I-的承接" class="headerlink" title="Part I 的承接"></a>Part I 的承接</h2><blockquote><blockquote><p>Inheritance 继承：           构造由内而外，析构由外而内<br>Composition 复合：           构造由内而外，析构由外而内<br>Inheritance+Composition：    构造由内而外，析构由外而内</p><blockquote><p>Derived::Derived(…) : Base(),Component() {…}<br>Derived::~Derived() {… Component(); Base()} // 与构造相反</p></blockquote></blockquote></blockquote><h2 id="关于-vptr-和-vtbl-虚指针和虚表"><a href="#关于-vptr-和-vtbl-虚指针和虚表" class="headerlink" title="关于 vptr 和 vtbl (虚指针和虚表)"></a>关于 vptr 和 vtbl (虚指针和虚表)</h2><blockquote><blockquote><p>只要类中有虚函数，其对象在内存中就会多一根指针（指向虚表）<br>父类有虚函数，子类对象也一定拥有该指针</p></blockquote></blockquote><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">public</span> B &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内存模型：-动态绑定"><a href="#内存模型：-动态绑定" class="headerlink" title="内存模型： 动态绑定"></a>内存模型： 动态绑定</h3><hr><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg" alt="内存模型"></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">C *p = <span class="hljs-keyword">new</span> C;</span><br><span class="line">(*p).vfunc2();</span><br><span class="line"><span class="hljs-comment">// 相当于,其中 n 表示虚表中的第 n 个虚函数</span></span><br><span class="line">(*(p-&gt;vptr)[n])(p);</span><br><span class="line">(* p-&gt;vptr[n] )(p);</span><br></pre></td></tr></table></figure><hr><h3 id="应用：PPT-图形类-多态的应用"><a href="#应用：PPT-图形类-多态的应用" class="headerlink" title="应用：PPT 图形类(多态的应用)"></a>应用：PPT 图形类(多态的应用)</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr2.jpg" alt="PPT类"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>&emsp;C++ 编译器看到一个函数调用，会有两个考量（静态绑定，动态绑定)</p><ol><li>静态绑定是被编译成: CALL xxxx(func address)。</li><li>但如果符合某些条件就会动态绑定：<ul><li>通过指针调用</li><li>指针向上转型 up-cast</li><li>所调用的是虚函数(virtual func)<br>动态绑定的形式：虚机制<br>多态：指针具有很多的类型（型态）</li></ul></li></ol><hr><h2 id="关于-this-pointer"><a href="#关于-this-pointer" class="headerlink" title="关于 this pointer"></a>关于 this pointer</h2><blockquote><blockquote><p>设计分析继承体系时要对this pointer有一个清晰的认识<br>对象调用成员函数时，该对象的this指正就会隐含地传入函数中<br>下图中在对象调用OnFileOpen()时传入对象地址this，因此碰到虚函数Serialize()函数后，回去寻找CMyDoc类的虚函数表中的函数（动态绑定）</p></blockquote></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/templateMethod.jpg" alt=""></p><hr><h2 id="谈谈-const-const-member-function-常量成员函数"><a href="#谈谈-const-const-member-function-常量成员函数" class="headerlink" title="谈谈 const (const member function 常量成员函数)"></a>谈谈 const (const member function 常量成员函数)</h2><blockquote><p>const 是属于函数签名的一部分</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    Class() &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125; <span class="hljs-comment">// 保证不更改 mem</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>const object(datamember不可变动)</th><th>non-const object(datamem可变动)</th></tr></thead><tbody><tr><td>const member functions(保证datamenber不变)</td><td>YES</td><td>YES</td></tr><tr><td>non-const member functions(不保证datamember不变)</td><td>无法调用</td><td>YES </td></tr></tbody></table><blockquote><p>当成员函数的 const 和 non-const 版本同时存在时，const Object 只会调用 const 版本，non-const Object 只会调用 non-const 版本</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/db.jpg" alt=""></p><hr><h2 id="关于-new-delete-array-new-array-delete-重载"><a href="#关于-new-delete-array-new-array-delete-重载" class="headerlink" title="关于 new , delete. array new , array delete.(重载)"></a>关于 new , delete. array new , array delete.(重载)</h2><h3 id="Part-I-承接："><a href="#Part-I-承接：" class="headerlink" title="Part I 承接："></a>Part I 承接：</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/new.png" alt=""></p><hr><h3 id="全局重载形式"><a href="#全局重载形式" class="headerlink" title="全局重载形式"></a>全局重载形式</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/overideDelete.jpg" alt=""></p><h3 id="成员重载形式"><a href="#成员重载形式" class="headerlink" title="成员重载形式"></a>成员重载形式</h3><blockquote><p>new 分解为 3 个动作<br>delete 分解为 2 个动作<br>接管内存的分配和释放的行为</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride.jpg" alt=""></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride%5B%5D.jpg" alt=""></p><hr><h3 id="示例，-接口"><a href="#示例，-接口" class="headerlink" title="示例， 接口"></a>示例， 接口</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __FOO__</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FOO__</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> _id;</span><br><span class="line"><span class="hljs-keyword">long</span> _data;</span><br><span class="line"><span class="hljs-built_in">string</span> _str;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">Foo() : _id(<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"default ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line">Foo(<span class="hljs-keyword">int</span> id) : _id(id) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//virtual    // 可选的 virtual 关键字</span></span><br><span class="line">~Foo() &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dtor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size);</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead,<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// END DEFINE</span></span></span><br></pre></td></tr></table></figure><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"sizeof(Foo) = "</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo *p = <span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line"><span class="hljs-keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo* pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">delete</span>[] pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"********************************************"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局,不会进入重载函数</span></span><br><span class="line">Foo* _p = ::<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局</span></span><br><span class="line">Foo *_pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foo.png" alt="Foo with non-virtual dtor"></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foowithvirtual.png" alt="Foo with virtual dtor"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;还没有整理过的笔记，有点乱&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://www.ccyh.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="https://www.ccyh.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode23 合并 K 个排序链表(Hard)</title>
    <link href="https://www.ccyh.xyz/2019/09/10/LeetCode23%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8(Hard)/"/>
    <id>https://www.ccyh.xyz/2019/09/10/LeetCode23合并-K-个排序链表(Hard)/</id>
    <published>2019-09-10T13:43:26.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>&emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><a id="more"></a><p><strong>示例:</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,</span><br><span class="line">  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>&emsp;因为所给链表均有序且头节点指针均在一个数组中，可以将当前数组中的头节点指针所指向的链表节点的值与其所在下标绑定为一个 pair 并存入一个最小堆中（按节点val排序，由优先级队列实现），这样就可以每次从堆中（pop）取出最小值用尾插法插入结果链表中。并且每次pop后都更新lists数组，将新的头节点的 pair 推入最小堆中，如此循环往复直至堆为空。</p><h3 id="算法演示："><a href="#算法演示：" class="headerlink" title="算法演示："></a>算法演示：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/lists.PNG" alt="lists数组"><br></center><p>I. 初始化堆：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与其所指链表节点的val绑定为pair入堆</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="hljs-comment">//加负号取反，间接实现小顶堆</span></span><br><span class="line">                      Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/Initial.PNG" alt=""><br></center><p>II. 从堆中取出最小元素（堆顶）并更新lists数组与堆</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">//实现摘下链表头节点的操作(跟新lists)</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);<span class="hljs-comment">//释放内存</span></span><br><span class="line"> <span class="hljs-comment">//弹出顶点</span></span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-comment">//新头节点进入</span></span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br></pre></td></tr></table></figure><center><br>1. 更新lists数组<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/reLists.PNG" alt="更新lists"><br>2. 弹出堆顶<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/pop1.PNG" alt="弹出顶点"><br>3. 更新堆<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/push1.PNG" alt="更新堆"><br></center><p>III. 循环II（1、2、3）直到堆为空。</p><hr><h2 id="算法代码："><a href="#算法代码：" class="headerlink" title="算法代码："></a>算法代码：</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//定义优先级队列，对pair默认对第一个元素按从小到大排序（大顶堆）</span></span><br><span class="line"><span class="hljs-comment">//因此push进队列时可将对应链表节点的val值取相反数，输出时还原，间接实现了小顶堆</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义结果链表头节点</span></span><br><span class="line">ListNode *head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>),*p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//实现摘下链表头节点的操作</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> head -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//生成链表数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generatList</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-built_in">list</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>.size()!=lists.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* p = lists[i];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">list</span>[i].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) &#123; lists[i] = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]); p = lists[i];&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;ListNode*&gt; lists(<span class="hljs-number">3</span>);</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">list</span> = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;&#125;;</span><br><span class="line">generatList(lists,<span class="hljs-built_in">list</span>);</span><br><span class="line">ListNode* head = mergeKLists(lists);</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; p -&gt; val &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/result23.PNG" alt=""><br></center><hr><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><p>&emsp;假设 K 个链表每个链表的长度为 N ，堆的调整时间复杂度为 $ \log_{2}{K} $，故时间复杂度为$ KN \log_{2}{K} $.<br>&emsp;空间复杂度为$ O(1) $.</p><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;&amp;emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1178_Hard_猜字谜</title>
    <link href="https://www.ccyh.xyz/2019/09/06/LeetCode1178_Hard_%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
    <id>https://www.ccyh.xyz/2019/09/06/LeetCode1178_Hard_猜字谜/</id>
    <published>2019-09-06T12:30:03.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><a id="more"></a><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 word 中包含谜面 puzzle 的第一个字母。</li><li>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。<br><strong> 示例：</strong><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>], </span><br><span class="line">puzzles = [<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"aboveyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span> </span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"abrodyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span></span><br><span class="line"><span class="hljs-number">3</span> 个单词可以作为 <span class="hljs-string">"abslute"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"able"</span></span><br><span class="line"><span class="hljs-number">2</span> 个单词可以作为 <span class="hljs-string">"absoryz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span></span><br><span class="line"><span class="hljs-number">4</span> 个单词可以作为 <span class="hljs-string">"actresz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"actt"</span>, <span class="hljs-string">"access"</span></span><br><span class="line">没有单词可以作为 <span class="hljs-string">"gaswxyz"</span> 的谜底，因为列表中的单词都不含字母 <span class="hljs-string">'g'</span>。</span><br></pre></td></tr></table></figure></li></ul><p><strong> 提示： </strong></p><blockquote><ul><li>1 &lt;= words.length &lt;= 10^5</li><li>4 &lt;= words[i].length &lt;= 50</li><li>1 &lt;= puzzles.length &lt;= 10^4</li><li>puzzles[i].length == 7</li><li>words[i][j], puzzles[i][j] 都是小写英文字母。</li><li>每个 puzzles[i] 所包含的字符都不重复。</li></ul></blockquote><hr><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h3 id="法一：暴力枚举判断（超时）"><a href="#法一：暴力枚举判断（超时）" class="headerlink" title="法一：暴力枚举判断（超时）"></a>法一：暴力枚举判断（超时）</h3><p>这个算法很直观，无非就是遍历枚举每一个谜面，判断words中能作为它的谜底的word的个数。<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> charcounter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">charcounter[j-<span class="hljs-string">'a'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; chset;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : k)</span><br><span class="line">&#123;</span><br><span class="line">chset.insert(m);</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.size()&gt;<span class="hljs-number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.find(i[<span class="hljs-number">0</span>])==chset.end())</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">auto</span> iter = chset.begin();</span><br><span class="line"><span class="hljs-keyword">bool</span> flags = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(;iter != chset.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(charcounter[(*iter)-<span class="hljs-string">'a'</span>] &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flags = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flags) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="法二：暴力枚举-位运算（超时）"><a href="#法二：暴力枚举-位运算（超时）" class="headerlink" title="法二：暴力枚举+位运算（超时）"></a>法二：暴力枚举+位运算（超时）</h3><p>已知int行为32位，而小写字母有26个，因此用一个int型的整数就能够表示字符串中是否出现某字符：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178.PNG" alt=""><br></center><p>上图就可以表示字符串“anwvw”<br>因此思路就是沿用上面的暴力枚举方法，只不过将字符串查询比较转化为整数的比较。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords_BTL(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfpuzzles;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> puzzle = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">puzzle = puzzle | (<span class="hljs-number">1</span> &lt;&lt; (j-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfpuzzles.push_back(puzzle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfwords;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜底的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> word = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; m : k)</span><br><span class="line">&#123;</span><br><span class="line">word = word | (<span class="hljs-number">1</span> &lt;&lt; (m-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfwords.push_back(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : binOfpuzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; j : binOfwords)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(i == j) ans++;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((((<span class="hljs-number">1</span> &lt;&lt; (puzzles[n][<span class="hljs-number">0</span>]-<span class="hljs-string">'a'</span>)) &amp; j) != <span class="hljs-number">0</span>)) <span class="hljs-comment">//如果word中包含puzz的第一个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">26</span>;k++) <span class="hljs-comment">//判断是否符合第二条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>( ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;i) == <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;j) != <span class="hljs-number">0</span>) ) <span class="hljs-comment">//word中存在而puzz中不存在</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法虽然比第一个好点但是当面对更大规模的测试样例时还是会超时。</p><hr><h3 id="法三：位运算-哈希"><a href="#法三：位运算-哈希" class="headerlink" title="法三：位运算+哈希"></a>法三：位运算+哈希</h3><p>分析题设，根据第一个成为谜底的条件就是word中必须包含puzzle中的第一个字符，因此可以建立26个字符与包含该字符的word的整数表示所组成的数组的映射关系：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11782.PNG" alt=""><br></center><p>如此一来，我们就只需判断包含puzzle首字符的word是否是谜底就可以了，减少了很多无用重复的比较。<br>再者，不难发现若某一个word是puzzle的谜底那么其包含的字符种类肯定小于等于puzzle所包含的字符种类，这体现在整数化的字符串中就是：intOfWord的二进制值中 1 的位数肯定少于或等于intOfPuzzle中 1 的位数，并且intOfWord中 1 出现的位必将也是intOfPuzzle中 1 出现的位。因此对intOfWord和intOfPuzzle取余就会得到它们共同拥有的字符的字符串的整数表示，若该结果等与intOfWord就表明此时的word就是谜底。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11783.PNG" alt=""><br></center><p><strong> 最终算法如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfValidWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles) &#123;</span><br><span class="line"><span class="hljs-comment">//v用来保存含有'a'+i字母的word的二进制数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; hashV[<span class="hljs-number">26</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : words) &#123;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜底word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp = tmp^(<span class="hljs-number">1</span> &lt;&lt; ii);</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> j : s)</span><br><span class="line">hashV[j - <span class="hljs-string">'a'</span>].push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//结果数组ans</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : puzzles) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> at = i[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>;<span class="hljs-comment">//记录首字母</span></span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp ^= <span class="hljs-number">1</span> &lt;&lt; ii;</span><br><span class="line">ans.push_back(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : hashV[at]) <span class="hljs-comment">//hashV[at]中保存的是包含puzzle首字母的word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">if</span> ((j &amp; tmp) == j) <span class="hljs-comment">//j &amp; tmp 会得到它们共同拥有的字符的二进制数，</span></span><br><span class="line">ans.back()++;   <span class="hljs-comment">//若其值与(j)不相等则表示word中含有puzzle中不含的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="运行测试："><a href="#运行测试：" class="headerlink" title="运行测试："></a>运行测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = &#123;<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; puzzles = &#123;<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res(findNumOfValidWords(words,puzzles));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"  "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178res.PNG" alt=""><br></center><hr><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>图解LeetCode295_Hard_MedianFinder</title>
    <link href="https://www.ccyh.xyz/2019/08/29/LeetCode295_Hard/"/>
    <id>https://www.ccyh.xyz/2019/08/29/LeetCode295_Hard/</id>
    <published>2019-08-29T10:50:38.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC295-数据流中的中位数-类设计）"><a href="#LC295-数据流中的中位数-类设计）" class="headerlink" title="[LC295] 数据流中的中位数(类设计）"></a>[LC295] 数据流中的中位数(类设计）</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><a id="more"></a><p><strong>例如：</strong></p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br><strong>示例：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">addNum(<span class="hljs-number">1</span>)</span><br><span class="line">addNum(<span class="hljs-number">2</span>)</span><br><span class="line">findMedian() -&gt; <span class="hljs-number">1.5</span></span><br><span class="line">addNum(<span class="hljs-number">3</span>) </span><br><span class="line">findMedian() -&gt; <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-median-from-data-stream</a></p><hr><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>维护两个堆（一个大顶堆bigger，一个小顶堆smaller）来保存数据流中流过来的数字。无论何时都要保持abs(bigger.size-smaller.size)&lt;=1;并且保证大顶堆内的数字的值全都小于或等于小顶堆内的数字的值，这样就能保证大顶堆保存的是数据流中较小的一半数字，而小顶堆中保存的是另外较大的一半。</p><hr><h3 id="findMedian-函数设计"><a href="#findMedian-函数设计" class="headerlink" title="findMedian 函数设计"></a>findMedian 函数设计</h3><p>&emsp;&emsp;如此一来，不难发现数据流的中位数查找函数 findMedian() 的逻辑就为(伪代码)：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> smaller.size == bigger.size:</span><br><span class="line">    <span class="hljs-keyword">return</span> (smalle.top + bigger.top)/<span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> smaller.size &gt; bigger.size:</span><br><span class="line">    <span class="hljs-keyword">return</span> smaller.top;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">    <span class="hljs-keyword">return</span> bigger.top;</span><br></pre></td></tr></table></figure></p><hr><h3 id="addNum-函数设计"><a href="#addNum-函数设计" class="headerlink" title="addNum 函数设计"></a>addNum 函数设计</h3><p>&emsp;&emsp;addNum() 函数在添加元素的过程中保持两个堆的动态平衡：<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Condition 1.保证两堆元素个数相差不超过 1</span><br><span class="line">Condition 2.保证大顶堆中的元素小于等于小顶堆中的任何元素</span><br></pre></td></tr></table></figure></p><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><ul><li>如果两堆中的元素个数相同。这个时候无论插入哪一个堆，条件 1 都不会被破坏,因此考虑条件 2 ，将待插入元素与两堆的堆顶比较:若待插入元素为 5，显然这个时候若插入smaller会破坏条件 2，因此因插入bigger中。而若待插入为 9 则显然应插入 smaller 中。</li></ul><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case1.png" alt=""><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case1_1.png" alt=""><br><br></center><hr><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><ul><li>如果大顶堆元素个数小于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较:</li><li>若小于等于Bigger.top则直接插入Bigger中；</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case2.png" alt=""><br></center><ul><li>若大于smaller.top则为了保证条件1,需将smaller中的最小值（根）转存至Bigger中。</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case2_11.png" alt=""><br></center><hr><h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3:"></a>case 3:</h4><ul><li>如果大顶堆的元素个数大于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较：</li><li>若其大于等于Smaller.top则直接插入Smaller中；</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case3_1.png" alt=""><br></center><ul><li>若小于Bigger.top则为了保证条件1，需将Bigger中的最大元素值（根）转存至Smaller中。</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case3_2.png" alt=""><br></center><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Include_all.h"</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-comment">/** initialize your data structure here. */</span></span><br><span class="line">MedianFinder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//插入过程中维持两堆元素个数的动态平衡</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//如果两堆元素个数相同</span></span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.size()==bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(!bigger.empty() &amp;&amp; bigger.top()&gt;=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//小顶堆&gt;大顶堆</span></span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(smaller.size() &lt; bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(bigger.top()&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push bigger's top "</span> &lt;&lt; bigger.top() &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(bigger.top());</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop bigger's top'"</span> &lt;&lt; bigger.top() &lt;&lt;<span class="hljs-string">" from bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.pop();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//大顶堆&gt;小顶堆</span></span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.top() &lt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push smaller's top "</span> &lt;&lt; smaller.top() &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(smaller.top());</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop smaller's top "</span> &lt;&lt; smaller.top() &lt;&lt;<span class="hljs-string">" from smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.pop();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//该函数返回中位数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.size()==bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (smaller.top()+bigger.top())/<span class="hljs-number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(smaller.size()&gt;bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> smaller.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> bigger.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line"><span class="hljs-comment">//实现两个堆的动态平衡</span></span><br><span class="line">priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; smaller; <span class="hljs-comment">//小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; bigger; <span class="hljs-comment">//大顶堆</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="hljs-comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">46</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">67</span>,<span class="hljs-number">55</span>,<span class="hljs-number">66</span>&#125;;</span><br><span class="line">MedianFinder* obj = <span class="hljs-keyword">new</span> MedianFinder();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : nums)</span><br><span class="line">obj-&gt;addNum(i);</span><br><span class="line"><span class="hljs-keyword">double</span> param_2 = obj-&gt;findMedian();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; param_2 &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/leetcode295.png" alt=""><br></center><hr><h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LC295-数据流中的中位数-类设计）&quot;&gt;&lt;a href=&quot;#LC295-数据流中的中位数-类设计）&quot; class=&quot;headerlink&quot; title=&quot;[LC295] 数据流中的中位数(类设计）&quot;&gt;&lt;/a&gt;[LC295] 数据流中的中位数(类设计）&lt;/h2&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-卷积神经网络(0)</title>
    <link href="https://www.ccyh.xyz/2019/06/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D(0)/"/>
    <id>https://www.ccyh.xyz/2019/06/19/机器学习-卷积神经网络介绍(0)/</id>
    <published>2019-06-19T10:12:58.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;作为本系列的第一篇文章，本文仅对卷积神经网络的工作过程做一个简单的介绍，并不涉及数学原理与推导。若想要深入了解数学原理，那么可以去查看相关文献或者我将会在之后更新相关内容的文章。</p></blockquote><a id="more"></a><blockquote><p>&emsp;阅读这篇文章前你最好对简单的神经网络有一定的了解，如果没有，可以参看博主的神经人工神经网络学习笔记系列文章。<br>如果你已经做好了准备，那就让我们开始吧！</p></blockquote><hr><h2 id="什么是卷积神经网络？"><a href="#什么是卷积神经网络？" class="headerlink" title="什么是卷积神经网络？"></a>什么是卷积神经网络？</h2><hr><p>&emsp;卷积神经网络（Convolutional Neural Network，CNN）是前馈人工神经网络的一种。在图像识别领域有着广泛的应用并且非常有效。当人们谈到计算机视觉时，通常都绕不开卷积神经网络。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/google.gif" alt="谷歌相册图像搜索"><br></center><hr><h2 id="计算机眼中的图像"><a href="#计算机眼中的图像" class="headerlink" title="计算机眼中的图像"></a>计算机眼中的图像</h2><hr><p>&emsp;毫无疑问，你可以很快分辨下图中的动物是只猫。但在计算机“眼中”，它仅仅是一个数字序列。图像由一个个像素组成，每一个像素通常以RGB(Red,Green,Blue)三原色表示。但为了简化，我们使用灰度（0-255）表示，仅仅一个数字就可以表示（0：黑色 255：白色）。如此一来，对于一张$200\times 200$像素的图片，在计算机眼中就为一个$200\times 200$的矩阵，也即一个$40000$维的向量。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619123229184.png" alt="计算机眼中的图像"><br></center><br>&emsp;计算机学习（训练）识别图像的过程就是将许多图片向量输入某种算法处理后将结果与目标值相比对，对误差进行修正直到结果输出令人满意为止。待训练结束后再给它看一个从未看过的图像它也能准确地识别图像的内容。<br>&emsp;本系列文章我们将继续使用Mnist数据集来训练和测试神经网络。<br><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/mnist_8.gif" alt="Mnist数据集"><br></center><hr><h2 id="LeNet框架（20世纪90年代）"><a href="#LeNet框架（20世纪90年代）" class="headerlink" title="LeNet框架（20世纪90年代）"></a>LeNet框架（20世纪90年代）</h2><hr><p>&emsp;LeNet框架是卷积神经网络的祖师爷LeCun在1998年提出的，用于解决手写数字识别的视觉任务。自那时起，CNN的最基本的架构就定下来了：卷积层、池化层、全连接层。本篇文章也将围绕该框架来进行卷积神经网络的介绍。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/lenet.jpg" alt="LeNet框架简图"><br></center><hr><h2 id="LeNet-卷积神经网络的工作过程"><a href="#LeNet-卷积神经网络的工作过程" class="headerlink" title="LeNet 卷积神经网络的工作过程"></a>LeNet 卷积神经网络的工作过程</h2><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/lenet_cal.png" alt="卷积神经网络的计算过程"><br></center><hr><h3 id="1、卷积运算："><a href="#1、卷积运算：" class="headerlink" title="1、卷积运算："></a>1、卷积运算：</h3><hr><p>&emsp;顾名思义，卷积神经网络得名于“卷积”运算。在卷积神经网络中，卷积的主要目的是从目标图像中提取“特征”。通过使用输入数据中的小方块（矩阵分块）来学习图像特征，卷积运算保留了像素间的空间关系。<br>&emsp;正如前文所说，每个图像都可以被计算机看成是一个像素值矩阵。现仅考虑一个$5\times 5$像素的图像矩阵$W_{img}$：</p><p><div align="center"><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619045802129.png" alt=""><br></div><br>再令一个$3\times 3$的矩阵$W_{f}$：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619050403433.png" alt=""><br></center><br>将$3\times 3$的矩阵在$5\times 5$矩阵上移动并将对应位的数值相乘并求和，得到一个新的矩阵即为卷积运算后的特征值矩阵：<br><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/cnn_image_sample.gif" alt="卷积运算"><br></center><p>&emsp;这个由特征值组成的矩阵被称为 <strong>卷积特征</strong> 或 <strong>特征映射</strong> 。而上述参与卷积运算的$3\times 3$矩阵被称为 <strong>卷积滤波器</strong> 或 <strong>核</strong> 或 <strong>特征探测器</strong> （以下统称滤波器，但是事实上过滤器的作用就是原始图像的 <strong>特征检测器</strong>）。上述例子中过滤器在图像矩阵上每次移动1个像素单位，称为 <strong>步幅</strong> 。</p><p>&emsp;不难发现，不同的滤波器作用于相同图像上会得到不同的特征映射，下图列出了一些滤波器的取值以及功能作用(边缘检测，锐化等)：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619053433213.png" alt=""><br></center><p>&emsp;总的来说，一个滤波器在输入图像上移动（卷积操作）以生成特征映射。在同一张图像上，另一个滤波器的卷积生成了不同的特征图。需要注意到，卷积操作捕获原始图像中的局部依赖关系很重要。还要注意这两个不同的滤波器如何从同一张原始图像得到不同的特征图。请记住，以上图像和两个滤波器只是数值矩阵。<br>&emsp;实际上，卷积神经网络在训练过程中会自己学习这些滤波器的值（尽管在训练过程之前我们仍需要指定诸如滤波器数目、大小，网络框架等参数）。我们拥有的滤波器数目越多，提取的图像特征就越多，我们的网络在识别新图像时效果就会越好。</p><p>特征映射（卷积特征）的大小由我们在执行卷积步骤之前需要决定的三个参数控制：</p><ul><li><strong>深度：</strong>深度对应于我们用于卷积运算的过滤器数量。在图6所示的网络中，我们使用三个不同的过滤器对初始的船图像进行卷积，从而生成三个不同的特征图。可以将这三个特征地图视为堆叠的二维矩阵，因此，特征映射的“深度”为3。</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619054522781.png" alt="卷积操作"><br></center><ul><li><strong>步幅：</strong>步幅是我们在输入矩阵上移动一次过滤器矩阵的像素数量。当步幅为1时，我们一次将过滤器移动1个像素。当步幅为2时，过滤器每次移动2个像素。步幅越大，生成的特征映射越小。</li><li><strong>零填充：</strong>有时，将输入矩阵边界用零来填充会很方便，这样我们可以将过滤器应用于输入图像矩阵的边界元素。零填充一个很好的特性是它允许我们控制特征映射的大小。添加零填充也称为宽卷积，而不使用零填充是为窄卷积。</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619055337351.png" alt="边界零填充"><br></center><hr><h3 id="2、非线性操作（ReLU操作）"><a href="#2、非线性操作（ReLU操作）" class="headerlink" title="2、非线性操作（ReLU操作）"></a>2、非线性操作（ReLU操作）</h3><hr><p>&emsp;每次卷积操作之后，都会进行一次ReLU操作，其全称为修正线性单元（Rectified Linear Unit),是一种非线性操作。以下为修正线性函数的图像及表达式：</p><p>$$<br>f(x)=\begin{cases}<br>0, &amp; x&lt;0 \\<br>x, &amp; otherwise<br>\end{cases}<br>$$</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/ReLU.png" alt="修正线性函数"><br></center><p>&emsp;ReLU 是一个针对元素的操作（应用于每个像素），并将特征映射中的所有负像素值替换为零。ReLU 的目的是在卷积神经网络中引入非线性因素，因为在实际生活中我们想要用神经网络学习的数据大多数都是非线性的（卷积是一个线性运算 —— 按元素进行矩阵乘法和加法，所以我们希望通过引入 ReLU 这样的非线性函数来解决非线性问题）。<br>从可以很清楚地理解 ReLU 操作。它展示了将 ReLU 作用于某个特征映射得到的结果。这里的输出特征映射也被称为“修正”特征映射。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/relu_op.png" alt="修正线性函数"><br></center><p>其他非线性函数如 <strong>Sigmoid</strong> 或 <strong>tanh</strong> 也能达到类似效果，但是 <strong>ReLU</strong> 函数的效果是最好的。</p><hr><h3 id="3、池化（Pooling）"><a href="#3、池化（Pooling）" class="headerlink" title="3、池化（Pooling）"></a>3、池化（Pooling）</h3><hr><p>&emsp;空间池化（也称为子采样或下采样）可降低每个特征映射的维度，并保留最重要的信息。空间池化有几种不同的方式：<strong>最大值，平均值，求和等</strong>。</p><p>&emsp;在最大池化的情况下，我们定义一个空间邻域（例如一个2 × 2窗口），并取修正特征映射在该窗口内最大的元素。当然我们也可以取该窗口内所有元素的平均值（<strong>平均池化</strong>）或所有元素的总和。在实际运用中，<strong>最大池化</strong> 的表现更好。<br>&ensp;下图展示了通过2 × 2窗口在修正特征映射（卷积+ ReLU 操作后得到）上应用最大池化操作的示例:</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072042438.png" alt="Pooling"><br></center><p>&emsp;我们将2 x 2窗口移动2个单元格（也称为“步幅”），并取每个区域中的最大值。如图9所示，这样就降低了特征映射的维度,变成了一个$2\times 2$的矩阵。<br>&emsp;由于池化操作分别应用于每个特征映射（因此，我们从三个输入映射中得到了三个输出映射）。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072936964.png" alt="在修正后的特征映射上应用池化"><br></center><p>两种池化方法的结果对比：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072355283.png" alt="Pool Diffrent"><br></center><p>&emsp;池化的作用是逐步减少输入的空间大小。具体来说有以下四点：</p><ul><li>使输入（特征维度）更小，更易于管理</li><li>减少网络中的参数和运算次数，因此可以控制过拟合</li><li>使网络对输入图像微小的变换、失真和平移更加稳健（输入图片小幅度的失真不会改池化的输出结果 —— 因为我们取了邻域的最大值/平均值）</li><li>可以得到尺度几乎不变的图像（确切的术语是“等变”）。这是非常有用的，这样无论图片中的物体位于何处，我们都可以检测到</li></ul><p>&emsp;目前为止，我们已经了解了卷积神经网络中 <strong>卷积</strong>、<strong>ReLU</strong>、<strong>池化</strong> 的工作原理。这一点非常重要，下面我们将举例来描述这一过程。</p><hr><h2 id="可视化卷积神经网络"><a href="#可视化卷积神经网络" class="headerlink" title="可视化卷积神经网络"></a>可视化卷积神经网络</h2><hr><p>&emsp;Adam Harley 创建了一个基于 MNIST 手写数字数据集训练卷积神经网络的可视化。我强烈推荐大家 使用它来了解卷积神经网络的工作细节。其链接如下,可以自行尝试：</p><ul><li><a href="http://scs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">2D Visualization of a Convolutional Neural Network.</a></li></ul><hr><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619074946589.png" alt=""><br></center><hr><h3 id="1、卷积层"><a href="#1、卷积层" class="headerlink" title="1、卷积层"></a>1、卷积层</h3><p>&emsp;将鼠标放在卷积层的某个像素点上并点击会出现：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619075722203.png" alt=""><br></center><hr><h3 id="2、池化层"><a href="#2、池化层" class="headerlink" title="2、池化层"></a>2、池化层</h3><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080251028.png" alt=""><br></center><hr><h3 id="3、全连接层"><a href="#3、全连接层" class="headerlink" title="3、全连接层"></a>3、全连接层</h3><p>&emsp;全连接层的每一个结点都与其前一层的每一个结点相连接。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080952782.png" alt=""><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080746017.png" alt=""><br></center><hr><p>&emsp;该可视化项目还有3D版的，大家可以去玩玩，对于加深理解很有帮助。</p><hr><h2 id="卷积神经网络如何学习？"><a href="#卷积神经网络如何学习？" class="headerlink" title="卷积神经网络如何学习？"></a>卷积神经网络如何学习？</h2><hr><p>Waiting for update …</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;作为本系列的第一篇文章，本文仅对卷积神经网络的工作过程做一个简单的介绍，并不涉及数学原理与推导。若想要深入了解数学原理，那么可以去查看相关文献或者我将会在之后更新相关内容的文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（3）</title>
    <link href="https://www.ccyh.xyz/2019/06/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/07/人工神经网络学习笔记（3）/</id>
    <published>2019-06-07T12:02:15.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python-numpy编码实现人工神经网络"><a href="#Python-numpy编码实现人工神经网络" class="headerlink" title="Python-numpy编码实现人工神经网络"></a>Python-numpy编码实现人工神经网络</h3><hr><p>前面的几篇文章我们熟悉了人工神经网络的数学原理及其推导过程，但有道是‘纸上得来终觉浅’，是时候将理论变为现实了。现在我们将应用Python语言以及其强大的扩充程序库<a href="https://www.runoob.com/numpy/numpy-tutorial.html" target="_blank" rel="noopener">Numpy</a>来编写一个简单的神经网络。<br><a id="more"></a></p><hr><h4 id="准备数据："><a href="#准备数据：" class="headerlink" title="准备数据："></a>准备数据：</h4><ul><li><strong>训练集and测试集：</strong><a href="git@github.com:makeyourownneuralnetwork/makeyourownneuralnetwork.git">Mnist手写数字数据集(复制git链接克隆)</a>MINST数据库是由米国机器学习大佬Yann提供的手写数字数据库文件，其官方下载地址<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Download Mnist</a>。该数据集将会是神经网络的输入信号。</li></ul><p>每一张图片像素都为$28\times 28$,因此可作为一个$784\times 1$的向量传入神经网络。</p><div align="center"><br><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607010119916.png" alt="单个图片"><br><img src="/人工神经网络学习笔记（3）/20190607015526334.png" alt=""><br><br></div><ul><li>初始花链接权重矩阵：使用正态概率分布采样权重，平均值为0，标准方差为结点传入链接数目的开方，即$\frac{1}{\sqrt{inputconnects}}$</li></ul><hr><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>下面的代码实现了一个双隐层的神经网络，但是它的表现并不好（最起码在Mnist数据集的表现上差强人意），我训练了5个小时（5世代）也只能达到%96.54的准确率。相比而言当隐层的神经网络在Mnist数据集上的表现更好，三个小时（5世代）可以达到%97.34的准确率。你可以注释掉下面的部分代码将其退回到单隐层结构甚至加到三隐层结构。虽然代码写的很乱但代码中每一句都有详细的注释，别介意哈哈哈。<br>包含两个源代码文件：</p><ul><li>neural_network.py 包含神经网络主类用于训练神经网络</li><li>network_test.py 用于测试神经网络</li></ul><hr> <font size="3px" face="黑体" color="green"> neural_network.py </font><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.special</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.ndimage.interpolation</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">import</span> progressbar</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> anim</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 神经网络类定义</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">neuralNetwork</span>:</span></span><br><span class="line"><span class="hljs-comment"># 初始化神经网络</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,inputnodes,hiddennodes,hiddennodes_2,outputnodes,learningrate)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 设置神经网络的输入层、隐藏层、输出层、的结点数和学习率</span></span><br><span class="line">self.inodes = inputnodes</span><br><span class="line">self.hnodes = hiddennodes                <span class="hljs-comment"># 第一隐藏层结点数</span></span><br><span class="line">self.hnodes_2 = hiddennodes_2            <span class="hljs-comment"># 第二隐藏层结点数</span></span><br><span class="line"><span class="hljs-comment">#self.hnodes_3 = hiddennodes_3            # 第三隐藏层结点数</span></span><br><span class="line">self.onodes = outputnodes</span><br><span class="line"><span class="hljs-comment"># 学习率</span></span><br><span class="line">self.lr = learningrate</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># （常规版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络）</span></span><br><span class="line">self.wih = (numpy.random.rand(hiddennodes,inputnodes)<span class="hljs-number">-0.5</span>)            </span><br><span class="line">self.who = (numpy.random.rand(outputnodes,hiddennodes)<span class="hljs-number">-0.5</span>)           </span><br><span class="line"><span class="hljs-comment"># （进阶版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络）</span></span><br><span class="line">self.wih_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.hnodes,<span class="hljs-number">-0.5</span>),(hiddennodes,inputnodes))          <span class="hljs-comment"># 输入层到第一隐藏层权重矩阵</span></span><br><span class="line">self.wh12_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.hnodes_2,<span class="hljs-number">0.5</span>),(hiddennodes_2,hiddennodes))     <span class="hljs-comment"># 第一隐藏层到第二隐藏层权重矩阵</span></span><br><span class="line"><span class="hljs-comment">#self.wh23_ = numpy.random.normal(0.0,pow(self.hnodes_3,0.5),(hiddennodes_3,hiddennodes_2))   # 第二隐藏层到第三隐藏层权重矩阵</span></span><br><span class="line">self.who_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.onodes,<span class="hljs-number">-0.5</span>),(outputnodes,hiddennodes_2))         <span class="hljs-comment"># 第三隐藏层到输出层权重矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#定义激活函数，由scipy库提供</span></span><br><span class="line">self.activation_function = <span class="hljs-keyword">lambda</span> x : scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 训练神经网络</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(self,inputs_list,targets_list)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 将输入信号列表和目标信号列表转换成列向量</span></span><br><span class="line">inputs = numpy.array(inputs_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line">targets = numpy.array(targets_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第一隐藏层的输入信号：</span></span><br><span class="line">hidden_inputs = numpy.dot(self.wih_,inputs)</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层的输出信号（激活函数作用）：</span></span><br><span class="line">hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层的输入信号:</span></span><br><span class="line">hidden_inputs_2 = numpy.dot(self.wh12_,hidden_outputs)</span><br><span class="line"><span class="hljs-comment"># 第二层隐藏层的输出信号：</span></span><br><span class="line">hidden_outputs_2 = self.activation_function(hidden_inputs_2)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输入信号：</span></span><br><span class="line"><span class="hljs-string">hidden_inputs_3 = numpy.dot(self.wh23_,hidden_outputs_2)</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输出信号：</span></span><br><span class="line"><span class="hljs-string">hidden_outputs_3 = self.activation_function(hidden_inputs_3)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 输出层的输入信号：</span></span><br><span class="line">final_inputs = numpy.dot(self.who_,hidden_outputs_2)</span><br><span class="line"><span class="hljs-comment"># 输出层的输出信号：</span></span><br><span class="line">final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 计算输出层误差向量</span></span><br><span class="line">output_errors = targets - final_outputs</span><br><span class="line"><span class="hljs-comment"># 计算第三隐藏层误差向量</span></span><br><span class="line"><span class="hljs-comment">#hidden_errors_3 = numpy.dot(self.who_.T,output_errors)</span></span><br><span class="line"><span class="hljs-comment"># 计算第二隐藏层的误差向量</span></span><br><span class="line">hidden_errors_2 = numpy.dot(self.who_.T,output_errors)</span><br><span class="line"><span class="hljs-comment"># 计算第一隐藏层的误差向量</span></span><br><span class="line">hidden_errors = numpy.dot(self.wh12_.T,hidden_errors_2)</span><br><span class="line"></span><br><span class="line"><span class="hljs-string">''' 优化链接权重值 '''</span></span><br><span class="line"><span class="hljs-comment"># 第三隐藏层与输出层间的链接权重优化</span></span><br><span class="line"><span class="hljs-comment">#self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)),numpy.transpose(hidden_outputs_3))</span></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层与第三隐藏层间的链接权重优化</span></span><br><span class="line">self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (<span class="hljs-number">1.0</span> - final_outputs)),numpy.transpose(hidden_outputs_2))</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层与第二隐藏层间的链接权重优化</span></span><br><span class="line">self.wh12_ += self.lr * numpy.dot((hidden_errors_2 * hidden_outputs_2 * (<span class="hljs-number">1.0</span> - hidden_outputs_2)),numpy.transpose(hidden_outputs))</span><br><span class="line"><span class="hljs-comment"># 输入层与第一隐藏层间的链接权重优化</span></span><br><span class="line">self.wih_ += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="hljs-number">1.0</span> - hidden_outputs)),numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#return self.query(inputs_list)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 查询</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span><span class="hljs-params">(self,inputs_list)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 将输入列表转成numpy向量对象并转置为列向量</span></span><br><span class="line">inputs = numpy.array(inputs_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层结点的输入信号：权重矩阵与输入信号向量的乘积</span></span><br><span class="line">self.hidden_inputs = numpy.dot(self.wih_,inputs)</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层结点的输出信号：经过S函数的加权求和值</span></span><br><span class="line">self.hidden_outputs = self.activation_function(self.hidden_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层的输入信号:</span></span><br><span class="line">self.hidden_inputs_2 = numpy.dot(self.wh12_,self.hidden_outputs)</span><br><span class="line"><span class="hljs-comment"># 第二层隐藏层的输出信号：</span></span><br><span class="line">self.hidden_outputs_2 = self.activation_function(self.hidden_inputs_2)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输入信号：</span></span><br><span class="line"><span class="hljs-string">self.hidden_inputs_3 = numpy.dot(self.wh23_,self.hidden_outputs_2)</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输出信号：</span></span><br><span class="line"><span class="hljs-string">self.hidden_outputs_3 = self.activation_function(self.hidden_inputs_3)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 输出层结点的输入信号：</span></span><br><span class="line">self.final_inputs = numpy.dot(self.who_,self.hidden_outputs_2)</span><br><span class="line"><span class="hljs-comment"># 输出层结点的最终输出信号：</span></span><br><span class="line">self.final_outputs = self.activation_function(self.final_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 返回最终输出信号</span></span><br><span class="line"><span class="hljs-keyword">return</span> self.final_outputs</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(Network,test_dataset_name)</span>:</span></span><br><span class="line">Network.wih_ = numpy.loadtxt(<span class="hljs-string">'wih_file.csv'</span>)</span><br><span class="line">Network.wh12_ = numpy.loadtxt(<span class="hljs-string">'wh12_file.csv'</span>)</span><br><span class="line"><span class="hljs-comment">#Network.wh23_ = numpy.loadtxt('wh23_file.csv')</span></span><br><span class="line">Network.who_ = numpy.loadtxt(<span class="hljs-string">'who_file.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 准备测试数据</span></span><br><span class="line">test_data_file = open(test_dataset_name,<span class="hljs-string">'r'</span>)</span><br><span class="line">test_data_list = test_data_file.readlines()</span><br><span class="line">test_data_file.close()</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">'\n'</span>)</span><br><span class="line">print(<span class="hljs-string">"Testing...\n"</span>)</span><br><span class="line"><span class="hljs-comment"># 统计</span></span><br><span class="line">correct_test = <span class="hljs-number">0</span></span><br><span class="line">all_test = <span class="hljs-number">0</span></span><br><span class="line">correct = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</span><br><span class="line">num_counter = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#测试进度条</span></span><br><span class="line">p_test = progressbar.ProgressBar()</span><br><span class="line">p_test.start(len(test_data_list))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 动画显示</span></span><br><span class="line"><span class="hljs-comment">#plt.figure(1)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> imag_list <span class="hljs-keyword">in</span> test_data_list:</span><br><span class="line">all_values = imag_list.split(<span class="hljs-string">','</span>)</span><br><span class="line">lable = int(all_values[<span class="hljs-number">0</span>])</span><br><span class="line">scaled_input = (numpy.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span></span><br><span class="line">imag_array = numpy.asfarray(scaled_input).reshape((<span class="hljs-number">28</span>,<span class="hljs-number">28</span>))</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">plt.imshow(imag_array,cmap='Greys',animated=True)</span></span><br><span class="line"><span class="hljs-string">plt.draw()</span></span><br><span class="line"><span class="hljs-string">plt.pause(0.00001)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line">net_answer = Network.query(scaled_input).tolist().index(max(Network.final_outputs))</span><br><span class="line">num_counter[lable] += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> lable == int(net_answer):</span><br><span class="line">correct_test += <span class="hljs-number">1</span></span><br><span class="line">correct[lable] += <span class="hljs-number">1</span></span><br><span class="line">p_test.update(all_test + <span class="hljs-number">1</span>)</span><br><span class="line">all_test += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">p_test.finish()</span><br><span class="line">print(<span class="hljs-string">"Finish Test.\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 网络性能</span></span><br><span class="line">performance = correct_test/all_test</span><br><span class="line">Per_num_performance = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):</span><br><span class="line"><span class="hljs-comment"># 测试集可能不包含某些数字，故捕捉除以0异常</span></span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">Per_num_performance.append(correct[i]/num_counter[i])</span><br><span class="line"><span class="hljs-keyword">except</span> ZeroDivisionError:</span><br><span class="line">Per_num_performance.append(<span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"The correctRate of per number： "</span>,Per_num_performance)</span><br><span class="line">print(<span class="hljs-string">"Performance of the NeuralNetwork： "</span>,performance*<span class="hljs-number">100</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> performance</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 定义网络规模与学习率</span></span><br><span class="line">input_nodes = <span class="hljs-number">784</span></span><br><span class="line">hidden_nodes = <span class="hljs-number">700</span></span><br><span class="line">hidden_nodes_2 = <span class="hljs-number">700</span></span><br><span class="line"><span class="hljs-comment">#hidden_nodes_3 = 100</span></span><br><span class="line">output_nodes = <span class="hljs-number">10</span></span><br><span class="line">learningrate = <span class="hljs-number">0.0001</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 定义训练世代数</span></span><br><span class="line">epochs = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建神经网络实例</span></span><br><span class="line">Net = neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#plt.imshow(final_outputs,interpolation="nearest")</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 准备训练数据</span></span><br><span class="line">data_file = open(<span class="hljs-string">"mnist_train.csv"</span>,<span class="hljs-string">'r'</span>)</span><br><span class="line">data_list = data_file.readlines()</span><br><span class="line">N_train = len(data_list)</span><br><span class="line">data_file.close()</span><br><span class="line"><span class="hljs-comment"># 动画显示</span></span><br><span class="line"><span class="hljs-comment">#plt.figure(1)</span></span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"Training："</span>, epochs, <span class="hljs-string">"epochs..."</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> range(epochs):</span><br><span class="line"><span class="hljs-comment"># 训练进度条</span></span><br><span class="line">print(<span class="hljs-string">'\nThe '</span>+str(e+<span class="hljs-number">1</span>)+<span class="hljs-string">'th epoch trainning:\n'</span>)</span><br><span class="line">p_train = progressbar.ProgressBar()</span><br><span class="line">p_train.start(N_train)</span><br><span class="line">i = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> img_list <span class="hljs-keyword">in</span> data_list:</span><br><span class="line"><span class="hljs-comment"># 以逗号分割记录</span></span><br><span class="line">all_values = img_list.split(<span class="hljs-string">','</span>)</span><br><span class="line"><span class="hljs-comment"># 将0-255映射到0.01-0.99</span></span><br><span class="line">scaled_input = (numpy.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span></span><br><span class="line">imag_array = numpy.asfarray(scaled_input).reshape((<span class="hljs-number">28</span>,<span class="hljs-number">28</span>))</span><br><span class="line"><span class="hljs-comment">#plt.imshow(imag_array,cmap='Greys',animated=True)</span></span><br><span class="line"><span class="hljs-comment">#plt.draw()</span></span><br><span class="line"><span class="hljs-comment">#plt.pause(0.00001)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#旋转图像生成新的训练集</span></span><br><span class="line">input_plus_10imag = scipy.ndimage.interpolation.rotate(imag_array,<span class="hljs-number">10</span>,cval=<span class="hljs-number">0.01</span>,reshape=<span class="hljs-keyword">False</span>)</span><br><span class="line">input_minus_10imag = scipy.ndimage.interpolation.rotate(imag_array,<span class="hljs-number">-10</span>,cval=<span class="hljs-number">0.01</span>,reshape=<span class="hljs-keyword">False</span>)</span><br><span class="line">input_plus10 = input_plus_10imag.reshape((<span class="hljs-number">1</span>,<span class="hljs-number">784</span>))</span><br><span class="line">input_minus10 = input_minus_10imag.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">784</span>))</span><br><span class="line"><span class="hljs-comment"># 根据标签创建目标值向量</span></span><br><span class="line">targets = numpy.zeros(output_nodes) + <span class="hljs-number">0.01</span></span><br><span class="line">targets[int(all_values[<span class="hljs-number">0</span>])] = <span class="hljs-number">0.99</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 用三个训练集训练神经网络</span></span><br><span class="line">Net.train(scaled_input,targets)</span><br><span class="line">Net.train(input_plus10,targets)</span><br><span class="line">Net.train(input_minus10,targets)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#time.sleep(0.01)</span></span><br><span class="line">p_train.update(i+<span class="hljs-number">1</span>)</span><br><span class="line">i+=<span class="hljs-number">1</span></span><br><span class="line">p_train.finish()</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"\nTrainning finish.\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 将训练好的神经网络链接权重输出到csv文件中</span></span><br><span class="line">numpy.savetxt(<span class="hljs-string">'wih_file.csv'</span>,Net.wih_,fmt=<span class="hljs-string">'%f'</span>)</span><br><span class="line">numpy.savetxt(<span class="hljs-string">'wh12_file.csv'</span>,Net.wh12_,fmt=<span class="hljs-string">'%f'</span>)</span><br><span class="line"><span class="hljs-comment">#numpy.savetxt('wh23_file.csv',Net.wh23_,fmt='%f')</span></span><br><span class="line">numpy.savetxt(<span class="hljs-string">'who_file.csv'</span>,Net.who_,fmt=<span class="hljs-string">'%f'</span>)</span><br></pre></td></tr></table></figure> <font face="黑体" size="3px" color="green"> network_test.py </font><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> neural_network <span class="hljs-keyword">as</span> nk</span><br><span class="line"><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pl</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.special</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.ndimage.interpolation</span><br><span class="line"><span class="hljs-keyword">import</span> json</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">import</span> progressbar</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 测试神经网络</span></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">input_nodes = nk.input_nodes</span><br><span class="line">hidden_nodes = nk.hidden_nodes</span><br><span class="line">hidden_nodes_2 = nk.hidden_nodes_2</span><br><span class="line"><span class="hljs-comment">#hidden_nodes_3 = nk.hidden_nodes_3</span></span><br><span class="line">output_nodes = nk.output_nodes</span><br><span class="line">learningrate = nk.learningrate</span><br><span class="line">Network = nk.neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate)</span><br><span class="line">nk.test(Network,<span class="hljs-string">"mnist_test.csv"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># hidden_nodes = 200 lr = 0.01 performance = 97.34</span></span><br></pre></td></tr></table></figure><hr><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><ol><li>cd进入代码所在文件夹</li><li>(训练神经网络)输入命令：<font color="green" face="黑体">python</font> <font color="blue" face="黑体">neural_network.py</font></li></ol><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607011216578.png" alt="Training"></p><ol start="3"><li>（测试神经网络）输入命令：<font color="green" face="黑体">python</font> <font color="blue" face="黑体">network_test.py</font></li></ol><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607011510082.png" alt="Testing"></p><font size="1px" color="red">[Warning] 运行时请确保训练集和测试集数据的.csv文件与源代码文件在同一个目录下，否则请修改源码中的文件路径</font>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python-numpy编码实现人工神经网络&quot;&gt;&lt;a href=&quot;#Python-numpy编码实现人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;Python-numpy编码实现人工神经网络&quot;&gt;&lt;/a&gt;Python-numpy编码实现人工神经网络&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;前面的几篇文章我们熟悉了人工神经网络的数学原理及其推导过程，但有道是‘纸上得来终觉浅’，是时候将理论变为现实了。现在我们将应用Python语言以及其强大的扩充程序库&lt;a href=&quot;https://www.runoob.com/numpy/numpy-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numpy&lt;/a&gt;来编写一个简单的神经网络。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（2）</title>
    <link href="https://www.ccyh.xyz/2019/06/04/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/04/人工神经网络学习笔记（2）/</id>
    <published>2019-06-04T10:02:53.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何更新权重"><a href="#如何更新权重" class="headerlink" title="如何更新权重"></a>如何更新权重</h3><p>在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？<br><a id="more"></a></p><ul><li><strong>暴力枚举：</strong>对于一个三层的神经网络，每层有3个神经元结点，有两个$3\times 3$的链接权重矩阵，共有18个权重值。假设每个权重在1和-1之间共有1000种取值，那么我们有$1000^{18}$种权重组合，这个数字已经很大了。但是，如果是每层有500个结点呢？那么权重数将达到$2\times 500\times 500 = 500000$个，将会有$1000^{500000}$种组合。想要遍历这么些种可能得等到人类灭绝…</li></ul><p>可见，暴力枚举并不能实际地解决我们的问题。</p><ul><li><strong>新的思路：</strong>让我们再次明确下我们的最终目的，让误差值降到最小。试着将其转化成数学上的求函数最小值问题。先前我们知道，误差是所有链接权重的函数:<br>$$<br>Error = F_{error}(w_{1,1},w_{2,1},……,w_{j,k})<br>$$<br>现在我们需要额就是找出该函数的最小值。但由于真正的误差函数的自变量太多，先举个简单的例子：<br>假设误差函数只有一个自变量（链接权重）：<br>$$<br>E_{simple}=F_e(x)<br>$$<br>其图像为：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604110727225.png" alt=""><br>可以将其想象成一个连绵的山脉，有山峰也有山谷。设想将一个小球至于山腰，那么在重力的作用下它必定沿着所在位置的斜率方向向下滚动直到山谷。但是很明显，我们并没有重力帮忙，因此必须人为指定“滚动方向”。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604112226207.png" alt=""><br>不难发现，当斜率为正时应向左滚动（x–），斜率为负时应向右滚动（x++）。这种方法在数学上被称为梯度下降（gradient descent）。<br><strong>可能的意外情况：</strong><br>我们可能会碰到这种情况：当小球的起始位置为左侧山腰时，其很有可能最终会在局部最小值（左侧的山谷）停下，这可不是我们所希望的结果。因为我们的目的是把误差降到最小，那里显然不是最小的地方。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604114310137.png" alt=""><br>为了避免上述情况，我们应从选择不同的其实位置对神经网络进行多次训练，以确保其并不总是终止于错误的地方。而不同的其实位置意味着不同的链接权重。</li></ul><hr><h3 id="选择误差函数的形式"><a href="#选择误差函数的形式" class="headerlink" title="选择误差函数的形式"></a>选择误差函数的形式</h3><p>可选项：</p><ol><li>$E=t_n-o_n$  (目标值 - 期望值)</li><li>$E=(t_n-o_n)^2$  方差形式</li></ol><p>我们选用方差形式，因为其具有很多优点：</p><ol><li>可以很容易地使用代数方法（链式法则求解偏导数）计算出梯度下降的斜率</li><li>误差函数平滑连续，这使得梯度下降算法可以很好地发挥作用</li><li>越接近最小值梯度（斜率）越小，按照斜率调整步长可以减少越过最佳位置的风险</li></ol><hr><h3 id="计算梯度值（斜率）"><a href="#计算梯度值（斜率）" class="headerlink" title="计算梯度值（斜率）"></a>计算梯度值（斜率）</h3><ul><li>当只有一个链接权重时，误差函数为二维曲线：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604012324203.png" alt=""><br>$$<br>k=\frac{\partial{E}}{\partial{x}}<br>$$</li><li>当有两个链接权重时，误差函数为一个三维曲面：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1559636048297&amp;di=a69a0ac50c0c4c39c6290d14fe697429&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.ph.126.net%2FwdlmGd6Cl2EyG0Bp-xEihQ%3D%3D%2F1016406140918957318.jpg" alt=""><br>$$<br>k=\frac{\partial{E}}{\partial{w_{j,k}}}<br>$$<br>上述表达式表示了当权重$w_{j,k}$改变时，误差$E$是如何改变的。这是误差函数的斜率，也就是我们希望使用梯度下降的方法达到最小值的方向。</li></ul><p><strong>计算梯度：</strong></p><ol><li>在开始计算前我们回顾一下网络中各个参数的意义：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604014334436.png" alt=""></li><li>展开误差函数：<br>由于一个结点的误差只与与其相连的链接权重有关，因此误差函数可以简单地表示为：<br>$$<br>E=(t_k-o_k)^2<br>$$<br>其中：$o_k=Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})$所以：<br>$$<br>E=(t_k-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))^2<br>$$<br>所以：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=\frac{\partial{(t_k-o_k)^2}}{\partial{w_{j,k}}}<br>$$<br>$$<br>=\frac{\partial{E}}{\partial{o_k}}\cdot \frac{\partial{o_k}}{\partial{w_{j,k}}}=-2(t_k-o_k)\cdot \frac{\partial{o_k}}{\partial{w_{j,k}}}<br>$$<br>其中：令$x=\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}$<br>$$<br>\frac{\partial{o_k}}{\partial{w_{j,k}}}=\frac{\partial{Sig(x)}}{\partial{w_{j,k}}}=\frac{\partial{Sig(x)}}{\partial{x}}\cdot \frac{\partial{x}}{\partial{w_{j,k}}}<br>$$<br>且：<br>$$<br>\frac{\partial{Sig(x)}}{\partial{x}}=Sig(x)\cdot (1-Sig(x))<br>$$<br>因此，我们得到了以下表达式：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=-2(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot \frac{\partial{(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}})}{\partial{w_{j,k}}}<br>$$<br>$$<br>=-2(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$<br>又由于我们只关心误差函数斜率的方向，因此可以将公式中的常数2省略，并不影响正负号：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=-(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$<br>$$<br>=-(e_j)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$</li></ol><h3 id="改变链接权重"><a href="#改变链接权重" class="headerlink" title="改变链接权重"></a>改变链接权重</h3><p>之前提到过，权重的改变方向与梯度的方向相反。因此我们规定权重的改变方式为：<br>$$<br>w_{j,k}^{new}=w_{j,k}^{old}-\alpha \cdot \frac{\partial{E}}{\partial{w_{j,k}}}<br>$$<br>参数释义：</p><ul><li>$\alpha$为学习因子，可以调节这些权重变化的强度</li></ul><p><strong>用矩阵来简化运算：</strong><br>$$<br>\left(<br>\begin{matrix}<br>\vartriangle w_{1,1} &amp; \vartriangle w_{2,1} &amp; \vartriangle w_{3,1} &amp; …\\<br>\vartriangle w_{1,2} &amp; \vartriangle w_{2,2} &amp; \vartriangle w_{3,2} &amp; …\\<br>\vartriangle w_{1,3} &amp; \vartriangle w_{2,3} &amp; \vartriangle w_{3,3} &amp; …\\<br>… &amp; … &amp; … &amp; …<br>\end{matrix}<br>\right)=\alpha\cdot \left(\begin{matrix}e_1\cdot S_1\cdot (1-S_1)\\ e_2\cdot S_2\cdot (1-S_2)\\ e_k\cdot S_k\cdot (1-S_k)\\ …\end{matrix}\right) \cdot (o_1,o_2,o_3,…)<br>$$<br>将Sig函数简化为输出：<br>$$<br>\vartriangle w_{j,k} = \alpha\times E_k \times O_k \times (1-O_k) \cdot O_j^T<br>$$</p><hr><p>到此，所有的前期工作都已完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何更新权重&quot;&gt;&lt;a href=&quot;#如何更新权重&quot; class=&quot;headerlink&quot; title=&quot;如何更新权重&quot;&gt;&lt;/a&gt;如何更新权重&lt;/h3&gt;&lt;p&gt;在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（1）</title>
    <link href="https://www.ccyh.xyz/2019/06/03/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/03/人工神经网络学习比记（1）/</id>
    <published>2019-06-03T15:16:03.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何让网络可以学习"><a href="#如何让网络可以学习" class="headerlink" title="如何让网络可以学习"></a>如何让网络可以学习</h3><p>上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况：<br><a id="more"></a></p><ul><li>老师：1+1=？</li><li>小明：6</li><li>老师：1+2=？</li><li>小明：2</li><li>…</li></ul><p>可以发现，当小明给出答案后老师并没有给于他反馈。因此小明可能某一次猜中了正确答案，但只是凑巧而已，他不具备学习能力。<br>现在让老师给点反馈：</p><ul><li>老师：1+5=？</li><li>小明：4</li><li>老师：少了</li><li>小明：5</li><li>老师：少了</li><li>小明：6</li><li>老师：正确，你真棒！</li></ul><p>这样子，小明学会了1+5=6.<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023656961.png" alt="三层神经网络"><br>我们的神经网络也需要具备这样的学习能力。<br>也就是说，当网络输出错误的结果时要有一个改变下一次输出的机制。想要改变输出，可以改变哪些量呢？<br>观察输出函数：<br>$$<br>O_{output}=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot i_{oj}}) \\<br>\end{matrix}<br>\right]=\left[\begin{matrix}o_1\\o_2\\o_3\end{matrix}\right]<br>$$<br>不难发现，输出值与以下参数有关：</p><ol><li>SigMoid函数</li><li>链接权重</li><li>输入值</li></ol><p>显然，我们不可能去左右网络的输入值，因为那是网络要求解的问题，不可能以改变问题的方式改变答案。那么改变激活函数sig如何？这太麻烦了，试想那么多的神经元每一个都不同的激活函数会对运算造成大麻烦，将无法采用简洁的矩阵运算。<br>因此，<strong>改变链接权重</strong>会是一个好办法。</p><hr><h3 id="学习能力的养成"><a href="#学习能力的养成" class="headerlink" title="学习能力的养成"></a>学习能力的养成</h3><p>我们已经知道可以通过改变链接权重来改变网络的输出值，使其符合预期。那么问题又来了：</p><ol><li>改变权重的依据是什么？</li><li>如何改变？</li><li>改变的幅度多大合适？</li></ol><hr><h4 id="改变的依据"><a href="#改变的依据" class="headerlink" title="改变的依据"></a>改变的依据</h4><p>改变权重的目的是让输出值与期望值越接近越好（误差值越小越好），因此误差就是依据。所谓误差就是期望值与网络输出值的差：<br>$$<br>E=t-o<br>$$<br>我们知道输出层的误差为：$E_o=t_n-o_n$，但是其他层结点的误差是不知道的，因为其他层并没有一个输出期望值$t_n$。<br>不难发现，最终输出层造成的误差是所有层共同作用的结果，所以可以将总误差分摊给其他层。</p><h5 id="误差的反向传播"><a href="#误差的反向传播" class="headerlink" title="误差的反向传播"></a>误差的反向传播</h5><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/20190603111024704.png" alt="单个神经元的误差分配"></p><hr><p>如上图误差为$e_1$，因为链接权重越大说明对该误差的影响越大，因此以链接权重来决定每条链路所分摊误差的大小：<br>$$<br>e_{w_{1,1}}=\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\cdot e_1<br>$$<br>$$<br>e_{w_{2,1}}=\frac{w_{2,1}}{w_{1,1}+w_{2,1}}\cdot e_1<br>$$<br><strong>反向传播误差到更多层中：</strong><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/20190603113735974.png" alt="误差的反向传播"><br>隐藏层结点的误差值：<br>$$<br>e_{h1}=\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\cdot e_{o1}+\frac{w_{1,2}}{w_{1,2}+w_{2,2}}\cdot e_{o2}<br>$$</p><hr><h5 id="使用矩阵乘法简化误差反向传播"><a href="#使用矩阵乘法简化误差反向传播" class="headerlink" title="使用矩阵乘法简化误差反向传播"></a>使用矩阵乘法简化误差反向传播</h5><ol><li>误差向量：<br>$$<br>error_{output}=<br>\left(<br>\begin{matrix}<br>e_1 \\<br>e_2<br>\end{matrix}<br>\right)<br>$$</li><li>隐藏层误差：<br>$$<br>error_{hidden}=<br>\left(<br>\begin{matrix}<br>\frac{w_{1,1}}{w_{1,1}+w_{2,1}} &amp; \frac{w_{1,2}}{w_{1,2}+w_{2,2}} \\<br>\\<br>\frac{w_{2,1}}{w_{1,1}+w_{2,1}} &amp; \frac{w_{2,2}}{w_{1,2}+w_{2,2}}<br>\end{matrix}<br>\right) \cdot \left(\begin{matrix}e_1 \\ e_2 \end{matrix} \right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>上述矩阵乘法太过复杂，无法通过简单的矩阵运算求解。观察上式可知，最重要的事情是输出误差链接权重$w_{j,k}$的乘法。较大的权重携带较大的误差给隐藏层，这些分数的分母是一种归一化因子。如果我们忽略掉这个因子，我们仅仅只是失去了后馈误差的真实值大小，但并没有失去其表示的真正含义（影响力）,也就是说反馈误差始终是以链接权重的强度来分配的。因此上式可以简化为：<br>$$<br>error_{hidden}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{1,2} \\<br>w_{2,1} &amp; w_{2,2}<br>\end{matrix}<br>\right)\cdot \left(\begin{matrix}e_1\\ e_2\end{matrix}\right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>不难发现，隐藏层至输出层的链接权重矩阵$W_{hidden\rightarrow output}$为:<br>$$<br>W_{hidden\rightarrow output}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} \\<br>w_{1,2} &amp; w_{2,2}<br>\end{matrix}<br>\right)=\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{1,2} \\<br>w_{2,1} &amp; w_{2,2}<br>\end{matrix}<br>\right)^T<br>$$<br>因此：<br>$$<br>error_{hidden}=W_{hidden\rightarrow output}^T\cdot error_{output}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} \\<br>w_{1,2} &amp; w_{2,2}<br>\end{matrix}<br>\right)^T\cdot \left(\begin{matrix}e_1\\ e_2\end{matrix}\right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>到此我们得到了用矩阵来传播误差的算法：<br>$$<br>error_{hidden}=W_{hidden\rightarrow output}^T\cdot error_{output}<br>$$</li></ol><hr><p>到此，我们已经做了大量的工作了。我们计算出了所有层的误差，接下来的工作就是根据误差来调整链接权重了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何让网络可以学习&quot;&gt;&lt;a href=&quot;#如何让网络可以学习&quot; class=&quot;headerlink&quot; title=&quot;如何让网络可以学习&quot;&gt;&lt;/a&gt;如何让网络可以学习&lt;/h3&gt;&lt;p&gt;上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（0）</title>
    <link href="https://www.ccyh.xyz/2019/06/03/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/03/人工神经网络学习笔记（0）/</id>
    <published>2019-06-03T14:25:33.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="何为人工神经网络"><a href="#何为人工神经网络" class="headerlink" title="何为人工神经网络"></a>何为人工神经网络</h2><p>人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。<br><a id="more"></a></p><h2 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2877951112,4239204535&amp;fm=26&amp;gp=0.jpg" alt=""><br><strong>关键部件：</strong> 树突 &amp; 胞体 &amp; 轴突</p><ul><li>单个神经元的工作机制可以简单地描述为：树突接受其他神经元的神经末梢传来的电信号，信号传送到胞体并由某种机制决定是否激发下一次电信号的传递，若激发则电信号由轴突传递至神经末梢，再由神经末梢传递给其他神经元。其中，判断是否激发的机制有一大好处是可以减小神经元间微弱电信号（噪声）的干扰，使得自由足够强的电信号才能激发下一次传递。</li></ul><h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1784596280,2741805283&amp;fm=26&amp;gp=0.jpg" alt="人工神经元"></p><ul><li>由生物神经元得到的启发，人工神经元与其大同小异。上图中： $x_1,x_2,x_3,x_4$ 为该神经元树突所接受到的其他神经元传来的电信号。中间的圆圈为胞体，在胞体中将会由处理信号的机制，以决定输出信号y。<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3></li><li>在之前的生物神经元中已经说道，神经元对是否激发信号传递有一个判断机制，这是因为神经元不希望传递微小的噪声信号，而只传递有意识的明显信号。只有信号强度达到了某一个阙值，才会激发电信号的传递。<br><strong>那么在人工神经元中我们如何来实现这个机制呢？</strong></li><li>这样的一个函数也许能够满足我们的需要：<br>$$Function(x) = \begin{cases}<br>0 &amp; x \leq T \\<br>1 &amp; x&gt;T<br>\end{cases}$$<br>显而易见，这个简单的阶跃函数在输入信号大于T（阙值）时才会产生输出信号1（被激发），而较小的输入时输出为0（被抑制）；我们称这样的函数为激活函数。当然，激活函数不会就只有这么一种。常用的还有sigmoid函数：<br>$$Sigmoid(x) = \frac{1}{1+e^{-x}}$$<br>函数图像：<br><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2160826125,3899173269&amp;fm=26&amp;gp=0.jpg" alt=""><br>可以发现，sigmoid函数相对于阶跃函数而言更加平滑，自然，接近现实。我们的神经网络也将采用它。<br>如此一来，我们的单个神经元模型就成型了：<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/model.jpeg" alt="人工神经元模型"><br>参数含义：</li><li>$x_1 ,x_2… x_m$为输入信号</li><li>$w_1 ,w_2… w_m$为权重值，表示各个输入信号对输出结果的影响力大小。对于为何引入权值可以做如下思考：你去相亲，你对未来对象的考量主要有身高，长相，身材，文化程度等，但遇到样样都好的概率实在是太底了，所以你决定适当放宽某些要求。比如如果学历高就可以降低身材长相的要求。这表示你比较注重伴侣的文化程度。因此，对方的文化程度对你的择偶有着重要的影响，其所占权重就会比较高。</li><li>求和函数将计算$x=\sum_{m}{x_iw_i},i=1,2,…m$后将所得的值传给激活函数Sigmoid即：<br>$$Output=Sig(x)=\frac{1}{1+e^{-(\sum_{m}{x_iw_i})}}$$<br>观察函数图不难发现，Sigmoid函数将加权求和的输入映射到0~1的值域内输出。<h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=266571296,2744303426&amp;fm=26&amp;gp=0.jpg" alt=""><br>介绍完单个神经元的功能，如果把这些小部件组合起来，就成了所谓的人工神经网络。<br><strong>层次结构：</strong></li><li>输入层：接受外部输入信息，可以是图片等。</li><li>隐藏层：隐藏层层数不一，可根据需求来定。</li><li>输出层：将结果输出到外部。</li></ul><p><strong>链接方式：</strong></p><ul><li>除输入层外，每一层的每个神经元都接受其上一层所有神经元传来的信号的加权值。</li><li>神经元的链接方式并不唯一，你可以创造自己的链接方式，但为了便于抽象计算编码，规则的链接方式能帮我们大忙。</li></ul><h3 id="一个三层神经网络示例"><a href="#一个三层神经网络示例" class="headerlink" title="一个三层神经网络示例"></a>一个三层神经网络示例</h3><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023656961.png" alt=""></p><hr><p><strong>参数释义：</strong></p><ul><li>$i_1,i_2,i_3$为输入信号。</li><li>$w_{j,k}$表示后层结点$j$与前一层节点$k$之间链接的权重值。</li><li>$o_1,o_2,o_3$为该网络输出的结果信号。</li></ul><hr><p><strong>信号的前向传播：</strong><br>前面我们介绍了单个人工神经元对信号的处理。但是现在网络中有多个神经元，我们当然不愿意对每一个神经元节点都进行编码计算，因此我们将其简化为矩阵运算。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023612835.png" alt=""></p><ol><li>将输入看成一个多维列向量：<br>$$<br>I=<br>\left[<br>\begin{matrix}<br>i_1 \\<br>i_2 \\<br>i_3<br>\end{matrix} \right]<br>$$</li><li>链接权重为一个$3\times3$的矩阵：<br>$$<br>W_{input\rightarrow hidden}=<br>\left[<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} &amp; w_{3,1} \\<br>w_{1,2} &amp; w_{2,2} &amp; w_{3,2} \\<br>w_{1,3} &amp; w_{2,3} &amp; w_{3,3}<br>\end{matrix} \right]<br>$$</li><li>将两者相乘得到隐藏层的输入信号：<br>$$<br>I_{hidden}=W_{input\rightarrow hidden}\cdot I=<br>\left[<br>\begin{matrix}<br>w_{1,1}\cdot i_1 + w_{2,1}\cdot i_2 + w_{3,1}\cdot i_3 \\<br>w_{1,2}\cdot i_1 + w_{2,2}\cdot i_2 + w_{3,2}\cdot i_3 \\<br>w_{1,3}\cdot i_1 + w_{2,3}\cdot i_2 + w_{3,3}\cdot i_3<br>\end{matrix} \right]<br>$$<br>也即：<br>$$<br>I_{hidden}=<br>\left[<br>\begin{matrix}<br>\sum_{j=1}^{3}{w_{j,1}\cdot i_j} \\<br>\sum_{j=1}^{3}{w_{j,2}\cdot i_j} \\<br>\sum_{j=1}^{3}{w_{j,3}\cdot i_j}<br>\end{matrix}\right]=[i_{h1},i_{h2},i_{h3}]^T<br>$$</li><li>再将加权求和的信号值经过Sigmoid激活函数处理我们可以得到最终的输出向量：<br>$$<br>O_{hidden}=Sig(W_{hidden\rightarrow output}\cdot I_{hidden})=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot o_{hj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot o_{hj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot o_{hj}}) \\<br>\end{matrix}<br>\right]=[o_{h1},o_{h2},o_{h3}]^T<br>$$<br>这里需要注意的是，输入层到隐藏层的链接权重矩阵与隐藏层到输出成的链接权重矩阵是不同的矩阵。但是计算过程是一致的，因此同理可得：<br>$$<br>I_{output}=Sig(W_{hidden\rightarrow output}\cdot O_{hidden})<br>$$<br>网络的最终输出为：<br>$$<br>O_{output}=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot i_{oj}}) \\<br>\end{matrix}<br>\right]=[o_1,o_2,o_3]^T<br>$$<br>到此，我们已经了解了神经网络中信号的前向传播机制，但是目前这个网络模型远远达不到我们的要求，它除了单纯的传播信号什么事情也做不了。显然后续我们得为其添加反馈机制，使其能够具有学习能力。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;何为人工神经网络&quot;&gt;&lt;a href=&quot;#何为人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;何为人工神经网络&quot;&gt;&lt;/a&gt;何为人工神经网络&lt;/h2&gt;&lt;p&gt;人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>感知机与逻辑门的实现</title>
    <link href="https://www.ccyh.xyz/2019/06/01/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.ccyh.xyz/2019/06/01/感知机与逻辑门的实现/</id>
    <published>2019-06-01T14:49:16.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><hr><p>&emsp;感知机（Perceptron）由两层神经元组成，输入层接收外界信号后传递给输出层，输出层是M-P神经元（如下图），亦称<strong>” 阙值逻辑单元（threshold logic unit）“</strong>。</p><a id="more"></a><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20190624050228397.png" alt="M-P神经元简图"><br></center><h1 id="逻辑门的实现"><a href="#逻辑门的实现" class="headerlink" title="逻辑门的实现"></a>逻辑门的实现</h1><hr><p>&emsp;感知机能容易地实现逻辑与、或、非、异或运算。注意到$y=f(\sum_{i}{w_ix_i-\theta})$,假定$f$为阶跃函数:<br>$$<br>sgn(x) = \begin{cases}<br>1, &amp; x&gt;= 0 \\<br>0, &amp; x&lt;0<br>\end{cases}<br>$$<br>则有：</p><ul><li>与门（$ x_1\land x_2 $）：令$w_1=w_2=1,\theta=1.5$,则$y=f(1\cdot x_1+1\cdot x_2-2)$,仅当$x_1=x_2=1$时，$y=1$</li></ul><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python实现与门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AND</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    </span><br><span class="line">    w1,w2,theta = <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>或门（$x_1\lor x_2$）：令$w_1=w_2=1,\theta=0.5$,则$y=f(1\cdot x_1+1\cdot x_2-0.5)$,仅当$x_1=1$或$x_2=1$时，$y=1$。</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python实现或门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OR</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    w1,w2,theta = <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>非门（$\lnot x_1$）：令$w_1=-0.6$,$w_2=0,\theta=-0.5$,则$y=f(-0.6\cdot x_1+0\cdot x_2+0.5)$,仅当$x_1=1$时，$y=0$；当$x_1=0$时，$y=1$。</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现非门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NOT</span><span class="hljs-params">(x1)</span>:</span></span><br><span class="line">    w1, theta = <span class="hljs-number">-0.6</span>, <span class="hljs-number">-0.5</span></span><br><span class="line">    result = w1*x1 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>与非门：令$w_1=w_2=-1,\theta=-1.5$,则$y=f(1\cdot x_1+1\cdot x_2+1.5)$,仅当$x_1=x_2=1$时，$y=0$</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现与非门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NAND</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    w1,w2,theta = <span class="hljs-number">-1.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">-1.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>异或门（$x_1\oplus x_2$）：异或门在生活中有很多用处，我们常常听到下面这句话：“这件事要么你来做，要么我来做”。意思是这件事只能由我们之间的任何一个人来做，其他都不行。又比如你房间中的灯的开关一般门口一个床头一个，这样子你每按下其中任何一个开关都只会有两种结果（变得与另一个一样，变得与另一个不一样）利用这两种结果就可以构成灯的开与关。</p></li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20190624055322320.png" alt=""><br></center><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现异或门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ExOR</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> AND(OR(x1,x2),NAND(x1,x2))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;感知机&quot;&gt;&lt;a href=&quot;#感知机&quot; class=&quot;headerlink&quot; title=&quot;感知机&quot;&gt;&lt;/a&gt;感知机&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;感知机（Perceptron）由两层神经元组成，输入层接收外界信号后传递给输出层，输出层是M-P神经元（如下图），亦称&lt;strong&gt;” 阙值逻辑单元（threshold logic unit）“&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-icarus修改文章详情页</title>
    <link href="https://www.ccyh.xyz/2019/05/01/Hexo-icarus%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E9%A1%B5/"/>
    <id>https://www.ccyh.xyz/2019/05/01/Hexo-icarus修改文章详情页/</id>
    <published>2019-05-01T18:46:04.000Z</published>
    <updated>2020-01-23T07:50:10.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么修改？"><a href="#为什么修改？" class="headerlink" title="为什么修改？"></a>为什么修改？</h2><a id="more"></a><p>由于Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局。但是三栏布局限制了文章内容的展示，因此试图将其改为两栏布局。</p><hr><h2 id="通过修改源代码来达成目标"><a href="#通过修改源代码来达成目标" class="headerlink" title="通过修改源代码来达成目标"></a>通过修改源代码来达成目标</h2><p>打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">col</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!is_post())&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> main_column_class();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'is-6-tablet is-6-desktop is-9-widescreen'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>再section标签中做如下改动：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"section"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"columns"</span>&gt;</span></span><br><span class="line">                <span class="hljs-comment">&lt;!-- 将main_column_class() 改为 col() --&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column &lt;%= col() %&gt; has-order-2 column-main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">body</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">left</span>' &#125;) %&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">right</span>' &#125;) %&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。<br>通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。</p><p>为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。<br>将代码全选复制，再粘贴于末尾，做如下修改3处代码：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-keyword">if</span> (get_widgets(position).length &amp;&amp; !is_post()) &#123; %&gt;        <span class="hljs-xml"><span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-1' : 'has-order-3';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!-- 粘贴的部分 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">position</span> === <span class="hljs-string">'left'</span> &amp;&amp; <span class="hljs-attr">is_post</span>()) &#123; %&gt;</span>                          <span class="hljs-comment">&lt;!-- 修改，可选保留的栏 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-3' : 'has-order-1';       <span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure></p><hr><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>我这里保存的是左边栏，若要保存右边栏可以在 widget.ejs 文件中更改（已标识）。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>见本站！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么修改？&quot;&gt;&lt;a href=&quot;#为什么修改？&quot; class=&quot;headerlink&quot; title=&quot;为什么修改？&quot;&gt;&lt;/a&gt;为什么修改？&lt;/h2&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo用MathJax渲染数学公式</title>
    <link href="https://www.ccyh.xyz/2019/04/30/Hexo%E7%94%A8MathJax%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.ccyh.xyz/2019/04/30/Hexo用MathJax渲染数学公式/</id>
    <published>2019-04-30T17:24:31.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更改默认Markdown渲染引擎"><a href="#更改默认Markdown渲染引擎" class="headerlink" title="更改默认Markdown渲染引擎"></a>更改默认Markdown渲染引擎</h2><a id="more"></a><p>Hexo的默认Markdown渲染引擎为hexo-renderer-marked，将其替换为hexo-renderer-kramed,对于这一步，网上的大部分教程是这么干的：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><p>也就是先卸载掉默认引擎，再安装新引擎。但是我的npm出了问题，而且我个人觉得npm实在是不好用，因此我下载了yarn，并执行：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-renderer-marked</span><br><span class="line">yarn add hexo-renderer-kramed</span><br></pre></td></tr></table></figure></p><p>但当我执行hexo clean时却出现了类似下面的错误：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">Error: hexo-renderer-marked is not installed , please install ....</span><br></pre></td></tr></table></figure></p><p>所以一直无法成功。<br>后来我想干脆不卸载marked渲染引擎，直接安装kramed：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-kramed</span><br></pre></td></tr></table></figure></p><hr><h2 id="安装MathJax"><a href="#安装MathJax" class="headerlink" title="安装MathJax"></a>安装MathJax</h2><p>卸载hexo-math：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-math</span><br></pre></td></tr></table></figure></p><p>再安装hexo-renderer-mathjax：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-mathjax -S</span><br></pre></td></tr></table></figure></p><hr><h2 id="解决行内公式语义冲突"><a href="#解决行内公式语义冲突" class="headerlink" title="解决行内公式语义冲突"></a>解决行内公式语义冲突</h2><p>在博客的根目录下找到$\color{red}{node_modules/kramed/lib/rules/inline.js}$<br>做如下两处更改：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inline = &#123;</span><br><span class="line">  <span class="hljs-comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,   第一处</span></span><br><span class="line">  <span class="hljs-built_in">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">  autolink: <span class="hljs-regexp">/^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/</span>,</span><br><span class="line">  url: noop,</span><br><span class="line">  html: <span class="hljs-regexp">/^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/</span>,</span><br><span class="line">  link: <span class="hljs-regexp">/^!?\[(inside)\]\(href\)/</span>,</span><br><span class="line">  reflink: <span class="hljs-regexp">/^!?\[(inside)\]\s*\[([^\]]*)\]/</span>,</span><br><span class="line">  nolink: <span class="hljs-regexp">/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/</span>,</span><br><span class="line">  reffn: <span class="hljs-regexp">/^!?\[\^(inside)\]/</span>,</span><br><span class="line">  strong: <span class="hljs-regexp">/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</span><br><span class="line">  <span class="hljs-comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,  第二处</span></span><br><span class="line">  em: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  code: <span class="hljs-regexp">/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/</span>,</span><br><span class="line">  br: <span class="hljs-regexp">/^ &#123;2,&#125;\n(?!\s*$)/</span>,</span><br><span class="line">  del: noop,</span><br><span class="line">  text: <span class="hljs-regexp">/^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/</span>,</span><br><span class="line">  math: <span class="hljs-regexp">/^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="更改Mathjax加载脚本"><a href="#更改Mathjax加载脚本" class="headerlink" title="更改Mathjax加载脚本"></a>更改Mathjax加载脚本</h2><p>找到$\color{red}{node-modules/hexo-renderer-mathjax/mathjax.html}$将最后一句改为：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>将改动部署到博客</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更改默认Markdown渲染引擎&quot;&gt;&lt;a href=&quot;#更改默认Markdown渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;更改默认Markdown渲染引擎&quot;&gt;&lt;/a&gt;更改默认Markdown渲染引擎&lt;/h2&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+icarus主题配置</title>
    <link href="https://www.ccyh.xyz/2019/04/29/Hexo+icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.ccyh.xyz/2019/04/29/Hexo+icarus主题配置/</id>
    <published>2019-04-29T17:31:10.000Z</published>
    <updated>2020-01-23T07:50:10.291Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="下载icarus主题"><a href="#下载icarus主题" class="headerlink" title="下载icarus主题"></a>下载icarus主题</h2><ol><li>进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面<a id="more"></a></li><li><p>输入：</p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/ppoffice/hexo-theme-icarus themes/icarus</span><br></pre></td></tr></table></figure></li><li><p>打开themes文件夹，就会发现多了一个icarus文件夹，这就是主题的所有文件</p></li></ol><hr><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><ol><li><p>更改站点配置文件_config.yml,将主题改为icarus</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">theme:</span> <span class="hljs-string">icarus</span></span><br></pre></td></tr></table></figure></li><li><p>Icarus文件目录概览：<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429082811950.png" alt=""></p><blockquote><ul><li>$config.yml$是主题的配置文件</li><li>$/layout$ 文件夹中是主题各种模板文件</li><li>我们主要的超作就是在这两个文件中了</li></ul></blockquote></li></ol><hr><h3 id="主题配置文件（部分）"><a href="#主题配置文件（部分）" class="headerlink" title="主题配置文件（部分）"></a>主题配置文件（部分）</h3><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># Version of the Icarus theme that is currently used</span></span><br><span class="line"><span class="hljs-attr">version:</span> <span class="hljs-number">2.3</span><span class="hljs-number">.0</span></span><br><span class="line"><span class="hljs-comment"># 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中</span></span><br><span class="line"><span class="hljs-attr">favicon:</span> <span class="hljs-string">/images/favicons.ico</span></span><br><span class="line"><span class="hljs-comment"># Path or URL to RSS atom.xml</span></span><br><span class="line"><span class="hljs-attr">rss:</span> <span class="hljs-string">/atom.xml</span></span><br><span class="line"><span class="hljs-comment"># 显示在导航栏左侧的网站logo，同样可以自己制作</span></span><br><span class="line"><span class="hljs-attr">logo:</span> <span class="hljs-string">/images/gen.svg</span></span><br><span class="line"><span class="hljs-comment"># Open Graph metadata</span></span><br><span class="line"><span class="hljs-comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line"><span class="hljs-attr">open_graph:</span></span><br><span class="line">    <span class="hljs-comment"># Facebook App ID</span></span><br><span class="line"><span class="hljs-attr">    fb_app_id:</span> </span><br><span class="line">    <span class="hljs-comment"># Facebook Admin ID</span></span><br><span class="line"><span class="hljs-attr">    fb_admins:</span> </span><br><span class="line">    <span class="hljs-comment"># Twitter ID</span></span><br><span class="line"><span class="hljs-attr">    twitter_id:</span> </span><br><span class="line">    <span class="hljs-comment"># Twitter site</span></span><br><span class="line"><span class="hljs-attr">    twitter_site:</span> </span><br><span class="line">    <span class="hljs-comment"># Google+ profile link</span></span><br><span class="line"><span class="hljs-attr">    google_plus:</span> </span><br><span class="line"><span class="hljs-comment">#  导航栏</span></span><br><span class="line"><span class="hljs-attr">navbar:</span></span><br><span class="line">    <span class="hljs-comment">#菜单（显示名称：对应文件夹）</span></span><br><span class="line"><span class="hljs-attr">    menu:</span></span><br><span class="line">        <span class="hljs-string">主页:</span> <span class="hljs-string">/</span></span><br><span class="line">        <span class="hljs-string">归档:</span> <span class="hljs-string">/archives</span></span><br><span class="line">        <span class="hljs-string">分类:</span> <span class="hljs-string">/categories</span></span><br><span class="line">        <span class="hljs-string">标签:</span> <span class="hljs-string">/tags</span></span><br><span class="line">        <span class="hljs-string">关于:</span> <span class="hljs-string">/about</span>   </span><br><span class="line">    <span class="hljs-comment"># 导航栏右侧图标链接</span></span><br><span class="line"><span class="hljs-attr">    links:</span></span><br><span class="line">        <span class="hljs-string">My</span> <span class="hljs-attr">GitHub:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'你的gityhub地址'</span></span><br><span class="line"><span class="hljs-comment"># Footer section link settings</span></span><br><span class="line"><span class="hljs-attr">footer:</span></span><br><span class="line">    <span class="hljs-comment"># 页脚图标链接</span></span><br><span class="line"><span class="hljs-attr">    links:</span></span><br><span class="line">        <span class="hljs-string">Creative</span> <span class="hljs-attr">Commons:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'https://creativecommons.org/'</span></span><br><span class="line">        <span class="hljs-string">Attribution</span> <span class="hljs-number">4.0</span> <span class="hljs-attr">International:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons-by</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'https://creativecommons.org/licenses/by/4.0/'</span></span><br><span class="line">        <span class="hljs-string">Download</span> <span class="hljs-string">on</span> <span class="hljs-attr">GitHub:</span></span><br><span class="line"><span class="hljs-attr">            icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">            url:</span> <span class="hljs-string">'http://github.com/ppoffice/hexo-theme-icarus'</span></span><br><span class="line"><span class="hljs-comment"># 文章显示设置</span></span><br><span class="line"><span class="hljs-attr">article:</span></span><br><span class="line">    <span class="hljs-comment"># Code highlight theme</span></span><br><span class="line">    <span class="hljs-comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span></span><br><span class="line">    <span class="hljs-comment">#代码主题atom-one-light亮色，atom-one-dark暗色</span></span><br><span class="line"><span class="hljs-attr">    highlight:</span> <span class="hljs-string">atom-one-dark</span></span><br><span class="line">    <span class="hljs-comment"># 是否显示文章主图</span></span><br><span class="line"><span class="hljs-attr">    thumbnail:</span> <span class="hljs-literal">true</span></span><br><span class="line">    <span class="hljs-comment"># 是否显示估算阅读时间</span></span><br><span class="line"><span class="hljs-attr">    readtime:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 搜索插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Plugins</span></span><br><span class="line"><span class="hljs-attr">search:</span></span><br><span class="line">    <span class="hljs-comment"># Name of the search plugin</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">insight</span></span><br><span class="line"><span class="hljs-comment"># 评论插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Plugins</span></span><br><span class="line"><span class="hljs-attr">comment:</span></span><br><span class="line">    <span class="hljs-comment">#可选valine，disqus（科学上网）等</span></span><br><span class="line">    <span class="hljs-comment"># Name of the comment plugin</span></span><br><span class="line">    <span class="hljs-comment">#type: valine</span></span><br><span class="line">    <span class="hljs-comment">#app_id: 不为空</span></span><br><span class="line">    <span class="hljs-comment">#app_key: 不为空</span></span><br><span class="line">    <span class="hljs-comment">#notify: true</span></span><br><span class="line">    <span class="hljs-comment">#verify: true</span></span><br><span class="line">    <span class="hljs-comment">#placeholder:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">disqus</span></span><br><span class="line"><span class="hljs-attr">    shortname:</span> <span class="hljs-string">不能为空</span></span><br><span class="line"><span class="hljs-comment"># 打赏功能</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/</span></span><br><span class="line"><span class="hljs-attr">donate:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 阿里巴巴支付宝</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">alipay</span></span><br><span class="line">        <span class="hljs-comment"># 二维码图片</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">'/images/honbao.PNG'</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 微信</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">wechat</span></span><br><span class="line">        <span class="hljs-comment"># 二维码图片</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">'/images/yjtp.png'</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line"><span class="hljs-comment"># 分享插件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Plugins</span></span><br><span class="line"><span class="hljs-attr">share:</span></span><br><span class="line">    <span class="hljs-comment"># 插件类型，有多种，可选，自行百度</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">sharejs</span></span><br><span class="line"><span class="hljs-comment"># Sidebar settings.</span></span><br><span class="line"><span class="hljs-comment"># Please be noted that a sidebar is only visible when it has at least one widget</span></span><br><span class="line"><span class="hljs-attr">sidebar:</span></span><br><span class="line">    <span class="hljs-comment"># 左侧边栏设置</span></span><br><span class="line"><span class="hljs-attr">    left:</span></span><br><span class="line">        <span class="hljs-comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line"><span class="hljs-attr">        sticky:</span> <span class="hljs-literal">false</span></span><br><span class="line">    <span class="hljs-comment"># 右侧边栏设置</span></span><br><span class="line"><span class="hljs-attr">    right:</span></span><br><span class="line">        <span class="hljs-comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line"><span class="hljs-attr">        sticky:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 边栏小部件设置</span></span><br><span class="line"><span class="hljs-comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/</span></span><br><span class="line"><span class="hljs-attr">widgets:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 个人信息</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">profile</span></span><br><span class="line">        <span class="hljs-comment"># 部件位置（左）</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line">        <span class="hljs-comment"># 作者名（字符串）</span></span><br><span class="line"><span class="hljs-attr">        author:</span> <span class="hljs-string">飞鱼</span></span><br><span class="line">        <span class="hljs-comment"># 作者身份描述（字符串）</span></span><br><span class="line"><span class="hljs-attr">        author_title:</span> <span class="hljs-string">Student</span></span><br><span class="line">        <span class="hljs-comment"># 作者当前居住地</span></span><br><span class="line"><span class="hljs-attr">        location:</span> <span class="hljs-string">China,Fujian</span></span><br><span class="line">        <span class="hljs-comment"># 头像（可用本地图片或网络图片链接）</span></span><br><span class="line"><span class="hljs-attr">        avatar:</span> <span class="hljs-string">'/images/ava.png'</span></span><br><span class="line">        <span class="hljs-comment"># Email address for the Gravatar to be shown in the profile widget</span></span><br><span class="line"><span class="hljs-attr">        gravatar:</span> </span><br><span class="line">        <span class="hljs-comment"># 关注我的链接，可设为你的GitHub主页</span></span><br><span class="line"><span class="hljs-attr">        follow_link:</span> <span class="hljs-string">'https://github.com/yourname'</span></span><br><span class="line">        <span class="hljs-comment"># 个人介绍部件底部图标社交链接</span></span><br><span class="line"><span class="hljs-attr">        social_links:</span></span><br><span class="line"><span class="hljs-attr">            Github:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://github.com/yourname'</span></span><br><span class="line"><span class="hljs-attr">            Facebook:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-facebook</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://facebook.com'</span></span><br><span class="line"><span class="hljs-attr">            Twitter:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-twitter</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">'https://twitter.com/yourname'</span></span><br><span class="line"><span class="hljs-attr">            RSS:</span></span><br><span class="line"><span class="hljs-attr">                icon:</span> <span class="hljs-string">fas</span> <span class="hljs-string">fa-rss</span></span><br><span class="line"><span class="hljs-attr">                url:</span> <span class="hljs-string">/</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># Widget name</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">toc</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 分类</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">category</span></span><br><span class="line">        <span class="hljs-comment"># 位置指定</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 标签云</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">tagcloud</span></span><br><span class="line">        <span class="hljs-comment"># 位置</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 近期文章</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">recent_posts</span></span><br><span class="line">        <span class="hljs-comment"># 位置</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 归档</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">archive</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 标签</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">tag</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">right</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># 外部链接</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">links</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br><span class="line">        <span class="hljs-comment"># Links to be shown in the links widget</span></span><br><span class="line"><span class="hljs-attr">        links:</span></span><br><span class="line"><span class="hljs-attr">            Google:</span> <span class="hljs-string">'https://google.com'</span></span><br><span class="line"><span class="hljs-attr">            Baidu:</span> <span class="hljs-string">'https://baidu.com'</span></span><br></pre></td></tr></table></figure><p>上述设置已经让你的博客稍微有点属于你的样子了，下面来添加一些有意思的元素。</p><hr><h3 id="添加雪花飘落效果"><a href="#添加雪花飘落效果" class="headerlink" title="添加雪花飘落效果"></a>添加雪花飘落效果</h3><ul><li>在 $\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$目录下新建一个 snow.js 文件(若没有src/文件夹可以自己新建)，复制粘贴以下代码：<br><strong> 样式1：六边形雪花 </strong><figure class="highlight javascript hljs"><table><tr><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>)</span>&#123;</span><br><span class="line">$.fn.snow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> $flake = $(<span class="hljs-string">''</span>).css(&#123;<span class="hljs-string">'position'</span>: <span class="hljs-string">'absolute'</span>,<span class="hljs-string">'z-index'</span>:<span class="hljs-string">'9999'</span>, <span class="hljs-string">'top'</span>: <span class="hljs-string">'-50px'</span>&#125;).html(<span class="hljs-string">'❄'</span>),</span><br><span class="line">documentHeight = $(<span class="hljs-built_in">document</span>).height(),</span><br><span class="line">documentWidth= $(<span class="hljs-built_in">document</span>).width(),</span><br><span class="line">defaults = &#123;</span><br><span class="line">minSize: <span class="hljs-number">10</span>,</span><br><span class="line">maxSize: <span class="hljs-number">20</span>,</span><br><span class="line">newOn: <span class="hljs-number">1000</span>,</span><br><span class="line">flakeColor: <span class="hljs-string">"#AFDAEF"</span> <span class="hljs-comment">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span></span><br><span class="line">&#125;,</span><br><span class="line">options= $.extend(&#123;&#125;, defaults, options);</span><br><span class="line"><span class="hljs-keyword">var</span> interval= setInterval( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> startPositionLeft = <span class="hljs-built_in">Math</span>.random() * documentWidth - <span class="hljs-number">100</span>,</span><br><span class="line">startOpacity = <span class="hljs-number">0.5</span> + <span class="hljs-built_in">Math</span>.random(),</span><br><span class="line">sizeFlake = options.minSize + <span class="hljs-built_in">Math</span>.random() * options.maxSize,</span><br><span class="line">endPositionTop = documentHeight - <span class="hljs-number">200</span>,</span><br><span class="line">endPositionLeft = startPositionLeft - <span class="hljs-number">500</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">500</span>,</span><br><span class="line">durationFall = documentHeight * <span class="hljs-number">10</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5000</span>;</span><br><span class="line">$flake.clone().appendTo(<span class="hljs-string">'body'</span>).css(&#123;</span><br><span class="line">left: startPositionLeft,</span><br><span class="line">opacity: startOpacity,</span><br><span class="line"><span class="hljs-string">'font-size'</span>: sizeFlake,</span><br><span class="line">color: options.flakeColor</span><br><span class="line">&#125;).animate(&#123;</span><br><span class="line">top: endPositionTop,</span><br><span class="line">left: endPositionLeft,</span><br><span class="line">opacity: <span class="hljs-number">0.2</span></span><br><span class="line">&#125;,durationFall,<span class="hljs-string">'linear'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">$(<span class="hljs-keyword">this</span>).remove()</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, options.newOn);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    $.fn.snow(&#123; </span><br><span class="line">    minSize: <span class="hljs-number">5</span>, <span class="hljs-comment">/* 定义雪花最小尺寸 */</span></span><br><span class="line">    maxSize: <span class="hljs-number">50</span>,<span class="hljs-comment">/* 定义雪花最大尺寸 */</span></span><br><span class="line">    newOn: <span class="hljs-number">300</span>  <span class="hljs-comment">/* 定义密集程度，数字越小越密集 */</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">作者：donlex</span><br><span class="line">链接：http:<span class="hljs-comment">//www.imooc.com/article/272005</span></span><br></pre></td></tr></table></figure></li></ul><p><strong> 样式2：圆点状雪花 </strong><br><figure class="highlight javascript hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snowFall</span>(<span class="hljs-params">snow</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 可配置属性 */</span></span><br><span class="line">    snow = snow || &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.maxFlake = snow.maxFlake || <span class="hljs-number">200</span>;   <span class="hljs-comment">/* 最多片数 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.flakeSize = snow.flakeSize || <span class="hljs-number">10</span>;  <span class="hljs-comment">/* 雪花形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.fallSpeed = snow.fallSpeed || <span class="hljs-number">1</span>;   <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 兼容写法 */</span></span><br><span class="line">requestAnimationFrame = <span class="hljs-built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>&#123; setTimeout(callback, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>); &#125;;</span><br><span class="line"></span><br><span class="line">cancelAnimationFrame = <span class="hljs-built_in">window</span>.cancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.mozCancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.webkitCancelAnimationFrame ||</span><br><span class="line">    <span class="hljs-built_in">window</span>.msCancelAnimationFrame ||</span><br><span class="line"><span class="hljs-built_in">window</span>.oCancelAnimationFrame;</span><br><span class="line"><span class="hljs-comment">/* 开始下雪 */</span></span><br><span class="line">snowFall.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 创建画布 */</span></span><br><span class="line">    snowCanvas.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-comment">/* 创建雪花形状 */</span></span><br><span class="line">    createFlakes.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-comment">/* 画雪 */</span></span><br><span class="line">    drawSnow.apply(<span class="hljs-keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 创建画布 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snowCanvas</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* 添加Dom结点 */</span></span><br><span class="line">    <span class="hljs-keyword">var</span> snowcanvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"canvas"</span>);</span><br><span class="line">    snowcanvas.id = <span class="hljs-string">"snowfall"</span>;</span><br><span class="line">    snowcanvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><br><span class="line">    snowcanvas.height = <span class="hljs-built_in">document</span>.body.clientHeight;</span><br><span class="line">    snowcanvas.setAttribute(<span class="hljs-string">"style"</span>, <span class="hljs-string">"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"</span>);</span><br><span class="line">    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>)[<span class="hljs-number">0</span>].appendChild(snowcanvas);</span><br><span class="line">    <span class="hljs-keyword">this</span>.canvas = snowcanvas;</span><br><span class="line">    <span class="hljs-keyword">this</span>.ctx = snowcanvas.getContext(<span class="hljs-string">"2d"</span>);</span><br><span class="line">    <span class="hljs-comment">/* 窗口大小改变的处理 */</span></span><br><span class="line">    <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        snowcanvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><br><span class="line">        <span class="hljs-comment">/* snowcanvas.height = window.innerHeight */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 雪运动对象 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakeMove</span>(<span class="hljs-params">canvasWidth, canvasHeight, flakeSize, fallSpeed</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * canvasWidth);   <span class="hljs-comment">/* x坐标 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.y = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * canvasHeight);  <span class="hljs-comment">/* y坐标 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-built_in">Math</span>.random() * flakeSize + <span class="hljs-number">2</span>;          <span class="hljs-comment">/* 形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.maxSize = flakeSize;                           <span class="hljs-comment">/* 最大形状 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.speed = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span> + fallSpeed;         <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.fallSpeed = fallSpeed;                         <span class="hljs-comment">/* 坠落速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed;                             <span class="hljs-comment">/* Y方向速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velX = <span class="hljs-number">0</span>;                                      <span class="hljs-comment">/* X方向速度 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.stepSize = <span class="hljs-built_in">Math</span>.random() / <span class="hljs-number">30</span>;                 <span class="hljs-comment">/* 步长 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.step = <span class="hljs-number">0</span>                                       <span class="hljs-comment">/* 步数 */</span></span><br><span class="line">&#125;</span><br><span class="line">flakeMove.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>.x,</span><br><span class="line">        y = <span class="hljs-keyword">this</span>.y;</span><br><span class="line">    <span class="hljs-comment">/* 左右摆动(余弦) */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.velX *= <span class="hljs-number">0.98</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.velY &lt;= <span class="hljs-keyword">this</span>.speed) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velX += <span class="hljs-built_in">Math</span>.cos(<span class="hljs-keyword">this</span>.step += <span class="hljs-number">.05</span>) * <span class="hljs-keyword">this</span>.stepSize;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">this</span>.y += <span class="hljs-keyword">this</span>.velY;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x += <span class="hljs-keyword">this</span>.velX;</span><br><span class="line">    <span class="hljs-comment">/* 飞出边界的处理 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.x &gt;= canvas.width || <span class="hljs-keyword">this</span>.x &lt;= <span class="hljs-number">0</span> || <span class="hljs-keyword">this</span>.y &gt;= canvas.height || <span class="hljs-keyword">this</span>.y &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.reset(canvas.width, canvas.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">/* 飞出边界-放置最顶端继续坠落 */</span></span><br><span class="line">flakeMove.prototype.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.x = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * width);</span><br><span class="line">    <span class="hljs-keyword">this</span>.y = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.maxSize + <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.speed = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span> + <span class="hljs-keyword">this</span>.fallSpeed;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velY = <span class="hljs-keyword">this</span>.speed;</span><br><span class="line">    <span class="hljs-keyword">this</span>.velX = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 渲染雪花-随机形状（此处可修改雪花颜色！！！）</span></span><br><span class="line">flakeMove.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> snowFlake = ctx.createRadialGradient(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-keyword">this</span>.size);</span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">"rgba(255, 255, 255, 0.9)"</span>);  <span class="hljs-comment">/* 此处是雪花颜色，默认是白色 */</span></span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">.5</span>, <span class="hljs-string">"rgba(255, 255, 255, 0.5)"</span>); <span class="hljs-comment">/* 若要改为其他颜色，请自行查 */</span></span><br><span class="line">    snowFlake.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">"rgba(255, 255, 255, 0)"</span>);    <span class="hljs-comment">/* 找16进制的RGB 颜色代码。 */</span></span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.fillStyle = snowFlake;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y, <span class="hljs-keyword">this</span>.size, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    ctx.restore();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">/* 创建雪花-定义形状 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFlakes</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> maxFlake = <span class="hljs-keyword">this</span>.maxFlake,</span><br><span class="line">        flakes = <span class="hljs-keyword">this</span>.flakes = [],</span><br><span class="line">        canvas = <span class="hljs-keyword">this</span>.canvas;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; maxFlake; i++) &#123;</span><br><span class="line">        flakes.push(<span class="hljs-keyword">new</span> flakeMove(canvas.width, canvas.height, <span class="hljs-keyword">this</span>.flakeSize, <span class="hljs-keyword">this</span>.fallSpeed))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 画雪 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawSnow</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> maxFlake = <span class="hljs-keyword">this</span>.maxFlake,</span><br><span class="line">        flakes = <span class="hljs-keyword">this</span>.flakes;</span><br><span class="line">    ctx = <span class="hljs-keyword">this</span>.ctx, canvas = <span class="hljs-keyword">this</span>.canvas, that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-comment">/* 清空雪花 */</span></span><br><span class="line">    ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>; e &lt; maxFlake; e++) &#123;</span><br><span class="line">        flakes[e].update();</span><br><span class="line">        flakes[e].render(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/*  一帧一帧的画 */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.loop = requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        drawSnow.apply(that);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 调用及控制方法 */</span></span><br><span class="line"><span class="hljs-keyword">var</span> snow = <span class="hljs-keyword">new</span> snowFall(&#123;<span class="hljs-attr">maxFlake</span>:<span class="hljs-number">60</span>&#125;);</span><br><span class="line">snow.start();</span><br><span class="line"></span><br><span class="line">作者：donlex</span><br><span class="line">链接：http:<span class="hljs-comment">//www.imooc.com/article/272005</span></span><br></pre></td></tr></table></figure></p><ul><li><p>最后在$\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$的$body$标签中添加代码：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- 雪花特效 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">var</span> windowWidth = $(<span class="hljs-built_in">window</span>).width();</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">if</span> (windowWidth &gt; <span class="hljs-number">480</span>) &#123;</span></span><br><span class="line"><span class="hljs-xml">        document.write('<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/src/snow.js"</span>&gt;</span><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">\</span>/<span class="hljs-attr">script</span>&gt;</span>');</span></span></span><br><span class="line"><span class="hljs-undefined">      &#125;</span></span><br><span class="line"><span class="hljs-undefined">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认雪花为白色，可自行更改颜色，效果可见本站</p></li></ul><hr><h3 id="网站访问量与访客量统计"><a href="#网站访问量与访客量统计" class="headerlink" title="网站访问量与访客量统计"></a>网站访问量与访客量统计</h3><ul><li>不蒜子官网：<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">http://busuanzi.ibruce.info/</a></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$模板文件的中添加如下代码：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_pv"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"theme-info"</span>&gt;</span></span><br><span class="line">  |  本站总访问量<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_pv"</span>&gt;</span>span&gt;次</span><br><span class="line"> span&gt;</span><br><span class="line"> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_uv"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"theme-info"</span>&gt;</span></span><br><span class="line">  |  本站访客数<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_uv"</span>&gt;</span>span&gt;人次</span><br><span class="line"> span&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="hljs-undefined">script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/_config.yml}$中添加：</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">busuanzi:</span></span><br><span class="line"><span class="hljs-attr">    enable:</span> <span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>最终效果：<br><div align="center"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429093801600.png" alt=""><br></div></p><h3 id="网站运行时间统计"><a href="#网站运行时间统计" class="headerlink" title="网站运行时间统计"></a>网站运行时间统计</h3></li><li><p>在$\color{DarkTurquoise}{/themes/icarus/layout/common/footer.ejs}$中添加：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"timeDate"</span>&gt;</span>载入天数...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"times"</span>&gt;</span>载入时分秒...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">                <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); </span></span><br><span class="line"><span class="hljs-javascript">                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createtime</span>(<span class="hljs-params"></span>) </span>&#123; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-keyword">var</span> grt= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"12/28/2018 12:49:00"</span>);<span class="hljs-comment">//此处修改你的建站时间或者网站上线时间 </span></span></span><br><span class="line"><span class="hljs-undefined">                    now.setTime(now.getTime()+250); </span></span><br><span class="line"><span class="hljs-javascript">                    days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = <span class="hljs-built_in">Math</span>.floor(days); </span></span><br><span class="line"><span class="hljs-javascript">                    hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = <span class="hljs-built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(hnum).length ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum); </span></span><br><span class="line"><span class="hljs-javascript">                    mnum = <span class="hljs-built_in">Math</span>.floor(minutes); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(mnum).length ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">"0"</span> + mnum;&#125; </span></span><br><span class="line"><span class="hljs-undefined">                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span></span><br><span class="line"><span class="hljs-javascript">                    snum = <span class="hljs-built_in">Math</span>.round(seconds); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(snum).length ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">"0"</span> + snum;&#125; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"timeDate"</span>).innerHTML = <span class="hljs-string">"本站已安全运行 "</span>+dnum+<span class="hljs-string">" 天 "</span>; </span></span><br><span class="line"><span class="hljs-javascript">                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"times"</span>).innerHTML = hnum + <span class="hljs-string">" 小时 "</span> + mnum + <span class="hljs-string">" 分 "</span> + snum + <span class="hljs-string">" 秒"</span>; </span></span><br><span class="line"><span class="hljs-undefined">                &#125; </span></span><br><span class="line"><span class="hljs-javascript">            setInterval(<span class="hljs-string">"createtime()"</span>,<span class="hljs-number">250</span>);</span></span><br><span class="line"><span class="hljs-undefined">            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改自己的建站时间</p></li><li>最终效果：<div align="center"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Hexo+icarus主题配置/20190429094726470.png" alt=""><br></div></li></ul><hr><h3 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h3><ul><li><p>在 $\color{DarkTurquoise}{/themes/icarus/sourse/js/src}$中添加click.js文件，复制以下代码进去：</p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        c(<span class="hljs-string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),</span><br><span class="line">        o(),</span><br><span class="line">        r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;d.length;e++)</span><br><span class="line">            d[e].alpha&lt;=<span class="hljs-number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="hljs-number">1</span>)):(d[e].y--,d[e].scale+=<span class="hljs-number">.004</span>,d[e].alpha-=<span class="hljs-number">.013</span>,d[e].el.style.cssText=<span class="hljs-string">"left:"</span>+d[e].x+<span class="hljs-string">"px;top:"</span>+d[e].y+<span class="hljs-string">"px;opacity:"</span>+d[e].alpha+<span class="hljs-string">";transform:scale("</span>+d[e].scale+<span class="hljs-string">","</span>+d[e].scale+<span class="hljs-string">") rotate(45deg);background:"</span>+d[e].color+<span class="hljs-string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> t=<span class="hljs-string">"function"</span>==<span class="hljs-keyword">typeof</span> e.onclick&amp;&amp;e.onclick;</span><br><span class="line">        e.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            t&amp;&amp;t(),i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">"div"</span>);</span><br><span class="line">            a.className=<span class="hljs-string">"heart"</span>,d.push(&#123;<span class="hljs-attr">el</span>:a,<span class="hljs-attr">x</span>:e.clientX<span class="hljs-number">-5</span>,<span class="hljs-attr">y</span>:e.clientY<span class="hljs-number">-5</span>,<span class="hljs-attr">scale</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">color</span>:s()&#125;),t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">"style"</span>);a.type=<span class="hljs-string">"text/css"</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">catch</span>(t)&#123;</span><br><span class="line">            a.styleSheet.cssText=e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span><span class="hljs-string">"rgb("</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">","</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">","</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> d=[];</span><br><span class="line">    e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">            setTimeout(e,<span class="hljs-number">1e3</span>/<span class="hljs-number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(),</span><br><span class="line">    n()</span><br><span class="line">&#125;</span><br><span class="line">(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>);</span><br></pre></td></tr></table></figure></li><li><p>最后在$\color{DarkTurquoise}{/themes/icarus/layout/layout.ejs}$文件中的</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>的下一行添加：</p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/src/click.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>效果见本站</p></li></ul><hr><h3 id="看板娘插件"><a href="#看板娘插件" class="headerlink" title="看板娘插件"></a>看板娘插件</h3><ul><li>在博客主目录下进入点击进入<strong>Git Bash Here</strong></li><li><p>输入命令：</p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure></li><li><p>在网站配置文件或主题配置文件$\color{green}{_config.yml}$中添加：</p><figure class="highlight yml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">live2d:</span></span><br><span class="line"><span class="hljs-attr">  enable:</span> <span class="hljs-literal">true</span>                                   <span class="hljs-comment">#开启看板娘</span></span><br><span class="line"><span class="hljs-attr">  scriptFrom:</span> <span class="hljs-string">local</span></span><br><span class="line"><span class="hljs-attr">  pluginRootPath:</span> <span class="hljs-string">live2dw/</span></span><br><span class="line"><span class="hljs-attr">  pluginJsPath:</span> <span class="hljs-string">lib/</span></span><br><span class="line"><span class="hljs-attr">  pluginModelPath:</span> <span class="hljs-string">assets/</span></span><br><span class="line"><span class="hljs-attr">  tagMode:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-attr">  log:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-attr">  model:</span></span><br><span class="line"><span class="hljs-attr">    use:</span> <span class="hljs-string">live2d-widget-model-z16</span>     <span class="hljs-comment">#指定模型任务</span></span><br><span class="line"><span class="hljs-attr">  display:</span></span><br><span class="line"><span class="hljs-attr">    position:</span> <span class="hljs-string">right</span>                              <span class="hljs-comment">#显示位置</span></span><br><span class="line"><span class="hljs-attr">    width:</span> <span class="hljs-number">200</span>                                   <span class="hljs-comment">#模型宽度</span></span><br><span class="line"><span class="hljs-attr">    height:</span> <span class="hljs-number">400</span>                                  <span class="hljs-comment">#模型高度</span></span><br><span class="line"><span class="hljs-attr">  mobile:</span></span><br><span class="line"><span class="hljs-attr">    show:</span> <span class="hljs-literal">true</span>                                  <span class="hljs-comment">#是否在移动端显示</span></span><br></pre></td></tr></table></figure></li><li><p>效果：见本站</p></li></ul><hr><h3 id="遇到的坑及解决方法"><a href="#遇到的坑及解决方法" class="headerlink" title="遇到的坑及解决方法"></a>遇到的坑及解决方法</h3><ul><li>..公式渲染问题</li><li>..</li><li>..<div align="center"><br>$\color{green}{Waiting….for….update….}$<br></div></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;下载icarus主题&quot;&gt;&lt;a href=&quot;#下载icarus主题&quot; class=&quot;headerlink&quot; title=&quot;下载icarus主题&quot;&gt;&lt;/a&gt;下载icarus主题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进入博客主目录，点击鼠标右键Git Bash Here,进入命令行界面&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【算法】DP最大和问题</title>
    <link href="https://www.ccyh.xyz/2019/03/17/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://www.ccyh.xyz/2019/03/17/【算法】DP最大和问题/</id>
    <published>2019-03-17T19:55:27.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><hr><a id="more"></a><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><blockquote><p>给定一个整数数字序列（用数组表示），在这个数列中选择若干个互不相邻的数，使得这些数的和达到最大值。</p></blockquote><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><blockquote><p>属于01背包问题同类问题，对于每一个数，都有两种选择（选或不选）。假设给定数组set[]的长度为n，最终要求OPT(n-1)的结果,也就是从下标0到下标n-1这些数中能组成的最大和，而要求OPT(n-1)就分为两种情况：<br>1.选择set[n-1],因为不能出现相邻选项故OPT[n-1]的结果为set[n-1]与OPT[n-3]的和。<br>2.不选择set[n-1],则OPT[n-1]的结果就与OPT[n-2]相等。<br>判断出口：<br>不难看出，OPT[0] = set[0]，OPT[1] = max(set[0],set[1]);</p></blockquote><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317082529638.png" alt=""></p><h4 id="因此其状态转移方程为："><a href="#因此其状态转移方程为：" class="headerlink" title="因此其状态转移方程为："></a>因此其状态转移方程为：</h4><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317083401575.png" alt=""></p><hr><h4 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h4><p><em>递归实现：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">OPT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>];</span><br><span class="line"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>] ? <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]:<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> a = OPT(i<span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> b = OPT(i<span class="hljs-number">-2</span>)+<span class="hljs-built_in">set</span>[i];</span><br><span class="line"><span class="hljs-keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>DP实现：</em><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">OPT_</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">set</span>[],<span class="hljs-keyword">int</span> m)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> *opt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//状态数组</span></span><br><span class="line">    <span class="hljs-comment">//出口</span></span><br><span class="line">opt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>];</span><br><span class="line">opt[<span class="hljs-number">1</span>] = <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>] ? <span class="hljs-built_in">set</span>[<span class="hljs-number">0</span>]:<span class="hljs-built_in">set</span>[<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a = opt[i<span class="hljs-number">-1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> b = opt[i<span class="hljs-number">-2</span>] + <span class="hljs-built_in">set</span>[i];</span><br><span class="line">opt[i] = a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> opt[m<span class="hljs-number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>测试：</em></p><blockquote><p>输入：{1,5,8,9,7,8,2,1,6,3}<br>输出：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/20190317084336292.png" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Knapsack" scheme="https://www.ccyh.xyz/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>【算法】背包问题的DFS与DP解法</title>
    <link href="https://www.ccyh.xyz/2019/03/14/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84DFS%E4%B8%8EDP%E8%A7%A3%E6%B3%95/"/>
    <id>https://www.ccyh.xyz/2019/03/14/【算法】背包问题的DFS与DP解法/</id>
    <published>2019-03-14T20:03:54.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kanapsack-Problem"><a href="#Kanapsack-Problem" class="headerlink" title="Kanapsack Problem"></a>Kanapsack Problem</h3><hr><a id="more"></a><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><blockquote><p>有n件物品，每件物品重w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品总重量不超过背包限重的情况下，让背包内的物品总价值达到最大。</p></blockquote><h5 id="DFS解法："><a href="#DFS解法：" class="headerlink" title="DFS解法："></a>DFS解法：</h5><h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><blockquote><p>对于每件物品，有两种情况（选，或不选）。若选择该物品，则将更新背包内的总重与总价值量，若不选择该物品，则跳过它去判断下一件物品，当处理完n件物品后，此时记录的sumW和sumC就是所选物品的总质量和总价值。如果sumW不超过V且sumC比MaxValue还大，就更新MaxValue。</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Maxn 10</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n,V,MaxValue = <span class="hljs-number">0</span>;<span class="hljs-comment">//n为物品的总件数，V为背包的容量，MaxValue为最大价值</span></span><br><span class="line"><span class="hljs-keyword">int</span> w[Maxn],c[Maxn];<span class="hljs-comment">//w[i]为每件物品的重量,c[i]为每件物品的价值</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Kanapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> sumW,<span class="hljs-keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == n)<span class="hljs-comment">//已完成对n件物品的选择</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(sumW &lt;= V &amp;&amp; sumC &gt; MaxValue)</span><br><span class="line">&#123;</span><br><span class="line">MaxValue = sumC;<span class="hljs-comment">//更新最大价值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW,sumC);<span class="hljs-comment">//不选择第index件物品</span></span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW + w[index],sumC + c[index]);<span class="hljs-comment">//选择第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; V;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-comment">//输入每件物品的重量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-comment">//输入每件的价值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//初始时为第0件物品，重量为0，价值为0;</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; MaxValue &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>由于每种物品有两种选择，因而易得上述算法的时间复杂度为$2^n$;<br>这显然很是糟糕，因为在上述算法中，总是把对n件物品的选择全部确定后才去更新最大价值，但是却忽略了背包容量总是不能超过V这个点，也就是说，我们可以把选择index物品放入对上述条件的判断之中，若选择index后重量不超过V则才选择它。</p></blockquote><h4 id="改进后的算法："><a href="#改进后的算法：" class="headerlink" title="改进后的算法："></a>改进后的算法：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS_Kanapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> sumW,<span class="hljs-keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW,sumC);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(sumW + w[index] &lt;= V)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(sumC + c[index] &gt; MaxValue)</span><br><span class="line">&#123;</span><br><span class="line">MaxValue = sumC + c[index];</span><br><span class="line">&#125;</span><br><span class="line">DFS_Kanapsack(index+<span class="hljs-number">1</span>,sumW+w[index],sumC+c[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kanapsack-Problem&quot;&gt;&lt;a href=&quot;#Kanapsack-Problem&quot; class=&quot;headerlink&quot; title=&quot;Kanapsack Problem&quot;&gt;&lt;/a&gt;Kanapsack Problem&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】全排列问题</title>
    <link href="https://www.ccyh.xyz/2019/03/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98(C++)/"/>
    <id>https://www.ccyh.xyz/2019/03/13/【算法】全排列问题(C++)/</id>
    <published>2019-03-13T12:32:26.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h4 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h4><blockquote><p>设定一个数组p用来存放当前排列，并用一个数组Hash用来标记已填入p中的数字。<br>按顺序将数字填入数组p中的第0位置第Max-1位，现在假设已经填好了p[0]~p[index-1]，正准备将数字填入index位置，若index位置未及Max（数组边界），则枚举0~Max-1；判断是否有数字未填入，若有则将其填入p中，同时在Hash中将该数字置为已填入。其后继续填入下一个位置index+1；当递归完成时，将Hash[i]还原为false（将i置为未填入）。</p></blockquote><a id="more"></a><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Max 10</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">//列举从0到Max-1的全排列</span></span><br><span class="line"><span class="hljs-keyword">int</span> p[Max];<span class="hljs-comment">//保存当前排列</span></span><br><span class="line"><span class="hljs-keyword">bool</span> Hash[Max] = &#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-comment">//标记i是否已填入p中，是为真，否为假；</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate_x</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(index == Max)<span class="hljs-comment">//递归边界，已生成一种排列可能</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; Max;i++)<span class="hljs-comment">//输出该排列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; Max;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(Hash[i] == <span class="hljs-literal">false</span>)<span class="hljs-comment">//判断i是否还未已填入p中</span></span><br><span class="line">&#123;</span><br><span class="line">p[index] = i;<span class="hljs-comment">//填入</span></span><br><span class="line">Hash[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记已填入</span></span><br><span class="line">generate_x(index+<span class="hljs-number">1</span>);<span class="hljs-comment">//填写下一个数</span></span><br><span class="line">Hash[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//处理完P[index] = i 的子问题，还原状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">generate_x(<span class="hljs-number">0</span>);<span class="hljs-comment">//从0开始填入</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><p><img src="/【算法】全排列问题(C++" alt="">/20190313012239824.png)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;算法思想：&quot;&gt;&lt;a href=&quot;#算法思想：&quot; class=&quot;headerlink&quot; title=&quot;算法思想：&quot;&gt;&lt;/a&gt;算法思想：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;设定一个数组p用来存放当前排列，并用一个数组Hash用来标记已填入p中的数字。&lt;br&gt;按顺序将数字填入数组p中的第0位置第Max-1位，现在假设已经填好了p[0]~p[index-1]，正准备将数字填入index位置，若index位置未及Max（数组边界），则枚举0~Max-1；判断是否有数字未填入，若有则将其填入p中，同时在Hash中将该数字置为已填入。其后继续填入下一个位置index+1；当递归完成时，将Hash[i]还原为false（将i置为未填入）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】数字黑洞</title>
    <link href="https://www.ccyh.xyz/2019/03/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/"/>
    <id>https://www.ccyh.xyz/2019/03/13/【算法】数字黑洞/</id>
    <published>2019-03-13T10:59:40.000Z</published>
    <updated>2020-01-23T07:50:10.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【PAT】B1019"><a href="#【PAT】B1019" class="headerlink" title="【PAT】B1019"></a>【PAT】B1019</h3><hr><a id="more"></a><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/20190313110514051.png" alt=""><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">digs</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> dig[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> len;</span><br><span class="line">digs()</span><br><span class="line">&#123;</span><br><span class="line">dig[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line">len = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,digs &amp;d)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">d.dig[d.len++] = n%<span class="hljs-number">10</span>;</span><br><span class="line">n /= <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">to_number</span><span class="hljs-params">(digs d)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> i = d.len<span class="hljs-number">-1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--,t++)</span><br><span class="line">&#123;</span><br><span class="line">result = result + d.dig[i]*((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp_less</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a,<span class="hljs-keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">digs d;</span><br><span class="line">to_array(n,d);</span><br><span class="line">sort(d.dig,d.dig+d.len);</span><br><span class="line"><span class="hljs-keyword">int</span> min = to_number(d);</span><br><span class="line">sort(d.dig,d.dig+d.len,cmp_less);</span><br><span class="line"><span class="hljs-keyword">int</span> max = to_number(d);</span><br><span class="line">n = max - min;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%04d - %04d = %04d\n"</span>,max,min,n);</span><br><span class="line"><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">6174</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/*for(int i = 0;i &lt; d.len;i++)</span></span><br><span class="line"><span class="hljs-comment">&#123;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; d.dig[i]&lt;&lt; ' ';</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【PAT】B1019&quot;&gt;&lt;a href=&quot;#【PAT】B1019&quot; class=&quot;headerlink&quot; title=&quot;【PAT】B1019&quot;&gt;&lt;/a&gt;【PAT】B1019&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://www.ccyh.xyz/tags/algorithm/"/>
    
  </entry>
  
</feed>
