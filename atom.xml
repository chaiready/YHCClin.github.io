<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code·Hub</title>
  
  <subtitle>FlyingFish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ccyh.xyz/"/>
  <updated>2020-02-29T06:06:38.584Z</updated>
  <id>https://www.ccyh.xyz/</id>
  
  <author>
    <name>lyh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【闲疯帝】EasyX康威生命游戏的简单实现</title>
    <link href="https://www.ccyh.xyz/2020/02/05/LifeGame/"/>
    <id>https://www.ccyh.xyz/2020/02/05/LifeGame/</id>
    <published>2020-02-05T11:38:22.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><hr><p>生命游戏中，对于任意细胞，规则如下：</p><p>&emsp;每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）<br><a id="more"></a></p><ul><li>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）<br>*当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）</li></ul><p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。<code>[From WikiPedia]</code></p><hr><h2 id="简单实现（采用EasyX绘图库）"><a href="#简单实现（采用EasyX绘图库）" class="headerlink" title="简单实现（采用EasyX绘图库）"></a>简单实现（采用EasyX绘图库）</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 30</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">康威生命游戏的c++简单实现</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;(N, <span class="hljs-string">' '</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">清屏函数：若使用system("cls")会出现闪屏，因为该函数太慢了</span></span><br><span class="line"><span class="hljs-comment">由于数据量不大这里采用移动光标实现屏幕部分涂改，也可采用双缓冲机制(自行google)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearScreen</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">COORD coordScreen = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;</span><br><span class="line">SetConsoleCursorPosition(hConsole, coordScreen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 判断周围生命个数</span></span><br><span class="line"><span class="hljs-keyword">int</span> direct[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125; &#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countLiveFunc</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> nx, ny;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">nx = x + direct[k][<span class="hljs-number">0</span>];</span><br><span class="line">ny = y + direct[k][<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; N &amp;&amp; board[nx][ny] == <span class="hljs-string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 刷新函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fresh</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> n = board.size();</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; newBoard(board);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> countLive = countLiveFunc(board, i, j);</span><br><span class="line"><span class="hljs-keyword">if</span> (countLive &lt; <span class="hljs-number">2</span>) newBoard[i][j] = <span class="hljs-string">' '</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLive == <span class="hljs-number">2</span> || countLive == <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLive &gt; <span class="hljs-number">3</span>) newBoard[i][j] = <span class="hljs-string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> countLive = countLiveFunc(board, i, j);</span><br><span class="line"><span class="hljs-keyword">if</span> (countLive == <span class="hljs-number">3</span>) newBoard[i][j] = <span class="hljs-string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">board = newBoard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBoard</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">initgraph(<span class="hljs-number">700</span>, <span class="hljs-number">600</span>); <span class="hljs-comment">// 初始化窗口</span></span><br><span class="line">setbkcolor(WHITE);</span><br><span class="line">setfillcolor(GREEN);</span><br><span class="line">setlinecolor(BLACK);</span><br><span class="line"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;</span><br><span class="line">BeginBatchDraw();<span class="hljs-comment">// 开始绘图，下面绘制的图形暂时不会显示出来</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : board)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i == <span class="hljs-string">' '</span>) rectangle(x, y, x + <span class="hljs-number">20</span>, y + <span class="hljs-number">20</span>);</span><br><span class="line"><span class="hljs-keyword">else</span> fillrectangle(x, y, x + <span class="hljs-number">20</span>, y + <span class="hljs-number">20</span>);</span><br><span class="line">x = (x + <span class="hljs-number">20</span>) % <span class="hljs-number">600</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) y += <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FlushBatchDraw(); <span class="hljs-comment">// 显示之前绘制的图形</span></span><br><span class="line">Sleep(<span class="hljs-number">300</span>);</span><br><span class="line">cleardevice();<span class="hljs-comment">// 清屏</span></span><br><span class="line">fresh(board);</span><br><span class="line">&#125;</span><br><span class="line">EndBatchDraw();</span><br><span class="line">getchar();</span><br><span class="line">closegraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">// 初始化：脉冲星</span></span><br><span class="line">board = &#123;</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;,</span><br><span class="line">&#123;<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">' '</span>,&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 执行打印函数</span></span><br><span class="line">printBoard();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/LifeGame/gamegui.gif" alt="脉冲星"><br><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;生命游戏中，对于任意细胞，规则如下：&lt;/p&gt;
&lt;p&gt;&amp;emsp;每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="闲疯帝" scheme="https://www.ccyh.xyz/categories/%E9%97%B2%E7%96%AF%E5%B8%9D/"/>
    
    
      <category term="Borring" scheme="https://www.ccyh.xyz/tags/Borring/"/>
    
  </entry>
  
  <entry>
    <title>图解红黑树</title>
    <link href="https://www.ccyh.xyz/2020/01/30/RedBlackTree/"/>
    <id>https://www.ccyh.xyz/2020/01/30/RedBlackTree/</id>
    <published>2020-01-30T10:08:31.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树的基本结构"><a href="#红黑树的基本结构" class="headerlink" title="红黑树的基本结构"></a>红黑树的基本结构</h2><hr><p>&emsp;<strong>红黑树(Red-black tree)</strong> 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，常用于关联数组、字典等。C++ 中的标准关联容器set、multiset、map、multimap内部采用的数据结构就是红黑树。</p><a id="more"></a><p><strong>红黑树的定义：</strong></p><ol><li>每个节点只能是红色的或黑色的</li><li>根节点是黑色的</li><li>每个叶子节点都是黑色的</li><li>如果一个节点是红色的，那么它的孩子节点必须是黑色的</li><li>从任意一个节点到叶子节点经过的黑色节点个数是一样的</li></ol><h2 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h2><hr><p>在介绍红黑树前先了解其等价形式 <strong>2-3 树</strong>，对后面理解红黑树的定义很有帮助。<br><strong>2-3 树 的定义：</strong></p><ol><li>满足二叉搜索树的性质</li><li>节点可以存放一个(<strong>2-节点</strong>)或两个(<strong>3-节点</strong>)关键字</li><li>每个节点有两个或三个孩子节点</li></ol><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130062357515.png" alt="2-3树的两种节点"><br></center><p>学过<code>B-树</code>的会发现其节点与<code>B-树</code>相似，类似三阶<code>B-树</code>。统样，<strong>2-3 树</strong> 的基本操作也与<code>B-树</code>类似。<br><strong>2-3 树 的基本操作：</strong></p><ol><li><strong>插入：</strong> 插入新节点时，往叶子节点插入</li><li><strong>分解：</strong> 4-节点可以被分解成 3 个 2-节点组成的树，且分解后树的根节点要向上与其原来的父节点融合。</li></ol><p>下面按序列<br>$${1,2,3,4,5}$$<br>构建一棵 <strong>2-3 树</strong>：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130064535147.png" alt=""><br></center><p>不难发现在上述操作中 <strong>2-3 树</strong> 始终能够保持严格的平衡。但是由于其节点关键字个数不唯一，且拆分合并操作的编程实现较复杂，因此我们希望通过添加一些规则，将其转化成二叉树，且转换后的二叉树仍然具有2-3树的自平衡优点，这就是红黑树。</p><h2 id="2-3-树-gt-红黑树"><a href="#2-3-树-gt-红黑树" class="headerlink" title="2-3 树 -&gt; 红黑树"></a>2-3 树 -&gt; 红黑树</h2><hr><p>对于 <strong>2-3 树</strong> 的两种结点，有不同的转换规则：</p><ul><li><strong>2-结点：</strong> 直接转换成红黑树的黑节点</li><li><strong>3-节点：</strong> 拆开两个关键字，左关键字标红（表示红色节点与其父节点在2-3树中曾经是同级关系），右关键字标黑，右关键字作左关键字的父节点</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130071511715.png" alt="节点转化"><br></center><p>按照上述规则，我们将序列<br>$${3,5,8,10,12,15,16,18,19,4,20}$$<br>构建的 <strong>2-3 树</strong> 转化为一棵红黑树：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130074524660.png" alt="2-3树 转 红黑树"><br></center><p>回顾一下红黑树的性质, 判断上图的树是否满足所有性质：</p><ul><li style="list-style: none"><input type="checkbox" checked> 每个节点只能是红色的或黑色的</li><li style="list-style: none"><input type="checkbox" checked> 根节点是黑色的</li><li style="list-style: none"><input type="checkbox"> 每个叶子节点都是黑色的</li><li style="list-style: none"><input type="checkbox" checked> 如果一个节点是红色的，那么它的孩子节点必须是黑色的</li><li style="list-style: none"><input type="checkbox" checked> 从任意一个节点到叶子节点经过的黑色节点个数是一样的</li></ul><p>可以发现除了第三个性质其余都满足了。事实上，性质三中说的叶子节点指的是为空的叶子节点，所以，完整的红黑树应为：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130075833445.png" alt=""><br></center><p>如此一来，便使得所有性质都满足了。</p><hr><h2 id="红黑树的创建"><a href="#红黑树的创建" class="headerlink" title="红黑树的创建"></a>红黑树的创建</h2><hr><p>&emsp;前面提到，创建 <strong>2-3 树</strong> 的代码编写较为复杂，因此我们肯定不会先创建一棵 <strong>2-3树</strong> 再将其转换成红黑树。因为我们可以很方便地创建一棵二叉树，红黑树不过是性质比普通二叉树多了些，因此在创建红黑树时只需在创建二叉树的方法的基础上多加几种操作来保证红黑树的性质不被破坏就行了。</p><p><strong>插入：</strong> 由于前面提到<strong>2-3树</strong>的插入操作都发生在叶子节点，且都是先将待插入元素与该叶子节点融合。因此新插入节点和原位置的叶子节点为平级关系。又前面提到红色节点与其父节点曾是原级关系，故<code>插入节点应为红色</code>。<br><strong>创建演示：</strong> 下图中红边所连接的子节点为我们说的红色节点（《算法 第四版》的说法为红分支所连节点为红节点，类比着看，其实没差别因为一条分支只唯一对应一个结点）。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200131101345963.png" alt=""><br></center><p>观察上述创建过程，发现当插入节点位于右分支时我们需要左旋操作，因为红色节点只能出现在左分支。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/20200130112423899.png" alt="左旋操作"><br></center><p><strong>左旋操作的伪码实现：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    RBNode *r_temp = node -&gt; right;</span><br><span class="line">    node -&gt; right = r_temp -&gt; left;</span><br><span class="line">    r_temp -&gt; left = node;</span><br><span class="line">    r_temp -&gt; color = node -&gt; color;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    <span class="hljs-keyword">return</span> r_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>右旋操作与左旋操作类似：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    RBNode *l_temp = node -&gt; left;</span><br><span class="line">    node -&gt; left = l_temp -&gt; right;</span><br><span class="line">    l_temp -&gt; right = node;</span><br><span class="line">    l_temp -&gt; color = node -&gt; color;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    <span class="hljs-keyword">return</span> l_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>翻转颜色操作：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    node -&gt; color = RED;</span><br><span class="line">    node -&gt; left -&gt; color = BLACK;</span><br><span class="line">    node -&gt; right -&gt; color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>插入操作：</strong></p><p>有了上述基本操作的实现基础，我们来研究插入操作的实现。插入按插入位置分三种情况：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/RedBlackTree/threesituation.png" alt=""><br></center><p><strong>插入操作的实现：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RBNode(key, value, <span class="hljs-number">1</span>, RED);<span class="hljs-comment">// 插入节点为红色</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(key &lt; root-&gt;key)   root -&gt; left  = insert(root-&gt;left, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;key)  root -&gt; right = insert(root-&gt;right, key, value);</span><br><span class="line">        <span class="hljs-keyword">else</span>                 root -&gt; value = value;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 应对三种情况的操作</span></span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;left))root = leftRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;left-&gt;left))root = rightRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right))flipColor(root);</span><br><span class="line"></span><br><span class="line">root -&gt; N = size(root-&gt;left) + size(root-&gt;right) + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED true</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLACK false</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KeyType int</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ValueType string</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isRed</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(RBNode *node)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">friend</span> RBNode* <span class="hljs-title">search</span><span class="hljs-params">(RBNode *root, KeyType key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">RBNode(KeyType k, ValueType v, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">bool</span> c) : key(k), value(v), N(n), color(c), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">KeyType key;<span class="hljs-comment">// 节点保存的键值</span></span><br><span class="line">ValueType value;<span class="hljs-comment">// 键值关联的值</span></span><br><span class="line">RBNode *left, *right;<span class="hljs-comment">// 左右孩子节点指针</span></span><br><span class="line"><span class="hljs-keyword">int</span> N;<span class="hljs-comment">// 这棵子树中的节点数</span></span><br><span class="line"><span class="hljs-keyword">bool</span> color;<span class="hljs-comment">// 节点颜色：真为红，假为黑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 获得以node为根的树的节点数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> node -&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 获得节点颜色</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRed</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> node-&gt;color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 改变节点颜色</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">node -&gt; left -&gt; color = BLACK;</span><br><span class="line">node -&gt; right -&gt; color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 左旋操作</span></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">RBNode *temp  = node -&gt; right;</span><br><span class="line">node -&gt; right = temp -&gt; left;</span><br><span class="line">temp -&gt; left  = node;</span><br><span class="line">temp -&gt; color = node -&gt; color;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">temp -&gt; N     = node -&gt; N;</span><br><span class="line">node -&gt; N     = <span class="hljs-number">1</span> + size(node-&gt;left) + size(node-&gt;right);</span><br><span class="line"><span class="hljs-keyword">return</span> temp;<span class="hljs-comment">// 返回重置父节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 右旋操作</span></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode *node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">RBNode *temp  = node -&gt; left;</span><br><span class="line">node -&gt; left  = temp -&gt; right;</span><br><span class="line">temp -&gt; right = node;</span><br><span class="line">temp -&gt; color = node -&gt; color;</span><br><span class="line">node -&gt; color = RED;</span><br><span class="line">temp -&gt; N     = node -&gt; N;</span><br><span class="line">node -&gt; N     = <span class="hljs-number">1</span> + size(node-&gt;left) + size(node-&gt;right);</span><br><span class="line"><span class="hljs-keyword">return</span> temp;<span class="hljs-comment">// 返回重置父节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">search</span><span class="hljs-params">(RBNode* root, KeyType key)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root -&gt; key == key) <span class="hljs-keyword">return</span> root;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root -&gt; key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> search(root -&gt; left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> search(root -&gt; right, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function">RBNode* <span class="hljs-title">insert</span><span class="hljs-params">(RBNode *&amp;root, KeyType key, ValueType value)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RBNode(key, value, <span class="hljs-number">1</span>, RED);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(key &lt; root-&gt;key)   root -&gt; left  = insert(root-&gt;left, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;key) root -&gt; right = insert(root-&gt;right, key, value);</span><br><span class="line"><span class="hljs-keyword">else</span> root -&gt; value = value;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 应对三种情况的操作</span></span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;left))root = leftRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;left-&gt;left))root = rightRotate(root);</span><br><span class="line"><span class="hljs-keyword">if</span>(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right)) flipColor(root);</span><br><span class="line"></span><br><span class="line">root -&gt; N = size(root-&gt;left) + size(root-&gt;right) + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="noopener">《算法》 第四版 - 红黑树</a> - Robert Sedgewick<br><a href="https://mp.weixin.qq.com/s/ccXqujooT4eNvptmJKlmDA" target="_blank" rel="noopener">《我画了20张图给女朋友讲清楚红黑树》</a> - 程序员小吴</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;红黑树的基本结构&quot;&gt;&lt;a href=&quot;#红黑树的基本结构&quot; class=&quot;headerlink&quot; title=&quot;红黑树的基本结构&quot;&gt;&lt;/a&gt;红黑树的基本结构&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;&lt;strong&gt;红黑树(Red-black tree)&lt;/strong&gt; 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，常用于关联数组、字典等。C++ 中的标准关联容器set、multiset、map、multimap内部采用的数据结构就是红黑树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>SegmentTree</title>
    <link href="https://www.ccyh.xyz/2020/01/29/SegmentTree/"/>
    <id>https://www.ccyh.xyz/2020/01/29/SegmentTree/</id>
    <published>2020-01-29T16:41:27.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><hr><p>&emsp;线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。线段树可以在 $O(\log_{2}{N})$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。<br><a id="more"></a></p><h2 id="线段树的基本结构"><a href="#线段树的基本结构" class="headerlink" title="线段树的基本结构"></a>线段树的基本结构</h2><hr><p>为数组（假设下标从1开始）：<br>$$a[5] = [{1,2,3,4,5}]$$<br>构造线段树如下图（采用堆式存储）：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129054853716.png" alt="线段树示意"><br></center><p>上述数组 $D$ 用来保存线段树，由于采用的是堆式存储，因此$D[i]$ 的左右孩子结点分别为$D[2\times i],D[2 \times i + 1]$。不难发现上图有两种结点，银色结点括号表示该结点包含的数组 $a$ 的区间，$D[i]$ 的值表示 $\sum_{k=i}^{j}a[k]$。且若区间两端点相等为$[k,k]$则$D[i] = a[k]$即值为绿色结点。</p><h2 id="线段树的建立"><a href="#线段树的建立" class="headerlink" title="线段树的建立"></a>线段树的建立</h2><hr><p>由于树树递归定义的，因此其建立也是递归的：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; a)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(left == right)</span><br><span class="line">    &#123;</span><br><span class="line">        D[p] = a[left];</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;</span><br><span class="line">    build(left, mid, p*<span class="hljs-number">2</span>, D, a);</span><br><span class="line">    build(mid+<span class="hljs-number">1</span>, right, p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, D, a);</span><br><span class="line">    D[p] = D[p * <span class="hljs-number">2</span>] + D[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h2><hr><h3 id="区间和："><a href="#区间和：" class="headerlink" title="区间和："></a>区间和：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// [left,right]为待查区间，[cl,cr]为当前区间，p 为当前节点编号，D 为线段树的存储数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> cl, <span class="hljs-keyword">int</span> cr, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;D)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt;= cl &amp;&amp; cr &lt;= right) <span class="hljs-comment">// 当前区间为待查区间的子集</span></span><br><span class="line"><span class="hljs-keyword">return</span> D[p];</span><br><span class="line">        <span class="hljs-comment">// 划分区间，递归查询</span></span><br><span class="line"><span class="hljs-keyword">int</span> mid = cl + (cr - cl)/<span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt;= mid) <span class="hljs-comment">// 与左区间有交集</span></span><br><span class="line">sum += getSum(left, right, cl, mid, p * <span class="hljs-number">2</span>, D);</span><br><span class="line"><span class="hljs-keyword">if</span>(right &gt; mid) <span class="hljs-comment">// 与右区间有交集</span></span><br><span class="line">sum += getSum(left, right, mid+<span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, D);</span><br><span class="line"><span class="hljs-keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><hr><p>$[cl,cr]$为当前区间，index为要修改的数组$a$的下标，$val$为修改的最终值，$p$为当前节点编号。<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cl, <span class="hljs-keyword">int</span> cr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(cl == cr)</span><br><span class="line">&#123;</span><br><span class="line">a[index] = val;</span><br><span class="line">D[p] = val;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> mid = cl + (cr - cl)/<span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(index &gt;= cl &amp;&amp; index &lt;= mid)</span><br><span class="line">updateST(cl, mid, index, val, p * <span class="hljs-number">2</span>, D, a);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; mid &amp;&amp; index &lt;= cr)</span><br><span class="line">updateST(mid + <span class="hljs-number">1</span>, cr, index, val, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, D, a);</span><br><span class="line">D[p] = D[p * <span class="hljs-number">2</span>] + D[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时如果将$a[1]$ 改成 $6$ ,则树变成(红色表示有修改的节点)：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129082526967.png" alt="更新后的树"><br></center><hr><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; D(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a(<span class="hljs-number">6</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size();i++)</span><br><span class="line">a[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Building STree:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">buildST(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, D, a);</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"STree:"</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; D.size();i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; D[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Quary:(1,3)"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; getSum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,D) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Update: a[1] = 6"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">updateST(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,D,a);</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"STree:"</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; D.size();i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; D[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Quary:(1,3)"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; getSum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,D) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/SegmentTree/20200129084206509.png" alt="Result"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线段树&quot;&gt;&lt;a href=&quot;#线段树&quot; class=&quot;headerlink&quot; title=&quot;线段树&quot;&gt;&lt;/a&gt;线段树&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。线段树可以在 $O(\log_{2}{N})$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>DisjointSet</title>
    <link href="https://www.ccyh.xyz/2020/01/29/DisjointSet_%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://www.ccyh.xyz/2020/01/29/DisjointSet_并查集/</id>
    <published>2020-01-29T14:07:30.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一文读懂并查集"><a href="#一文读懂并查集" class="headerlink" title="一文读懂并查集"></a>一文读懂并查集</h2><hr><p>&emsp;假设你现在置身于一个鸡尾酒会中，任何人都不能通过直接搭讪来获得陌生漂亮妹子的微信号。于是你委托你的朋友帮忙，你的朋友委托他的朋友。。。直到找到一位与漂亮妹子认识的人拿到了微信号。因此，你通过这些中间朋友与妹子取得了联系，成功进入了她的社交圈。当然，你可以通过她认识跟多的漂亮妹子，走上人生巅峰。</p><a id="more"></a><p>&emsp;但是设想一下这样一个悲剧，那位漂亮妹子刚来到地球，她与地球上所有的人类都没有联系，那么你就无法通过中间人去认识她。你与她属于两个互不相交的社交圈。<br>&emsp;现在，不妨稍稍抽象一下，将酒会比作一个个人（元素）组成的集合，而集合中人与人间的关系比作元素与元素间的关系。那么，想要探讨两个人（元素）间是否能取得联系，只要看两者是否属于同一社交圈中，即是否有联系。<br>&emsp;而 <strong>并查集</strong> 的作用就是依赖这些元素两两间的联系来将这些元素区分为各个不相交的集合（社交圈），这样就可以判断两个元素是否直接或间接有联系。</p><hr><h2 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h2><hr><p>&emsp;现在我们假设酒会中有 6 个编号从 0 到 5 的人，并且他们两两之间的联系{(0,1),(1,2),(1,3),(4,5)}; 因此他们之间的关系网络如下图：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/relation.PNG" alt=""><br><br></center><p>&emsp;由于图中的边都是双向的，为了编程方便，不妨为各个连通分量分别指定一个根结点成为一棵棵树。如此一来要想判断两个结点之间是否有联系只需判断他们是否有相同的根节点即可（属于同一棵树）。由此关系网络转化为一个森林，森林中的每一棵树都是一个集合：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/relationtree.PNG" alt=""><br><br></center><p>&emsp;为了方便找出每一个结点的父结点，我们采用 <strong>树的双亲存储结构</strong> 来存储森林，如下图（ParentOf 数组）：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/parantandchild.PNG" alt="ParentOf 数组"><br><br></center><p>到此为止，已经了解了并查集是什么。接下来就是并查集的实现了。</p><hr><h2 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h2><hr><h3 id="求节点所在集合的根节点："><a href="#求节点所在集合的根节点：" class="headerlink" title="求节点所在集合的根节点："></a>求节点所在集合的根节点：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x_root = x;</span><br><span class="line"><span class="hljs-keyword">while</span>(parent[x_root] != x_root)</span><br><span class="line">&#123;</span><br><span class="line">x_root = parent[x_root];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> x_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并操作（根据两俩关系建立森林（parent数组））："><a href="#并操作（根据两俩关系建立森林（parent数组））：" class="headerlink" title="并操作（根据两俩关系建立森林（parent数组））："></a>并操作（根据两俩关系建立森林（parent数组））：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">union_verts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; rank)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 寻根</span></span><br><span class="line"><span class="hljs-keyword">int</span> x_root = get_root(x,parent);</span><br><span class="line"><span class="hljs-keyword">int</span> y_root = get_root(y,parent);</span><br><span class="line"><span class="hljs-keyword">if</span>(x_root != y_root)    <span class="hljs-comment">// 若不属于同一个集合</span></span><br><span class="line">&#123;</span><br><span class="line">parent[y_root] = x_root;    <span class="hljs-comment">// 并操作</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                   <span class="hljs-comment">// 合并成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查操作："><a href="#查操作：" class="headerlink" title="查操作："></a>查操作：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">quary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x_root = get_root(x, parent);</span><br><span class="line">    <span class="hljs-keyword">int</span> y_root = get_root(y, parent);</span><br><span class="line">    <span class="hljs-keyword">if</span>(x_root == y_root)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// x 与 y 有联系</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           <span class="hljs-comment">// x 与 y 无联系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="缺陷及其优化"><a href="#缺陷及其优化" class="headerlink" title="缺陷及其优化"></a>缺陷及其优化</h2><hr><p>&emsp;上述算法完全可以实现并查集，但是由于上述算法的并操作只是简单第将两棵树合并而不考虑两树的高度，这在某些极端情况下生成的树的高度会非常大（如下图）。而并查集操作的时间复杂度取决于树高，因此该算法的时间复杂度将会从 $O(\log_{2}{N})$ 退化成为 $O(N)$。</p><p>&emsp;因此，在合并两棵树的操作时我们要判断是将哪一棵树的根节点作为新树的根节点才能保证新树的高度尽可能小。举例如下图：</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/Mergetree.PNG" alt=""><br><br></center><p>显然，存在两种情况：</p><ul><li><p>情况 1：新树树高为 4</p></li><li><p>情况 2：新树树高为 3</p><p>毫无疑问，应该按情况 2 来合并。</p></li></ul><h4 id="在并操作中作相应修改（路径压缩）："><a href="#在并操作中作相应修改（路径压缩）：" class="headerlink" title="在并操作中作相应修改（路径压缩）："></a>在并操作中作相应修改（路径压缩）：</h4><p>总结所有的情况：</p><ul><li>两树等高：随便合并</li><li>两树不等高：将较矮的树并到较高的树中</li></ul><p>因此，我们需要记录以某节点为根的子树的高度，存储在rank数组中。rank[i] 表示以 i 节点为根的子树的高度。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">union_verts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; rank)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x_root = get_root(x,parent);</span><br><span class="line"><span class="hljs-keyword">int</span> y_root = get_root(y,parent);</span><br><span class="line"><span class="hljs-keyword">if</span>(x_root != y_root)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-comment">// 不等高</span></span><br><span class="line"><span class="hljs-keyword">if</span>(rank[x_root] &gt; rank[y_root])</span><br><span class="line">&#123;</span><br><span class="line">parent[y_root] = x_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[x_root] &lt; rank[y_root])</span><br><span class="line">&#123;</span><br><span class="line">parent[x_root] = y_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span><span class="hljs-comment">// 等高</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x_root] = y_root;</span><br><span class="line">rank[y_root]++;<span class="hljs-comment">// 改变树高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就有效避免了树的狂长。</p><hr><h2 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent(<span class="hljs-number">6</span>);</span><br><span class="line">    <span class="hljs-comment">// 初始化parent数组</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; parent.size();i++) parent[i] = i;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rank(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; edges = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="hljs-comment">// 建立并查集</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; edges.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = edges[i][<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> y = edges[i][<span class="hljs-number">1</span>];</span><br><span class="line">        union_verts(x,y,parent,rank)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 查看 1 与 5 , 2 与 3 是否有联系（同属一个集合）</span></span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Boy 1 and Girl 5 will fall in love: "</span> &lt;&lt; quary(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/DjSet/Matchresult.PNG" alt=""><br><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一文读懂并查集&quot;&gt;&lt;a href=&quot;#一文读懂并查集&quot; class=&quot;headerlink&quot; title=&quot;一文读懂并查集&quot;&gt;&lt;/a&gt;一文读懂并查集&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;假设你现在置身于一个鸡尾酒会中，任何人都不能通过直接搭讪来获得陌生漂亮妹子的微信号。于是你委托你的朋友帮忙，你的朋友委托他的朋友。。。直到找到一位与漂亮妹子认识的人拿到了微信号。因此，你通过这些中间朋友与妹子取得了联系，成功进入了她的社交圈。当然，你可以通过她认识跟多的漂亮妹子，走上人生巅峰。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://www.ccyh.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="https://www.ccyh.xyz/2020/01/29/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>https://www.ccyh.xyz/2020/01/29/字典树/</id>
    <published>2020-01-29T14:04:49.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><hr><p>&emsp;据不完全统计，世界上现存英语单词的数量为17万到100万不等。假设现在要你写一个词典APP，要求能够快速检索、删除、添加单词，。显然你很容易想到两种方案：</p><ol><li>将所有单词按字典序排列，在按二分搜索来查询。</li><li>奖励首字母索引表，在各索引项表内按字典序排序单词，再在当中按二分搜索查询。<br>但无疑上述方案的要求略高，需要大量的连续空间来存储数据，而且不方便添加删除操作。</li></ol><a id="more"></a><p>&emsp;这时Trie树便发挥作用了，我们可以用Trie树来存储单词数据，树结构不需要大量连续的存储空间而且查询、添加结点、删除结点的操作的时间复杂度很小为$O(\log_{2}{N})$。</p><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>&emsp;假设存储<br>$$[{“code”,”cook”,”five”,”file”,”fat”}]$$<br>&emsp;这几个单词。其逻辑结构为：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129024314865.png" alt=""><br></center><h2 id="Trie树的实现"><a href="#Trie树的实现" class="headerlink" title="Trie树的实现"></a>Trie树的实现</h2><hr><h3 id="结点结构："><a href="#结点结构：" class="headerlink" title="结点结构："></a>结点结构：</h3><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129030049923.png" alt="结点结构"><br></center><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">char</span> nodeChar;<span class="hljs-comment">// 该结点表示的字符</span></span><br><span class="line">    <span class="hljs-keyword">int</span> freq;<span class="hljs-comment">// 出现的频率</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> isWord; <span class="hljs-comment">// 单词结点结束标记</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;TrieNode*&gt; childNode;<span class="hljs-comment">// 先一个结点的指针</span></span><br><span class="line">    TrieNode()<span class="hljs-comment">// 初始化结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        freq = <span class="hljs-number">0</span>;</span><br><span class="line">        isWord = <span class="hljs-literal">false</span>;</span><br><span class="line">        childNode = <span class="hljs-built_in">vector</span>&lt;TrieNode*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="树的大致结构："><a href="#树的大致结构：" class="headerlink" title="树的大致结构："></a>树的大致结构：</h4><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E5%AD%97%E5%85%B8%E6%A0%91/20200129030856288.png" alt="树的结构"><br></center><ul><li>根节点的nodeChar不存储字符， 其字符表示位于指针数组中，指针数组的某元素不空则表示存在以其为首字符的单词。</li></ul><hr><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 添加操作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> k)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(k &gt;= word.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 将word的首字母插入到root的哪一个分叉中</span></span><br><span class="line">    <span class="hljs-keyword">int</span> index = word[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">    <span class="hljs-comment">// 若该树为空，插入新结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(root-&gt;childNode[index] == <span class="hljs-literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;childNode[index] = <span class="hljs-keyword">new</span> TrieNode();</span><br><span class="line">        root-&gt;childNode[index]-&gt;nodeChar = word[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-comment">// 终端结点标记</span></span><br><span class="line">            root-&gt;childNode[index]-&gt;isWord = <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;childNode[index]-&gt;isWord = <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 递归添加结点</span></span><br><span class="line">        addWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 查询操作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    TrieNode* p = root;</span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; word.size() &amp;&amp; p != <span class="hljs-literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> index = word[i] - <span class="hljs-string">'a'</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(p-&gt;childNode[index] == <span class="hljs-literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(i == word.size()<span class="hljs-number">-1</span>)</span><br><span class="line">                p-&gt;childNode[index]-&gt;freq++;</span><br><span class="line">            p = p-&gt;childNode[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(i == word.size() &amp;&amp; p-&gt;isWord)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><hr><p>删除操作比较复杂，分三种情况：</p><pre><code>1. 删除整个单词 （该单词的尾结点为叶子节点，且该单词独占一条路径）2. 删除前缀词 （该单词的尾结点非叶子节点）3. 删除分支单词 （该单词的尾结点为叶子节点但存在于其他单词共用的路径）</code></pre><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeave</span><span class="hljs-params">(TrieNode* node)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(node-&gt;childNode[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteWord</span><span class="hljs-params">(TrieNode* root, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> k)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(k &gt;= word.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete into "</span> &lt;&lt; word[k] &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> index = word[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span>(root-&gt;childNode[index] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'d'</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        deleteWord(root-&gt;childNode[index], word, k+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span>(isLeave(root) &amp;&amp; !root-&gt;isWord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dc"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">            <span class="hljs-keyword">delete</span> root;</span><br><span class="line">            root = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == word.size()<span class="hljs-number">-1</span> &amp;&amp; !isLeave(root))</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;isWord = <span class="hljs-literal">false</span>;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dd"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteKey</span><span class="hljs-params">(TrieNode *root, <span class="hljs-built_in">string</span> word)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(searchWord(root, word))</span><br><span class="line">    &#123;</span><br><span class="line">        deleteWord(root, word, <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;据不完全统计，世界上现存英语单词的数量为17万到100万不等。假设现在要你写一个词典APP，要求能够快速检索、删除、添加单词，。显然你很容易想到两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将所有单词按字典序排列，在按二分搜索来查询。&lt;/li&gt;
&lt;li&gt;奖励首字母索引表，在各索引项表内按字典序排序单词，再在当中按二分搜索查询。&lt;br&gt;但无疑上述方案的要求略高，需要大量的连续空间来存储数据，而且不方便添加删除操作。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.ccyh.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Tree" scheme="https://www.ccyh.xyz/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>二分图最大匹配问题(匈牙利算法)</title>
    <link href="https://www.ccyh.xyz/2019/11/25/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98(%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95)/"/>
    <id>https://www.ccyh.xyz/2019/11/25/二分图最大匹配问题(匈牙利算法)/</id>
    <published>2019-11-25T20:33:10.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>&emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 <strong>奇环</strong> (边为奇数的环路)， 如果一个图没有 <strong>奇环</strong> ,那么它就一定是 二分图。</p><a id="more"></a><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/bm.PNG#pic_center" alt="二分图"><br></center><h2 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h2><p>&emsp;给定一个二分图 G , 在 G 的一个子图 M 中， M 的边集 { E } 中的任意两条边都不依附于同一个顶点， 则称 M 是一个匹配。 翻译成人话就是 在图 G 中找到一些边构成一个集合， 这个集合中的任意一条边所连接的两个顶点都只属于这条边的连个端点，即每条边的顶点都不与其他边共用。如下图： 边集合 E = {(1,5),(3,6),(4,7)} 构成了一个匹配。</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/match.PNG#pic_center" alt="匹配"><br></center><h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p> &emsp;顾名思义，就是最大化满足上述规定的边集 E 。如上图的一个最大匹配结果为：</p><center><br> <img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/maxmatch.PNG#pic_center" alt="最大匹配"><br></center><hr><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>&emsp;此算法由美国数学家 <strong>哈罗德·库恩</strong> 于1955年提出该算法。先介绍两个概念：<br>&emsp;<strong>交替路</strong>： 从一个未匹配顶点出发，依次经过非匹配边、匹配边、非匹配边 … 形成的路径叫作 交替路。<br>&emsp;<strong>增广路</strong>： 从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路就称为增广路(agumenting path)，且增广路中非匹配边的数目要大于匹配边的数目。 如下图：图中已匹配点带蓝色标记，红色箭头边为一条匹配边，黑色箭头边为非匹配边。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/m.PNG#pic_center" alt=""><br></center><p>&emsp;展开来就是这样的一条 <strong>增广路</strong>：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/road.PNG#pic_center" alt=""><br></center><p>&emsp;如果此时将上述增广路的 匹配边与非匹配边<strong>对调</strong> ：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/binaryGraph/nroad.PNG#pic_center" alt=""><br></center><p>&emsp;不难发现，匹配边多了一条（两条变三条），并且新增了两个匹配顶点。如此一来，边集 E 内不就多了一条边吗，符合我们的目标（最大化边集 E）。因此，匈牙利算法的 <strong>核心</strong> 就是 <strong>不断地寻找增广路径</strong> ，以便可以不断扩大边集 E，得到一个更大的匹配。</p><p><strong>总结增广路的定义：</strong></p><ul><li>其路径长度必定为奇数，且第一条边与最后一条边必定都不属于 M（最大匹配子图）。</li><li>该路径经过取反操作（匹配变不匹配，不匹配变匹配）后可以得到一个更大的匹配 M’。</li><li>M 为 G 的最大匹配当且仅当不存在相对于 M 的增广路径。</li></ul><hr><h3 id="算法概述："><a href="#算法概述：" class="headerlink" title="算法概述："></a>算法概述：</h3><ol><li>从 X 集合中选一个未匹配点 u 作为起点。选一条非匹配边(u,v), 到 Y中的点 v。</li><li>如果 v 是为匹配点， 说明找到了一条增广路。</li><li>否则若 v 是匹配点，下一步走匹配边，v 恰好和一条匹配边邻接。 设另一端为 left[v], 可以理解为 u 直接走到了 left[v], 也是 X 中的点。<ul><li>如果始终没有找到未匹配点（找不到最后一条非匹配边）,最后会扩展出一棵匈牙利树（root 是未匹配点， 叶子节点都是匹配点），从 root 到 leaf 的路径都不是增广路。</li></ul></li><li>每次选择一个未匹配点 u 进行 DFS。 如果找不到以 u 开头的增广路，就换一个未匹配点来进行 DFS， 且以后再也不从 u 出发找增广路了。<ul><li>如果以后存在一个从 u 出发的增广路，那么现在肯定找得到。</li></ul></li></ol><hr><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 0x00ff</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPM</span> &#123;</span>  <span class="hljs-comment">// 二分图的最大奇数匹配</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, e; <span class="hljs-comment">// 左右顶点个数, 边数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; G;      <span class="hljs-comment">// G[x][y] == 1,表示存在边 x - y</span></span><br><span class="line"><span class="hljs-keyword">int</span> *left;    <span class="hljs-comment">// left[i] 为右边（Y 集合）第i个顶点的匹配顶点编号</span></span><br><span class="line"><span class="hljs-keyword">bool</span> *T;  <span class="hljs-comment">// T[i] = true 表示第i个顶点已经被标记已访问</span></span><br><span class="line"></span><br><span class="line">BPM() </span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; e;</span><br><span class="line">T = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[maxn];</span><br><span class="line">left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxn];</span><br><span class="line">G = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(maxn,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(maxn,<span class="hljs-literal">false</span>));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> t1, t2;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">G[t1][t2] = <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-built_in">memset</span>(left, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> <span class="hljs-comment">// 匈牙利算法</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; m ; v++) <span class="hljs-comment">// 遍历右边 Y 集合中的顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(G[u][v] &amp;&amp; !T[v])</span><br><span class="line">&#123;</span><br><span class="line">T[v] = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(left[v] == <span class="hljs-number">-1</span> || match(left[v]))<span class="hljs-comment">// left[v] != -1, left[v] 是 v 的匹配边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 若 v 未匹配就将它与 u 匹配(相当于找到了一条增广路 u -&gt; v)，否则通过 v 的匹配点继续找未匹配点</span></span><br><span class="line">left[v] = u;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> <span class="hljs-comment">// 求最大匹配</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 匹配数</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; u++) <span class="hljs-comment">// 遍历左边顶点寻找增广路</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">memset</span>(T, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(T));</span><br><span class="line"><span class="hljs-keyword">if</span>(match(u))</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"--"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">ans++; <span class="hljs-comment">// 找到一条增广路</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二分图&quot;&gt;&lt;a href=&quot;#二分图&quot; class=&quot;headerlink&quot; title=&quot;二分图&quot;&gt;&lt;/a&gt;二分图&lt;/h2&gt;&lt;p&gt;&amp;emsp;二分图是这样的一个图：其顶点可以划分为两个集合 $ X $ 和 $ Y $, 任何一条边所关联的两个顶点中，恰好有一个属于集合 $X$ , 另一个属于 $Y$。 同一个集合内的顶点必没有边相连。如果一个图是二分图，那么它一定没有 &lt;strong&gt;奇环&lt;/strong&gt; (边为奇数的环路)， 如果一个图没有 &lt;strong&gt;奇环&lt;/strong&gt; ,那么它就一定是 二分图。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Graph" scheme="https://www.ccyh.xyz/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>【图解算法】Tarjan算法求图的强连通分量</title>
    <link href="https://www.ccyh.xyz/2019/11/21/Tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>https://www.ccyh.xyz/2019/11/21/Tarjan算法求图的强连通分量/</id>
    <published>2019-11-21T21:58:23.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强连通分量简介"><a href="#强连通分量简介" class="headerlink" title="强连通分量简介"></a>强连通分量简介</h2><p>&emsp;&emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p><a id="more"></a><p>&emsp;&emsp;比如下图：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/%E8%BF%9E%E9%80%9A%E5%9B%BE.PNG#pic_center" alt=""><br></center><hr><h2 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h2><p>&emsp;Tarjan算法是用来求强连通分量的，它是一种基于DFS（深度优先搜索）的算法，每个强连通分量为搜索树中的一棵子树。并且运用了数据结构栈。由于栈的先进先出的性质可以保证当前在栈中的结点中先入栈的结点必然有一条通路通往后入栈的结点，这样一来判断后入栈的结点是否有一条路径通向先入栈结点就成了算法要解决的主要问题。<br><strong>算法思路：</strong><br>&emsp;首先引入两个数组 dfn[maxn] 和 low[maxn], 其中 dfn[i] 表示编号为 i 的节点被访问时的时间戳；low[i] 表示从编号为 i 的节点可追溯到（到达）的最早被访问到的节点的时间戳。下面通过上述例子跑一遍算法，描绘出每个时刻的DFS树状态和栈中的内容。</p><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/1.PNG#pic_center" alt="第一步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/2.PNG#pic_center" alt="第二步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/3.PNG#pic_center" alt="第三步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/4.PNG#pic_center" alt="第四步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/5.PNG#pic_center" alt="第五步"><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/6.PNG#pic_center" alt="第六步"><br><br></center><p>&emsp;由上述过程可得该图由三个连通分量：{5}，{4}，{2,3,1,0}</p><hr><h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><blockquote><p>代码中有详细注释，可结合上述图例分析</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*  求强连通分量： Tarjan算法</span></span><br><span class="line"><span class="hljs-comment">    Tarjan 算法， 以Robert Tarjan的名字命名的算法</span></span><br><span class="line"><span class="hljs-comment">    该算法用来在线性时间内求解图的连通性问题</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ssc</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;</span><br><span class="line">    Ssc(<span class="hljs-keyword">int</span> n_, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;g) : n(n_) &#123;         <span class="hljs-comment">// InitializeMG</span></span><br><span class="line">        graph = g;</span><br><span class="line">        dfn = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        low = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);</span><br><span class="line">        scc = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n,<span class="hljs-literal">false</span>);</span><br><span class="line">        time = <span class="hljs-number">0</span>;</span><br><span class="line">        sscnum = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;   Sscs;     <span class="hljs-comment">// 所有连通分量</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;  graph;     <span class="hljs-comment">// 有向图的邻接矩阵</span></span><br><span class="line">    <span class="hljs-keyword">int</span>                      n;     <span class="hljs-comment">// 顶点总数</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  dfn;               <span class="hljs-comment">// 时间戳数组</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;  low;               <span class="hljs-comment">// 最小时间戳数组（能够追溯到的最早栈中节点时间戳）</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; scc;               <span class="hljs-comment">// 在栈内标记数组</span></span><br><span class="line">    <span class="hljs-keyword">int</span>         time,               <span class="hljs-comment">// 时间</span></span><br><span class="line">              sscnum;               <span class="hljs-comment">// 连通分量数</span></span><br><span class="line">    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;           stk;       <span class="hljs-comment">// 遍历栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Ssc::Tarjan(<span class="hljs-keyword">int</span> root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>( dfn[root] ) <span class="hljs-keyword">return</span>;                     <span class="hljs-comment">// 访问过了，直接返回</span></span><br><span class="line">    dfn[root] = low[root] = ++time;</span><br><span class="line">    stk.push(root);                             <span class="hljs-comment">// 入栈</span></span><br><span class="line">    scc[root] = <span class="hljs-literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;v &lt; n;v++)                    <span class="hljs-comment">// 遍历 root 所指节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!dfn[v] &amp;&amp; graph[root][v])           <span class="hljs-comment">// v 还未被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[root] = min(low[root], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scc[v] &amp;&amp; graph[root][v])       <span class="hljs-comment">// 如果 v 还在栈内</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[root] = min(low[root], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(low[root] == dfn[root])                  <span class="hljs-comment">// 后代不能找到更浅的节点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        sscnum ++;                              <span class="hljs-comment">// 记数</span></span><br><span class="line">        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sc;                         <span class="hljs-comment">// 保存当前连通分量</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)                             <span class="hljs-comment">// 依次退栈至 root</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> x = stk.top();</span><br><span class="line">            scc[x] = <span class="hljs-literal">false</span>;</span><br><span class="line">            stk.pop();</span><br><span class="line">            sc.push_back(x);</span><br><span class="line">            <span class="hljs-keyword">if</span>(x == root) <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Sscs.push_back(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-function">Ssc <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-number">6</span>, graph)</span></span>;</span><br><span class="line">    S.Tarjan(<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : S.Sscs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SSC ("</span> &lt;&lt; index++ &lt;&lt; <span class="hljs-string">") : "</span>; </span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The Number of SSC : "</span> &lt;&lt; S.sscnum &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Tarjan/Tarjan.PNG#pic_center" alt="Result"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强连通分量简介&quot;&gt;&lt;a href=&quot;#强连通分量简介&quot; class=&quot;headerlink&quot; title=&quot;强连通分量简介&quot;&gt;&lt;/a&gt;强连通分量简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有向图强连通分量：在有向图G中，如果两个顶点$V_i, V_j$ 间（vi&amp;gt;vj）有一条从$V_i$到$V_j$的有向路径，同时还有一条从$V_j$到$V_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://www.ccyh.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其改进</title>
    <link href="https://www.ccyh.xyz/2019/11/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/"/>
    <id>https://www.ccyh.xyz/2019/11/19/快速排序及其改进/</id>
    <published>2019-11-19T22:37:51.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><a id="more"></a><h2 id="简单快速排序算法"><a href="#简单快速排序算法" class="headerlink" title="简单快速排序算法"></a>简单快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">Partition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = p, j = r+<span class="hljs-number">1</span>;</span><br><span class="line">Type x = a[p]; <span class="hljs-comment">// 确定主元</span></span><br><span class="line"><span class="hljs-comment">// 划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r); <span class="hljs-comment">// 从左往右寻找比 x 大的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>(a[--j] &gt; x);<span class="hljs-comment">// 从右往左寻找比 x 小的元素</span></span><br><span class="line"><span class="hljs-keyword">if</span>(i &gt;= j)</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[p] = a[j];<span class="hljs-comment">// j 最终停留在一个比 x 小的数上面</span></span><br><span class="line">a[j] = x;<span class="hljs-comment">// 将主元放到最终位置</span></span><br><span class="line"><span class="hljs-keyword">return</span> j;<span class="hljs-comment">// 返回枢轴元素下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)<span class="hljs-comment">// 递归出口，只有一个元素时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = Partition(a, p, r); <span class="hljs-comment">// 得到划分位置</span></span><br><span class="line">QuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">QuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//-----------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><hr><p> 快速排序在平均情况下时间复杂度为 O(nlog n)<br> 最坏情况下(如待排序列有序)为 O(n^2)<br> 要使得在最坏情况下时间复杂度为 O(nlog n)<br> 容易看到，快速排序的性能取决于划分的 对称性<br> 可以每次都将问题划分为相等规模的两个子问题<br> 即 T(n) = 2T(n/2) + n<br> 由主定理解得 T(n) = O(nlog n)<br> 因此可以用一个算法选取当前序列的中位数将其作为主元(pivot)，将子问题划分为原问题的一半规模</p><h2 id="随机选择快速排序算法"><a href="#随机选择快速排序算法" class="headerlink" title="随机选择快速排序算法"></a>随机选择快速排序算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 随机选择快速排序算法在当数组还没有被划分时随机第从 a[p:r] 中选择主元作为划分基准</span></span><br><span class="line"><span class="hljs-comment">// 从而可以期望划分是较对称的</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (rand() % (r-p+<span class="hljs-number">1</span>))+ p;<span class="hljs-comment">// 生成 [p,r] 区间内的随机整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">RandomizedPartition</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = Random(p, r);<span class="hljs-comment">// 产生一个属于 [p:r] 区间的随机数</span></span><br><span class="line">swap(a[i], a[p]);</span><br><span class="line"><span class="hljs-keyword">return</span> Partition(a, p, r);<span class="hljs-comment">// 调用划分函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">RandomizedQuickSort</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(p &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line">RandomizedQuickSort(a, p, q<span class="hljs-number">-1</span>);<span class="hljs-comment">// 排序左子序列</span></span><br><span class="line">RandomizedQuickSort(a, q+<span class="hljs-number">1</span>, r);<span class="hljs-comment">// 排序右子序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机线性时间选择算法"><a href="#随机线性时间选择算法" class="headerlink" title="随机线性时间选择算法"></a>随机线性时间选择算法</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 由于RandomizedSelect中使用了RandomizedPartition产生的划分基准是随机的</span></span><br><span class="line"><span class="hljs-comment">// 在这个条件下可以证明，算法RandomizedSelect可以在 O(n) 的平均时间内找出n个输入的第 k 小元素</span></span><br><span class="line"><span class="hljs-comment">// 但其在最坏情况下的时间复杂度为 O(n^2),比如在找最小元素时(k=1),总是在最大元素处划分</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"> <span class="hljs-title">Type</span> <span class="hljs-title">RandomizedSelect</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)   // 返回第 <span class="hljs-title">k</span> 小的数</span></span><br><span class="line"><span class="hljs-class"> &#123;</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(p == r)</span><br><span class="line"> <span class="hljs-keyword">return</span> a[p];</span><br><span class="line"> <span class="hljs-keyword">int</span> i = RandomizedPartition(a, p, r);<span class="hljs-comment">// 随机划分</span></span><br><span class="line"> <span class="hljs-keyword">int</span> j = i - p + <span class="hljs-number">1</span>;<span class="hljs-comment">// 计算前半部分子序列长度</span></span><br><span class="line"> <span class="hljs-keyword">if</span>(k &lt;= j)<span class="hljs-comment">// 如果 j &gt;= k ,说明第 k 小的元素在前半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, p, i, k);</span><br><span class="line"> <span class="hljs-keyword">else</span><span class="hljs-comment">// 否则, 第 k 小的元素在右半部分</span></span><br><span class="line"> <span class="hljs-keyword">return</span> RandomizedSelect(a, i+<span class="hljs-number">1</span>, r, k-j);<span class="hljs-comment">// 从右半部分中寻找第 k - j 小的元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h2><p>下面讨论一个最坏情况下可以在 O(n) 时间内找到第 k 小的元素的线性时间选择算法<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// </span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> *1. 将 n 个元素划分成 n/5 个分组， 每组 5 个元素， 除可能有一个组不是 5 个元素外。用任意一种排序算法，</span></span><br><span class="line"><span class="hljs-comment"> *   将每组中的元素排好序，并去除每组的中位数，共 n/5 个。</span></span><br><span class="line"><span class="hljs-comment"> *2. 递归调用 Select 函数找出这 n/5 个元素的中位数。 如果 n/5 为偶数，就找他的两个中位数中较大的一个</span></span><br><span class="line"><span class="hljs-comment"> *   然后以这个元素作为划分基准。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],  <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span><span class="hljs-comment">// 插入排序</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p+<span class="hljs-number">1</span>; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j]; j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j], a[j + <span class="hljs-number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">Type</span> <span class="hljs-title">Select</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">p</span>, <span class="hljs-title">int</span> <span class="hljs-title">r</span>, <span class="hljs-title">int</span> <span class="hljs-title">k</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(r - p &lt; <span class="hljs-number">75</span>)</span><br><span class="line">&#123;</span><br><span class="line">insertSort(a,p,r);<span class="hljs-comment">// 简单插入排序</span></span><br><span class="line"><span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<span class="hljs-comment">// 返回中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">// 将 a[p + 5 * i] 至 a[p + 5 * i + 4] 的第三小元素与 a[p + i] 交换位置</span></span><br><span class="line">Type x = Select(a, p, p + (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<span class="hljs-comment">// 找出中位数中的中位数，r-p-4 即为 n-5</span></span><br><span class="line"><span class="hljs-keyword">int</span> m = Partition(a, p, r, x) , j = i - p + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(k &lt;= j)</span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, p, m, k);</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> Select(a, m+<span class="hljs-number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三路划分快速排序"><a href="#三路划分快速排序" class="headerlink" title="三路划分快速排序"></a>三路划分快速排序</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">QuickSort3Way</span>(<span class="hljs-title">Type</span> <span class="hljs-title">a</span>[], <span class="hljs-title">int</span> <span class="hljs-title">left</span>, <span class="hljs-title">int</span> <span class="hljs-title">right</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">if</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">Type x = a[right];<span class="hljs-comment">// 取尾元素为主元(基准)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// i 指向序列头元素的前一个元素(不存在)</span></span><br><span class="line"><span class="hljs-comment">// j 指向序列尾元素</span></span><br><span class="line"><span class="hljs-comment">// p 与 i 相同</span></span><br><span class="line"><span class="hljs-comment">// q 与 j 相同</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>, j = right, p = left - <span class="hljs-number">1</span>, q = right;</span><br><span class="line"><span class="hljs-comment">// 开始划分</span></span><br><span class="line"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>( a[++i] &lt; x );<span class="hljs-comment">// 从左往右找大于x的元素</span></span><br><span class="line"><span class="hljs-keyword">while</span>( a[--j] &gt; x ) <span class="hljs-keyword">if</span>( j == left ) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 从右往左找小于x的元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-comment">// i j 未交错</span></span><br><span class="line">&#123;</span><br><span class="line">swap(a[i], a[j]);<span class="hljs-comment">// 交换</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[i] == x) &#123; p++; swap( a[p], a[i] ); &#125;<span class="hljs-comment">// 将与主元相等的元素交换到两侧</span></span><br><span class="line"><span class="hljs-keyword">if</span>(a[j] == x) &#123; q--; swap( a[q], a[j] ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">// i j 交错， i 为主元最终位置</span></span><br><span class="line">&#125;</span><br><span class="line">swap(a[i], a[right]);<span class="hljs-comment">// 将主元交换到最终位置</span></span><br><span class="line">j = i - <span class="hljs-number">1</span>;</span><br><span class="line">i = i + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">// 此时 p，q 指向两侧与主元相等元素的最内侧元素</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">如下图：x 为主元</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">x x x x x x x a d d t g e w x d i s e s x x x x</span></span><br><span class="line"><span class="hljs-comment">            |             |   |         |</span></span><br><span class="line"><span class="hljs-comment">            p             j   i         q</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = left;  k &lt;= p; k++, j--) swap( a[k], a[j] );<span class="hljs-comment">// 将左侧相等元素交换到主元左边</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = right - <span class="hljs-number">1</span>; k &gt;= q; k--, i++) swap( a[i], a[k] );<span class="hljs-comment">// 将右侧相等元素交换到主元右边</span></span><br><span class="line"><span class="hljs-comment">// 一次划分结束</span></span><br><span class="line"></span><br><span class="line">QuickSort3Way(a, left,  j);</span><br><span class="line">QuickSort3Way(a, i, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">28</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">65</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">63</span>,<span class="hljs-number">78</span>,<span class="hljs-number">23</span>,<span class="hljs-number">61</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>&#125;;</span><br><span class="line"><span class="hljs-comment">//RandomizedQuickSort(a,0,19);</span></span><br><span class="line"><span class="hljs-keyword">time_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">QuickSort3Way(a, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>);</span><br><span class="line">end   = clock();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">1.0</span> * (end - start)/CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">" s "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">20</span>;i++)</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">" "</span>;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="QuickSort" scheme="https://www.ccyh.xyz/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>侯捷C++学习笔记[未整理版]</title>
    <link href="https://www.ccyh.xyz/2019/11/13/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5B%E6%9C%AA%E6%95%B4%E7%90%86%E7%89%88%5D/"/>
    <id>https://www.ccyh.xyz/2019/11/13/侯捷C++学习笔记[未整理版]/</id>
    <published>2019-11-13T22:13:59.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还没有整理过的笔记，有点乱</p></blockquote><a id="more"></a><h1 id="C-程序设计II-兼谈对象模型"><a href="#C-程序设计II-兼谈对象模型" class="headerlink" title="C++ 程序设计II 兼谈对象模型"></a>C++ 程序设计II 兼谈对象模型</h1><hr><h2 id="Conversion-function-转换函数-operator-type"><a href="#Conversion-function-转换函数-operator-type" class="headerlink" title="Conversion function - 转换函数 operator type()"></a>Conversion function - 转换函数 operator type()</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// this type -&gt; other type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类，分数可以被看成double</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数，不唯一，合理就行</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    <span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 operator double() 将 f 转换成 double</span></span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 4.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// non-explicit-one-argument constructor</span></span><br><span class="line">    Fraction(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den = <span class="hljs-number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/* 当下面operator type() 函数同时存在时，会迷惑编译器，出错 ambiguous</span></span><br><span class="line"><span class="hljs-comment">    // 因为有两条路可行：</span></span><br><span class="line"><span class="hljs-comment">        1. 将 4 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        2. 将 f 转double 在将 4.6 转Fraction</span></span><br><span class="line"><span class="hljs-comment">        从而产生歧义</span></span><br><span class="line"><span class="hljs-comment">    operator double() const // 最好加const </span></span><br><span class="line"><span class="hljs-comment">    &#123;</span></span><br><span class="line"><span class="hljs-comment">        return ((double)m_numerator / m_denominator);</span></span><br><span class="line"><span class="hljs-comment">    &#125; // 转换函数</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// 调用 non-explicit ctor 将 4 转换成 Fraction,然后调用operator+()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other type -&gt; this type</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span> &#123;</span> <span class="hljs-comment">// 分数类</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">// explicit-one-argument constructor</span></span><br><span class="line">    explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) &#123;&#125; // 90% 的 explicit 用在构造函数上</span><br><span class="line">    Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 最好加const </span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)m_numerator / m_denominator);</span><br><span class="line">    &#125; <span class="hljs-comment">// 转换函数</span></span><br><span class="line">    */</span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        <span class="hljs-keyword">int</span> m_denominator; <span class="hljs-comment">// 分母</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m_numerator; <span class="hljs-comment">// 分子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;</span><br><span class="line">    Fraction d = <span class="hljs-number">4</span> + f; <span class="hljs-comment">// [Error] conversion from double to Fraction requested, 4 不能自动转为Fraction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span>&lt;bool, Alloc&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-keyword">typedef</span> __bit_reference reference;</span><br><span class="line">    <span class="hljs-keyword">protected</span>:</span><br><span class="line">        reference <span class="hljs-keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> *(begin() + defference_type(n));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>* p;</span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask;</span><br><span class="line">    ...</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> !(!(*p &amp; mask)); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于智能指针"><a href="#pointer-like-classes-关于智能指针" class="headerlink" title="pointer-like classes, 关于智能指针"></a>pointer-like classes, 关于智能指针</h2><hr><blockquote><blockquote><p>一个 class 产生出来的对象像一个指针(do more then pointer, such as auto pointer)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">public</span>:</span><br><span class="line">        <span class="hljs-comment">// 固定写法</span></span><br><span class="line">        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *px;&#125;</span><br><span class="line">        T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> px;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">shared_ptr</span>(T* p) : px(px) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span>:</span><br><span class="line">        T*    px; <span class="hljs-comment">// 指向 T 的指针</span></span><br><span class="line">        <span class="hljs-keyword">long</span>* pn;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; sp(<span class="hljs-keyword">new</span> Foo); <span class="hljs-comment">// 初始化sp为指向Foo的智能指针,即sp内部的px指向Foo</span></span><br><span class="line">    <span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(*sp)</span></span>; <span class="hljs-comment">// *p 调用 operator*()</span></span><br><span class="line">    sp -&gt; method(); <span class="hljs-comment">// 调用 method 函数 等价于 调用operator-&gt;() 再调用 px -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pointer-like-classes-关于迭代器-一种特别的智能指针"><a href="#pointer-like-classes-关于迭代器-一种特别的智能指针" class="headerlink" title="pointer-like classes, 关于迭代器(一种特别的智能指针)"></a>pointer-like classes, 关于迭代器(一种特别的智能指针)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// list 链表节点设计</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> __<span class="hljs-title">list_node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">void</span>* prev;</span><br><span class="line">    <span class="hljs-keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;lass T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ref</span>, <span class="hljs-title">class</span> <span class="hljs-title">Ptr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> __<span class="hljs-title">list_iterator</span> &#123;</span> <span class="hljs-comment">// 链表的迭代器实现</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> __list_node&lt;T&gt;* link_type; <span class="hljs-comment">// 指向链表节点的指针类型</span></span><br><span class="line">    link_type node; <span class="hljs-comment">// node 为指向链表节点的指针</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> self&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> node != x.node;&#125;</span><br><span class="line">    <span class="hljs-comment">// 本节重点</span></span><br><span class="line">    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; ++*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">    self&amp; <span class="hljs-keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//前置</span></span><br><span class="line">    self <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>) &#123;self tmp = *<span class="hljs-keyword">this</span>; --*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//后置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">list</span>&lt;Foo&gt;::iterator it;</span><br><span class="line">    *it; <span class="hljs-comment">// 获得一个Foo对象</span></span><br><span class="line">    it -&gt; method();</span><br><span class="line">    <span class="hljs-comment">// 调用Foo::method()</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (*it).method();</span></span><br><span class="line">    <span class="hljs-comment">// 相当于 (&amp;(*it)) -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-like-classes-所谓-仿函数-像函数的类"><a href="#function-like-classes-所谓-仿函数-像函数的类" class="headerlink" title="function-like classes, 所谓 仿函数 (像函数的类)"></a>function-like classes, 所谓 仿函数 (像函数的类)</h2><blockquote><blockquote><p>() 函数调用操作符 function call<br>一般只要看到class内重载了()操作符，那他的用意就是想要变成一个function,其构造的对象称为函数对象<br>标准库中，仿函数会继承一些奇特的基类如：unary_function , binary_function</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 大小为零</span></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>, <span class="hljs-title">class</span> <span class="hljs-title">Result</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; </span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">identity</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> T&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> T&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-comment">// 重载了函数调用操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt; // 源代码暗示你给他一个 <span class="hljs-title">pair</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select1st</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::first_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">select2nd</span> :</span> <span class="hljs-keyword">public</span> unary_function&lt;Pair, typname Pair::second_type&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Pair::second_type&amp;</span><br><span class="line">    <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> x.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; p(<span class="hljs-string">'a'</span>,<span class="hljs-number">97</span>);</span><br><span class="line">    <span class="hljs-keyword">char</span> ch = select1st(p);</span><br><span class="line">    <span class="hljs-keyword">int</span> in  = select2nd(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="namespase-经验谈"><a href="#namespase-经验谈" class="headerlink" title="namespase 经验谈"></a>namespase 经验谈</h2><hr><blockquote><blockquote><p>避免命名冲突</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt; // shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> jj01 &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_member_template</span><span class="hljs-params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span></span><br><span class="line">namespase jj02 &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line">    <span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_template_param</span><span class="hljs-params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125; <span class="hljs-comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ----------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 可以将所有测试函数放在一个main里面执行</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    jj01::test_member_template();</span><br><span class="line">    jj02::test_template_param();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-template-模板类-泛型编程"><a href="#class-template-模板类-泛型编程" class="headerlink" title="class template, 模板类(泛型编程)"></a>class template, 模板类(泛型编程)</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line">    T a;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function">T <span class="hljs-title">getA</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="function-template-函数模板"><a href="#function-template-函数模板" class="headerlink" title="function template, 函数模板"></a>function template, 函数模板</h2><blockquote><blockquote><p>编译器会对 function template 进行 实参推导 (augument deduction)</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stone</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    stone (<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> we)</span><br><span class="line">    : _w(w), _h(h), _weight(we) &#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> stone&amp; ths) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> _weight &lt; rhs._weight;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">min</span>(<span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">a</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">b</span>)</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">return</span> b &lt; a ? b : a; <span class="hljs-comment">// 实参推导的结果，T 为stone，于是调用 stone::operator&lt;()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="member-template-成员模板-令构造函数更有弹性"><a href="#member-template-成员模板-令构造函数更有弹性" class="headerlink" title="member template, 成员模板(令构造函数更有弹性)"></a>member template, 成员模板(令构造函数更有弹性)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125; <span class="hljs-comment">// 无参初始化</span></span><br><span class="line">    pair(<span class="hljs-keyword">const</span> T1&amp; a, <span class="hljs-keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125; <span class="hljs-comment">// 传参初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 成员模板(是成员又是模板)</span></span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>, <span class="hljs-title">class</span> <span class="hljs-title">U2</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">pair</span>(<span class="hljs-title">const</span> <span class="hljs-title">pair</span>&lt;U1, U2&gt;&amp; <span class="hljs-title">p</span>) // 构造函数 <span class="hljs-title">U1</span>,<span class="hljs-title">U2</span> 必须(可转型为)继承于 <span class="hljs-title">T1</span>,<span class="hljs-title">T2</span></span></span><br><span class="line"><span class="hljs-class">    :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived1</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p); <span class="hljs-comment">// 可以</span></span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; b;</span><br><span class="line">pair&lt;Derived1, Derived2&gt; b2(b); <span class="hljs-comment">// 不可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_ptr</span> :</span> <span class="hljs-keyword">public</span> __shared_ptr&lt;_Tp&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1* ptr = <span class="hljs-keyword">new</span> Derived1; <span class="hljs-comment">// up-cast 向上造型</span></span><br><span class="line"><span class="hljs-built_in">shared_ptr</span>&lt;Base1&gt; sptr(<span class="hljs-keyword">new</span>  Derived1); <span class="hljs-comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure><h2 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization, 模板特化"></a>specialization, 模板特化</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>&gt; // 绑定</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">hash</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; hash&lt;<span class="hljs-keyword">int</span>&gt; () (<span class="hljs-number">1000</span>); <span class="hljs-comment">// 临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partial-specialization-模板偏特化-–-个数上的偏"><a href="#partial-specialization-模板偏特化-–-个数上的偏" class="headerlink" title="partial specialization, 模板偏特化 – 个数上的偏"></a>partial specialization, 模板偏特化 – 个数上的偏</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 泛化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = ...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>, Alloc&gt; <span class="hljs-comment">// 绑定第一个模板参数，必须从左到右依次指定，不可跳跃</span></span><br><span class="line">&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// --------------------------------------------</span></span><br><span class="line"><span class="hljs-comment">// 范围上的偏特化</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="hljs-built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure><h2 id="template-template-parameter-模板模板参数"><a href="#template-template-parameter-模板模板参数" class="headerlink" title="template template parameter, 模板模板参数"></a>template template parameter, 模板模板参数</h2><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">// Container为模板模板参数</span></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> &gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    pass</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">list</span>&gt; my1st1; <span class="hljs-comment">// Error list本身是模板，未定义</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, Lst&gt; my1st2; <span class="hljs-comment">// 可以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmatPtr</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCls</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    SmatPtr&lt;T&gt; sp;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    XCls() : sp(<span class="hljs-keyword">new</span> T) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">shared_ptr</span>&gt; p1; <span class="hljs-comment">// ok</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unique_ptr</span>&gt; p2; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, weak_ptr&gt; p3; <span class="hljs-comment">// no</span></span><br><span class="line">XCls&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">auto_ptr</span>&gt; p4; <span class="hljs-comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="这个不是-template-template-parameter"><a href="#这个不是-template-template-parameter" class="headerlink" title="这个不是 template template parameter"></a>这个不是 template template parameter</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> = <span class="hljs-title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">stack</span> &#123;</span></span><br><span class="line">    pass</span><br><span class="line"><span class="hljs-keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1;</span><br><span class="line"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; s2; <span class="hljs-comment">// 已经指定list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于-C-标准库"><a href="#关于-C-标准库" class="headerlink" title="关于 C++ 标准库"></a>关于 C++ 标准库</h2><hr><blockquote><blockquote><p>Iterator   迭代器<br>Container  容器<br>Algorithm  算法<br>Functors   仿函数</p></blockquote></blockquote><p>查看标准库，并实验每一个已经实现的标准库功能。</p><hr><h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h1><hr><h2 id="variadic-templates-数量不定的模板参数-since-C-11"><a href="#variadic-templates-数量不定的模板参数-since-C-11" class="headerlink" title="variadic templates  数量不定的模板参数 (since C++11)"></a>variadic templates  数量不定的模板参数 (since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// ... 也是语法的一部分</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg, <span class="hljs-keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// &lt;&lt; 须重载</span></span><br><span class="line">    print(args...); <span class="hljs-comment">// 递归调用，每次分为firstArg和后面 Types... (其他的多个)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 调用</span></span><br><span class="line">print(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">337</span>), <span class="hljs-number">42</span>);</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">7.5</span></span><br><span class="line"><span class="hljs-comment">hello</span></span><br><span class="line"><span class="hljs-comment">0000000101111001</span></span><br><span class="line"><span class="hljs-comment">42</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 通过 sizeof(args...) 可以得到后面一包是几个</span></span><br></pre></td></tr></table></figure><h2 id="auto-语法糖-since-c-11"><a href="#auto-语法糖-since-c-11" class="headerlink" title="auto 语法糖(since c++11)"></a>auto 语法糖(since c++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; c;</span><br><span class="line"><span class="hljs-keyword">auto</span> ite = find(c.begin(), c.end(), target); </span><br><span class="line"><span class="hljs-comment">// 让编译器自动帮你推断类型，但前提是你得有assign语句，不然编译器不知道怎么推</span></span><br><span class="line"><span class="hljs-keyword">auto</span> it; <span class="hljs-comment">// 不能这样写，编译器不知道it是什么类型</span></span><br><span class="line">it = find(c.begin(), c.end(),target); <span class="hljs-comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="range-base-for-语法糖-since-C-11"><a href="#range-base-for-语法糖-since-C-11" class="headerlink" title="range-base for 语法糖(since C++11)"></a>range-base for 语法糖(since C++11)</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : container) <span class="hljs-comment">// 逐个取出，copy到 i 上 (pass by value)</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : container) <span class="hljs-comment">// pass by reference 更改了container 中的值</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;) <span class="hljs-comment">// 新语法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference-引用-代表-实际上是指针实现的"><a href="#reference-引用-代表-实际上是指针实现的" class="headerlink" title="reference 引用(代表),实际上是指针实现的"></a>reference 引用(代表),实际上是指针实现的</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span>* p = &amp;x; <span class="hljs-comment">// p pointer to x</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r = x;  <span class="hljs-comment">// r reference to x , r 代表 x, r 从一而终，不能再代表其它对象了</span></span><br><span class="line"><span class="hljs-keyword">int</span> x2 = <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 编译器制造的假象</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">sizeof</span>(r) == <span class="hljs-keyword">sizeof</span>(x)) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true 但其实 r 是一个指针</span></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; (&amp;r == &amp;x) &lt;&lt; <span class="hljs-built_in">endl</span>;               <span class="hljs-comment">// true 假象</span></span><br><span class="line"></span><br><span class="line">r = x2;      <span class="hljs-comment">// r 不能从新代表其它对象，只是把 r 代表的 x 的值变成 x2 的值罢了</span></span><br><span class="line"><span class="hljs-keyword">int</span>&amp; r2 = r; <span class="hljs-comment">// r2 reference to r (r2 代表 r, 亦相当于代表 x)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 不管是内置类型还是自定义类型都符合上述结论</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)的描述.</p></blockquote></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T *pobj)</span> </span>&#123;pobj -&gt; xxx();&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T pobj)</span> </span>&#123;pobj.xxx();&#125; <span class="hljs-comment">// 须拷贝，传递较慢</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(T&amp; pobj)</span> </span>&#123;pobj.xxx();&#125;</span><br><span class="line"></span><br><span class="line">T obj;</span><br><span class="line">func1(&amp;obj);<span class="hljs-comment">// 调用接口不同，困扰</span></span><br><span class="line">func2(obj); <span class="hljs-comment">// 调用接口相同，很好</span></span><br><span class="line">func3(obj);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 特别注意，写函数重载时，以下两种(same signature)不能并存</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; im)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> im)</span></span>; <span class="hljs-comment">// Ambiguous</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Q : const 是不是函数签名的一部分，即是否能作为重载的指标？<br>A : 是！</p></blockquote></blockquote><h1 id="Object-Model-对象模型"><a href="#Object-Model-对象模型" class="headerlink" title="Object Model 对象模型"></a>Object Model 对象模型</h1><hr><h2 id="Part-I-的承接"><a href="#Part-I-的承接" class="headerlink" title="Part I 的承接"></a>Part I 的承接</h2><blockquote><blockquote><p>Inheritance 继承：           构造由内而外，析构由外而内<br>Composition 复合：           构造由内而外，析构由外而内<br>Inheritance+Composition：    构造由内而外，析构由外而内</p><blockquote><p>Derived::Derived(…) : Base(),Component() {…}<br>Derived::~Derived() {… Component(); Base()} // 与构造相反</p></blockquote></blockquote></blockquote><h2 id="关于-vptr-和-vtbl-虚指针和虚表"><a href="#关于-vptr-和-vtbl-虚指针和虚表" class="headerlink" title="关于 vptr 和 vtbl (虚指针和虚表)"></a>关于 vptr 和 vtbl (虚指针和虚表)</h2><blockquote><blockquote><p>只要类中有虚函数，其对象在内存中就会多一根指针（指向虚表）<br>父类有虚函数，子类对象也一定拥有该指针</p></blockquote></blockquote><hr><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">public</span> B &#123;</span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内存模型：-动态绑定"><a href="#内存模型：-动态绑定" class="headerlink" title="内存模型： 动态绑定"></a>内存模型： 动态绑定</h3><hr><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr.jpg" alt="内存模型"></p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">C *p = <span class="hljs-keyword">new</span> C;</span><br><span class="line">(*p).vfunc2();</span><br><span class="line"><span class="hljs-comment">// 相当于,其中 n 表示虚表中的第 n 个虚函数</span></span><br><span class="line">(*(p-&gt;vptr)[n])(p);</span><br><span class="line">(* p-&gt;vptr[n] )(p);</span><br></pre></td></tr></table></figure><hr><h3 id="应用：PPT-图形类-多态的应用"><a href="#应用：PPT-图形类-多态的应用" class="headerlink" title="应用：PPT 图形类(多态的应用)"></a>应用：PPT 图形类(多态的应用)</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/vptr2.jpg" alt="PPT类"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>&emsp;C++ 编译器看到一个函数调用，会有两个考量（静态绑定，动态绑定)</p><ol><li>静态绑定是被编译成: CALL xxxx(func address)。</li><li>但如果符合某些条件就会动态绑定：<ul><li>通过指针调用</li><li>指针向上转型 up-cast</li><li>所调用的是虚函数(virtual func)<br>动态绑定的形式：虚机制<br>多态：指针具有很多的类型（型态）</li></ul></li></ol><hr><h2 id="关于-this-pointer"><a href="#关于-this-pointer" class="headerlink" title="关于 this pointer"></a>关于 this pointer</h2><blockquote><blockquote><p>设计分析继承体系时要对this pointer有一个清晰的认识<br>对象调用成员函数时，该对象的this指正就会隐含地传入函数中<br>下图中在对象调用OnFileOpen()时传入对象地址this，因此碰到虚函数Serialize()函数后，回去寻找CMyDoc类的虚函数表中的函数（动态绑定）</p></blockquote></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/templateMethod.jpg" alt=""></p><hr><h2 id="谈谈-const-const-member-function-常量成员函数"><a href="#谈谈-const-const-member-function-常量成员函数" class="headerlink" title="谈谈 const (const member function 常量成员函数)"></a>谈谈 const (const member function 常量成员函数)</h2><blockquote><p>const 是属于函数签名的一部分</p></blockquote><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    Class() &#123;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125; <span class="hljs-comment">// 保证不更改 mem</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mem;&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>const object(datamember不可变动)</th><th>non-const object(datamem可变动)</th></tr></thead><tbody><tr><td>const member functions(保证datamenber不变)</td><td>YES</td><td>YES</td></tr><tr><td>non-const member functions(不保证datamember不变)</td><td>无法调用</td><td>YES </td></tr></tbody></table><blockquote><p>当成员函数的 const 和 non-const 版本同时存在时，const Object 只会调用 const 版本，non-const Object 只会调用 non-const 版本</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/db.jpg" alt=""></p><hr><h2 id="关于-new-delete-array-new-array-delete-重载"><a href="#关于-new-delete-array-new-array-delete-重载" class="headerlink" title="关于 new , delete. array new , array delete.(重载)"></a>关于 new , delete. array new , array delete.(重载)</h2><h3 id="Part-I-承接："><a href="#Part-I-承接：" class="headerlink" title="Part I 承接："></a>Part I 承接：</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/new.png" alt=""></p><hr><h3 id="全局重载形式"><a href="#全局重载形式" class="headerlink" title="全局重载形式"></a>全局重载形式</h3><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/overideDelete.jpg" alt=""></p><h3 id="成员重载形式"><a href="#成员重载形式" class="headerlink" title="成员重载形式"></a>成员重载形式</h3><blockquote><p>new 分解为 3 个动作<br>delete 分解为 2 个动作<br>接管内存的分配和释放的行为</p></blockquote><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride.jpg" alt=""></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/memoveride%5B%5D.jpg" alt=""></p><hr><h3 id="示例，-接口"><a href="#示例，-接口" class="headerlink" title="示例， 接口"></a>示例， 接口</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __FOO__</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FOO__</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-keyword">int</span> _id;</span><br><span class="line"><span class="hljs-keyword">long</span> _data;</span><br><span class="line"><span class="hljs-built_in">string</span> _str;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">Foo() : _id(<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"default ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line">Foo(<span class="hljs-keyword">int</span> id) : _id(id) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ctor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//virtual    // 可选的 virtual 关键字</span></span><br><span class="line">~Foo() &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dtor. this = "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">"id = "</span> &lt;&lt; _id &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size);</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* phead,<span class="hljs-keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">Foo* p = (Foo*) <span class="hljs-built_in">malloc</span>(size);</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:new[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* phead, <span class="hljs-keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo:delete[] has been called."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// END DEFINE</span></span></span><br></pre></td></tr></table></figure><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"sizeof(Foo) = "</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo *p = <span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line"><span class="hljs-keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Foo* pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">delete</span>[] pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"********************************************"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局,不会进入重载函数</span></span><br><span class="line">Foo* _p = ::<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">7</span>);</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _p;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"============================================"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 强制全局</span></span><br><span class="line">Foo *_pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];</span><br><span class="line">::<span class="hljs-keyword">delete</span>[] _pArray;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foo.png" alt="Foo with non-virtual dtor"></p><p><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/Foowithvirtual.png" alt="Foo with virtual dtor"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;还没有整理过的笔记，有点乱&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://www.ccyh.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="https://www.ccyh.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode23 合并 K 个排序链表(Hard)</title>
    <link href="https://www.ccyh.xyz/2019/09/10/LeetCode23%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8(Hard)/"/>
    <id>https://www.ccyh.xyz/2019/09/10/LeetCode23合并-K-个排序链表(Hard)/</id>
    <published>2019-09-10T13:43:26.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>&emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><a id="more"></a><p><strong>示例:</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,</span><br><span class="line">  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,</span><br><span class="line">  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>&emsp;因为所给链表均有序且头节点指针均在一个数组中，可以将当前数组中的头节点指针所指向的链表节点的值与其所在下标绑定为一个 pair 并存入一个最小堆中（按节点val排序，由优先级队列实现），这样就可以每次从堆中（pop）取出最小值用尾插法插入结果链表中。并且每次pop后都更新lists数组，将新的头节点的 pair 推入最小堆中，如此循环往复直至堆为空。</p><h3 id="算法演示："><a href="#算法演示：" class="headerlink" title="算法演示："></a>算法演示：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/lists.PNG" alt="lists数组"><br></center><p>I. 初始化堆：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与其所指链表节点的val绑定为pair入堆</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="hljs-comment">//加负号取反，间接实现小顶堆</span></span><br><span class="line">                      Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/Initial.PNG" alt=""><br></center><p>II. 从堆中取出最小元素（堆顶）并更新lists数组与堆</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"> <span class="hljs-comment">//实现摘下链表头节点的操作(跟新lists)</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);<span class="hljs-comment">//释放内存</span></span><br><span class="line"> <span class="hljs-comment">//弹出顶点</span></span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-comment">//新头节点进入</span></span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br></pre></td></tr></table></figure><center><br>1. 更新lists数组<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/reLists.PNG" alt="更新lists"><br>2. 弹出堆顶<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/pop1.PNG" alt="弹出顶点"><br>3. 更新堆<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/push1.PNG" alt="更新堆"><br></center><p>III. 循环II（1、2、3）直到堆为空。</p><hr><h2 id="算法代码："><a href="#算法代码：" class="headerlink" title="算法代码："></a>算法代码：</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//定义优先级队列，对pair默认对第一个元素按从小到大排序（大顶堆）</span></span><br><span class="line"><span class="hljs-comment">//因此push进队列时可将对应链表节点的val值取相反数，输出时还原，间接实现了小顶堆</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; Q;</span><br><span class="line"><span class="hljs-comment">//初始化优先级队列，将lists中的元素下标与</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义结果链表头节点</span></span><br><span class="line">ListNode *head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>),*p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//实现摘下链表头节点的操作</span></span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(-Q.top().first);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line"><span class="hljs-keyword">int</span> i = Q.top().second;</span><br><span class="line">ListNode *r = lists[Q.top().second];</span><br><span class="line">lists[Q.top().second] = lists[Q.top().second] -&gt; next;</span><br><span class="line"><span class="hljs-keyword">delete</span>(r);</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">Q.push(make_pair(-lists[i]-&gt;val, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> head -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//生成链表数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generatList</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-built_in">list</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>.size()!=lists.size()) <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* p = lists[i];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">list</span>[i].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) &#123; lists[i] = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]); p = lists[i];&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p -&gt; next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-built_in">list</span>[i][j]);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;ListNode*&gt; lists(<span class="hljs-number">3</span>);</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">list</span> = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;&#125;;</span><br><span class="line">generatList(lists,<span class="hljs-built_in">list</span>);</span><br><span class="line">ListNode* head = mergeKLists(lists);</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="hljs-keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; p -&gt; val &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode23/result23.PNG" alt=""><br></center><hr><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><p>&emsp;假设 K 个链表每个链表的长度为 N ，堆的调整时间复杂度为 $ \log_{2}{K} $，故时间复杂度为$ KN \log_{2}{K} $.<br>&emsp;空间复杂度为$ O(1) $.</p><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;&amp;emsp;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1178_Hard_猜字谜</title>
    <link href="https://www.ccyh.xyz/2019/09/06/LeetCode1178_Hard_%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
    <id>https://www.ccyh.xyz/2019/09/06/LeetCode1178_Hard_猜字谜/</id>
    <published>2019-09-06T12:30:03.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><a id="more"></a><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 word 中包含谜面 puzzle 的第一个字母。</li><li>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。<br><strong> 示例：</strong><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>], </span><br><span class="line">puzzles = [<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"aboveyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span> </span><br><span class="line"><span class="hljs-number">1</span> 个单词可以作为 <span class="hljs-string">"abrodyz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span></span><br><span class="line"><span class="hljs-number">3</span> 个单词可以作为 <span class="hljs-string">"abslute"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"able"</span></span><br><span class="line"><span class="hljs-number">2</span> 个单词可以作为 <span class="hljs-string">"absoryz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span></span><br><span class="line"><span class="hljs-number">4</span> 个单词可以作为 <span class="hljs-string">"actresz"</span> 的谜底 : <span class="hljs-string">"aaaa"</span>, <span class="hljs-string">"asas"</span>, <span class="hljs-string">"actt"</span>, <span class="hljs-string">"access"</span></span><br><span class="line">没有单词可以作为 <span class="hljs-string">"gaswxyz"</span> 的谜底，因为列表中的单词都不含字母 <span class="hljs-string">'g'</span>。</span><br></pre></td></tr></table></figure></li></ul><p><strong> 提示： </strong></p><blockquote><ul><li>1 &lt;= words.length &lt;= 10^5</li><li>4 &lt;= words[i].length &lt;= 50</li><li>1 &lt;= puzzles.length &lt;= 10^4</li><li>puzzles[i].length == 7</li><li>words[i][j], puzzles[i][j] 都是小写英文字母。</li><li>每个 puzzles[i] 所包含的字符都不重复。</li></ul></blockquote><hr><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h3 id="法一：暴力枚举判断（超时）"><a href="#法一：暴力枚举判断（超时）" class="headerlink" title="法一：暴力枚举判断（超时）"></a>法一：暴力枚举判断（超时）</h3><p>这个算法很直观，无非就是遍历枚举每一个谜面，判断words中能作为它的谜底的word的个数。<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> charcounter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">charcounter[j-<span class="hljs-string">'a'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; chset;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : k)</span><br><span class="line">&#123;</span><br><span class="line">chset.insert(m);</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.size()&gt;<span class="hljs-number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(chset.find(i[<span class="hljs-number">0</span>])==chset.end())</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">auto</span> iter = chset.begin();</span><br><span class="line"><span class="hljs-keyword">bool</span> flags = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(;iter != chset.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(charcounter[(*iter)-<span class="hljs-string">'a'</span>] &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flags = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flags) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="法二：暴力枚举-位运算（超时）"><a href="#法二：暴力枚举-位运算（超时）" class="headerlink" title="法二：暴力枚举+位运算（超时）"></a>法二：暴力枚举+位运算（超时）</h3><p>已知int行为32位，而小写字母有26个，因此用一个int型的整数就能够表示字符串中是否出现某字符：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178.PNG" alt=""><br></center><p>上图就可以表示字符串“anwvw”<br>因此思路就是沿用上面的暴力枚举方法，只不过将字符串查询比较转化为整数的比较。</p><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfVaildWords_BTL(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfpuzzles;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : puzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> puzzle = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : i)</span><br><span class="line">&#123;</span><br><span class="line">puzzle = puzzle | (<span class="hljs-number">1</span> &lt;&lt; (j-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfpuzzles.push_back(puzzle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; binOfwords;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; k : words)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//生成谜底的二进制数</span></span><br><span class="line"><span class="hljs-keyword">int</span> word = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; m : k)</span><br><span class="line">&#123;</span><br><span class="line">word = word | (<span class="hljs-number">1</span> &lt;&lt; (m-<span class="hljs-string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line">binOfwords.push_back(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : binOfpuzzles)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; j : binOfwords)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(i == j) ans++;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((((<span class="hljs-number">1</span> &lt;&lt; (puzzles[n][<span class="hljs-number">0</span>]-<span class="hljs-string">'a'</span>)) &amp; j) != <span class="hljs-number">0</span>)) <span class="hljs-comment">//如果word中包含puzz的第一个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">26</span>;k++) <span class="hljs-comment">//判断是否符合第二条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>( ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;i) == <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-keyword">int</span>)((<span class="hljs-number">1</span> &lt;&lt; k)&amp;j) != <span class="hljs-number">0</span>) ) <span class="hljs-comment">//word中存在而puzz中不存在</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(flag) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push_back(ans);</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法虽然比第一个好点但是当面对更大规模的测试样例时还是会超时。</p><hr><h3 id="法三：位运算-哈希"><a href="#法三：位运算-哈希" class="headerlink" title="法三：位运算+哈希"></a>法三：位运算+哈希</h3><p>分析题设，根据第一个成为谜底的条件就是word中必须包含puzzle中的第一个字符，因此可以建立26个字符与包含该字符的word的整数表示所组成的数组的映射关系：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11782.PNG" alt=""><br></center><p>如此一来，我们就只需判断包含puzzle首字符的word是否是谜底就可以了，减少了很多无用重复的比较。<br>再者，不难发现若某一个word是puzzle的谜底那么其包含的字符种类肯定小于等于puzzle所包含的字符种类，这体现在整数化的字符串中就是：intOfWord的二进制值中 1 的位数肯定少于或等于intOfPuzzle中 1 的位数，并且intOfWord中 1 出现的位必将也是intOfPuzzle中 1 出现的位。因此对intOfWord和intOfPuzzle取余就会得到它们共同拥有的字符的字符串的整数表示，若该结果等与intOfWord就表明此时的word就是谜底。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode11783.PNG" alt=""><br></center><p><strong> 最终算法如下：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; findNumOfValidWords(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; puzzles) &#123;</span><br><span class="line"><span class="hljs-comment">//v用来保存含有'a'+i字母的word的二进制数</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; hashV[<span class="hljs-number">26</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : words) &#123;</span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜底word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp = tmp^(<span class="hljs-number">1</span> &lt;&lt; ii);</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> j : s)</span><br><span class="line">hashV[j - <span class="hljs-string">'a'</span>].push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//结果数组ans</span></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;</span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : puzzles) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> at = i[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>;<span class="hljs-comment">//记录首字母</span></span><br><span class="line"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; s(i.begin(), i.end());</span><br><span class="line"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//生成一个谜面的二进制数</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">26</span>; ii++)</span><br><span class="line"><span class="hljs-keyword">if</span> (s.count(<span class="hljs-string">'a'</span> + ii))</span><br><span class="line">tmp ^= <span class="hljs-number">1</span> &lt;&lt; ii;</span><br><span class="line">ans.push_back(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : hashV[at]) <span class="hljs-comment">//hashV[at]中保存的是包含puzzle首字母的word的二进制数</span></span><br><span class="line"><span class="hljs-keyword">if</span> ((j &amp; tmp) == j) <span class="hljs-comment">//j &amp; tmp 会得到它们共同拥有的字符的二进制数，</span></span><br><span class="line">ans.back()++;   <span class="hljs-comment">//若其值与(j)不相等则表示word中含有puzzle中不含的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="运行测试："><a href="#运行测试：" class="headerlink" title="运行测试："></a>运行测试：</h3><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = &#123;<span class="hljs-string">"aaaa"</span>,<span class="hljs-string">"asas"</span>,<span class="hljs-string">"able"</span>,<span class="hljs-string">"ability"</span>,<span class="hljs-string">"actt"</span>,<span class="hljs-string">"actor"</span>,<span class="hljs-string">"access"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; puzzles = &#123;<span class="hljs-string">"aboveyz"</span>,<span class="hljs-string">"abrodyz"</span>,<span class="hljs-string">"abslute"</span>,<span class="hljs-string">"absoryz"</span>,<span class="hljs-string">"actresz"</span>,<span class="hljs-string">"gaswxyz"</span>&#125;;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res(findNumOfValidWords(words,puzzles));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"  "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/leetcode1178/leetcode1178res.PNG" alt=""><br></center><hr><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>图解LeetCode295_Hard_MedianFinder</title>
    <link href="https://www.ccyh.xyz/2019/08/29/LeetCode295_Hard/"/>
    <id>https://www.ccyh.xyz/2019/08/29/LeetCode295_Hard/</id>
    <published>2019-08-29T10:50:38.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC295-数据流中的中位数-类设计）"><a href="#LC295-数据流中的中位数-类设计）" class="headerlink" title="[LC295] 数据流中的中位数(类设计）"></a>[LC295] 数据流中的中位数(类设计）</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><a id="more"></a><p><strong>例如：</strong></p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br><strong>示例：</strong><br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line">addNum(<span class="hljs-number">1</span>)</span><br><span class="line">addNum(<span class="hljs-number">2</span>)</span><br><span class="line">findMedian() -&gt; <span class="hljs-number">1.5</span></span><br><span class="line">addNum(<span class="hljs-number">3</span>) </span><br><span class="line">findMedian() -&gt; <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-median-from-data-stream</a></p><hr><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>维护两个堆（一个大顶堆bigger，一个小顶堆smaller）来保存数据流中流过来的数字。无论何时都要保持abs(bigger.size-smaller.size)&lt;=1;并且保证大顶堆内的数字的值全都小于或等于小顶堆内的数字的值，这样就能保证大顶堆保存的是数据流中较小的一半数字，而小顶堆中保存的是另外较大的一半。</p><hr><h3 id="findMedian-函数设计"><a href="#findMedian-函数设计" class="headerlink" title="findMedian 函数设计"></a>findMedian 函数设计</h3><p>&emsp;&emsp;如此一来，不难发现数据流的中位数查找函数 findMedian() 的逻辑就为(伪代码)：<br><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> smaller.size == bigger.size:</span><br><span class="line">    <span class="hljs-keyword">return</span> (smalle.top + bigger.top)/<span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> smaller.size &gt; bigger.size:</span><br><span class="line">    <span class="hljs-keyword">return</span> smaller.top;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">    <span class="hljs-keyword">return</span> bigger.top;</span><br></pre></td></tr></table></figure></p><hr><h3 id="addNum-函数设计"><a href="#addNum-函数设计" class="headerlink" title="addNum 函数设计"></a>addNum 函数设计</h3><p>&emsp;&emsp;addNum() 函数在添加元素的过程中保持两个堆的动态平衡：<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Condition 1.保证两堆元素个数相差不超过 1</span><br><span class="line">Condition 2.保证大顶堆中的元素小于等于小顶堆中的任何元素</span><br></pre></td></tr></table></figure></p><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><ul><li>如果两堆中的元素个数相同。这个时候无论插入哪一个堆，条件 1 都不会被破坏,因此考虑条件 2 ，将待插入元素与两堆的堆顶比较:若待插入元素为 5，显然这个时候若插入smaller会破坏条件 2，因此因插入bigger中。而若待插入为 9 则显然应插入 smaller 中。</li></ul><center><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case1.png" alt=""><br><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case1_1.png" alt=""><br><br></center><hr><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><ul><li>如果大顶堆元素个数小于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较:</li><li>若小于等于Bigger.top则直接插入Bigger中；</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case2.png" alt=""><br></center><ul><li>若大于smaller.top则为了保证条件1,需将smaller中的最小值（根）转存至Bigger中。</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case2_11.png" alt=""><br></center><hr><h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3:"></a>case 3:</h4><ul><li>如果大顶堆的元素个数大于小顶堆的元素个数。此时，将待插入元素与两堆堆顶比较：</li><li>若其大于等于Smaller.top则直接插入Smaller中；</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case3_1.png" alt=""><br></center><ul><li>若小于Bigger.top则为了保证条件1，需将Bigger中的最大元素值（根）转存至Smaller中。</li></ul><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/case3_2.png" alt=""><br></center><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++ hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Include_all.h"</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"><span class="hljs-comment">/** initialize your data structure here. */</span></span><br><span class="line">MedianFinder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//插入过程中维持两堆元素个数的动态平衡</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//如果两堆元素个数相同</span></span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.size()==bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(!bigger.empty() &amp;&amp; bigger.top()&gt;=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//小顶堆&gt;大顶堆</span></span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(smaller.size() &lt; bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(bigger.top()&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push bigger's top "</span> &lt;&lt; bigger.top() &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(bigger.top());</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop bigger's top'"</span> &lt;&lt; bigger.top() &lt;&lt;<span class="hljs-string">" from bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.pop();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//大顶堆&gt;小顶堆</span></span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.top() &lt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push smaller's top "</span> &lt;&lt; smaller.top() &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(smaller.top());</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop smaller's top "</span> &lt;&lt; smaller.top() &lt;&lt;<span class="hljs-string">" from smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.pop();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push num "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into smaller"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">smaller.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Push "</span> &lt;&lt; num &lt;&lt;<span class="hljs-string">" into bigger"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">bigger.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//该函数返回中位数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(smaller.size()==bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (smaller.top()+bigger.top())/<span class="hljs-number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(smaller.size()&gt;bigger.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> smaller.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line"><span class="hljs-keyword">return</span> bigger.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line"><span class="hljs-comment">//实现两个堆的动态平衡</span></span><br><span class="line">priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; smaller; <span class="hljs-comment">//小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; bigger; <span class="hljs-comment">//大顶堆</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="hljs-comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">46</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">67</span>,<span class="hljs-number">55</span>,<span class="hljs-number">66</span>&#125;;</span><br><span class="line">MedianFinder* obj = <span class="hljs-keyword">new</span> MedianFinder();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : nums)</span><br><span class="line">obj-&gt;addNum(i);</span><br><span class="line"><span class="hljs-keyword">double</span> param_2 = obj-&gt;findMedian();</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; param_2 &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%5BLeetcode295_hard%5DMedianFinder/leetcode295.png" alt=""><br></center><hr><h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LC295-数据流中的中位数-类设计）&quot;&gt;&lt;a href=&quot;#LC295-数据流中的中位数-类设计）&quot; class=&quot;headerlink&quot; title=&quot;[LC295] 数据流中的中位数(类设计）&quot;&gt;&lt;/a&gt;[LC295] 数据流中的中位数(类设计）&lt;/h2&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.ccyh.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.ccyh.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>机器学习原来这么有趣-Part3-深度学习与卷积神经网络</title>
    <link href="https://www.ccyh.xyz/2019/06/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.ccyh.xyz/2019/06/21/机器学习真有趣-第3部分-深度学习与卷积神经网络/</id>
    <published>2019-06-21T12:21:08.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近看了Adam Geitgey的机器学习系列文章。寻思着闲着也是闲着，干脆翻译以下，顺便学习下英语啥的哈哈哈。第一次做这种事，有不到位的地方欢迎指教噢。</p></blockquote><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>&emsp;你是否已经厌倦了在查阅了无数有关深度学习的文章之后仍然不能参透其中深意的无力感。如果有的话，现在，是时候改变现状了！</p><p>&emsp;现在，我们将学习如何应用深度学习知识编写一个程序去识别图像中的物体。换句话说，我们将试着去清楚地解释谷歌相册具有的黑科技图像搜索功能（根据图像内容搜索图像）内部究竟如何运作，揭开其神秘的面纱。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/google.gif" alt="谷歌让你能够根据文字描述搜索自己的相册中的图片"><br></center><p>&emsp;就像<a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471" target="_blank" rel="noopener">Part1</a>和<a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-2-a26a10b68df3#.lbsa5her1" target="_blank" rel="noopener">Part2</a>那样，这篇教程是面向所有对机器学习有着极度的好奇但却不知道该从何处开始的同学。写作本教程的目的旨在它能够对所有人而言都是通俗易懂的，因此我使用了大量的概括斌且略过了大量的非必要的细节。但这些并不重要，我才不会在意这些。只要能让读者加深对学习机器学习兴趣（而不是畏惧），我的任务就算圆满完成了。<br>（如果你还没读过Part1和Part2，那么现在就可以去读读啦！）</p><hr><h1 id="利用深度学习识别对象"><a href="#利用深度学习识别对象" class="headerlink" title="利用深度学习识别对象"></a>利用深度学习识别对象</h1><hr><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621125835738.png" alt=""><br></center><p>&emsp;你以前也许看过上面这副著名的<a href="http://xkcd.com/1425/" target="_blank" rel="noopener">xkcd 系列漫画</a>。<br>&emsp;该暗讽基于这样的一个事实：随便一个三岁小孩都能认出一张图片中的鸟，但搞清楚如何让计算机识别物体这个问题却令世界上最好的计算机科学家困惑了50余年。</p><p>&emsp;但近些年来，我们终于摸索出一套利用 <strong>深度卷积神经网络</strong> 识别物体的方法。这个词听起来就像是从威廉·吉布森的科幻小说中摘抄下来的一样，但是如果你将其逐一分解开来，这个方法是很好理解的。</p><p>&emsp;那么，让我们开始吧–编写一个能够识别鸟类的程序！</p><hr><h1 id="一个简单的开始"><a href="#一个简单的开始" class="headerlink" title="一个简单的开始"></a>一个简单的开始</h1><hr><p>&emsp;在学习如何识别图像中的小鸟之前，先让我们来学习一下更为简单的识别任务–识别手写数字 ” <strong>8</strong> “。<br>&emsp;在本系列的第二部分，我们学习了通过将大量简单的人工神经元链接在一起所组成的神经网络可以解决一些复杂的问题。我们创建了一个小型的神经网络根据房子的大小、房间数目以及其所在的社区去估计该房子的市场价格：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621013358140.png" alt=""><br></center><p>&emsp;我们也认识到机器学习的目的就是用一个通用算法可以被喂以不同的数据以解决不同的问题。因此让我们修改之前写过的神经网络让它具有识别手写数字的能力。但为了使这项工作更加简单，我们只尝试去识别一个数字 —– <strong>8</strong> 。</p><p>&emsp;让机器学习算法正常工作的前提是你必须拥有数据—-最好是非常多的数据。所以我们需要大量的手写数字8的图片好让我们可以开始工作。幸运的是，研究者们早已为此创建了一个叫做<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>的手写数字数据集。MNIST数据集提供了60,000张$18\times 18$像素的手写数字图片。<br>&emsp;这里有些来自MNIST的关于手写数字8的图片：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621015205458.png" alt="一些来自MNIST的8"><br></center><h1 id="如果你细想一下，一切都只是数字而已"><a href="#如果你细想一下，一切都只是数字而已" class="headerlink" title="如果你细想一下，一切都只是数字而已"></a>如果你细想一下，一切都只是数字而已</h1><hr><p>&emsp;我们在第二部分所构建的神经网络仅仅只有三个输入结点（”3“个房间、”2000“平方英尺等等）。但现在我们想让我们的神经网络处理图像，我们如何将图像输入网络而不仅仅是数字？<br>&ensp;问题的答案简单到让人难以置信。一个神经网络以数字作为其输入。对于计算机而言，一张图片实际上只是一个数字网格，网格中的每个数字表示对应像素的明暗程度：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/mnist_8.gif" alt="Mnist数据集"><br></center><p>&emsp;为了将一张图片输入我们的神经网络，我们简单地将一张$18\times 18$像素的图片视为一个含有$18\times 18=324$个数字的数组：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621020543877.png" alt=""><br></center><p>&emsp;为了处理这324个输入，我们只要扩大输入层结点至324个就可以了。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621020832375.png" alt=""><br></center><p>&emsp;注意到我们的神经网络现在也只有两个输出结点（之前是一个）。第一个输出表示该图片是8的概率，第二个表示该图片不是8的概率。通过为我们想要识别的每种类型的对象提供单独的输出，我们可以利用神经网络对对象进行分类。<br>&emsp;现在我们的神经网络的确比之前的规模大得多了（用324个输入结点代替了3个输入结点）。但是大多数现代计算机都能够在眨眼间处理完拥有数百神经元结点的神经网络。甚至你的手机也可以做到这般。<br>&emsp;剩下的就是用这些 <strong>” 8 “</strong> 的图片以及不是 <strong>” 8 “</strong> 的图片来训练神经网络使其能够区分二者了。我们会人为地告知网络那些真正的<strong>” 8 “</strong> 的图片是8的可能性为100%,而其他图片是8的可能性为0%。<br>下面是部分训练集的数据：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621022738958.png" alt=""><br></center><p>&emsp;对于如此规模类型的神经网络，我们只需在一台现代笔记本电脑上花费几分钟时间就可以训练出一个能够识别手写数字8的高准确度的神经网络模型。<br>欢迎来到（20世纪80年代后期）图像识别的世界！！！</p><h1 id="以管窥天"><a href="#以管窥天" class="headerlink" title="以管窥天"></a>以管窥天</h1><hr><p>&emsp;简单地将一个个像素馈入神经网络，这很简洁，也的确可以用来构建图像识别神经网络。机器学习太牛皮了！…但这样真的就完美了吗？<br>&emsp;吼，当然没有那么简单了。</p><p>&emsp;首先，好消息是我们的【数字8识别者】在识别居中字符时的确可以很好地工作并且拥有很高的准确率：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621025031526.png" alt=""><br></center><p>但坏消息是：<br>&emsp;【数字8识别者】对于非居中字符的识别效率惨不忍睹，仅仅一丢丢的位置变化就毁了它的一世英名：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621025126754.png" alt=""><br></center><p>&emsp;这是因为我们的神经网络仅仅学习了具有完美的居中位置的数字8图像，所以它仅仅只能够区别位于居中位置的数字图像。</p><p>&emsp;这种能力在现实世界中毫无用处。现实世界的问题往往不那么简单明了。所以，我们必须搞清楚如何使我们的神经网络对于非居中字符图像也能准确识别。</p><h2 id="蛮力解法-1：使用滑动窗口搜索"><a href="#蛮力解法-1：使用滑动窗口搜索" class="headerlink" title="蛮力解法 #1：使用滑动窗口搜索"></a>蛮力解法 #1：使用滑动窗口搜索</h2><hr><p>&emsp;我们以及构建了一个表现不错的识别居中字符8的神经网络。那如果我们仅仅只是扫描非居中的8的图像直到找到它为止。这样我们就可以利用先前的神经网络来识别它了不是吗？就像下图这样：</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/find_8.gif" alt=""><br></center><p>&emsp;这种方法叫做滑动窗口法。它是一个依靠蛮力的解决办法（可不怎么聪明）。它在有限的案例中表现还算不赖，但它实在是太低效了。你不得不一遍又一遍地检查相同的图像寻找不同大小的数字图像。我们应该能够做的更好，而不是得过且过。</p><h2 id="蛮力解法-2：更多数据以及更深层的网络"><a href="#蛮力解法-2：更多数据以及更深层的网络" class="headerlink" title="蛮力解法 #2：更多数据以及更深层的网络"></a>蛮力解法 #2：更多数据以及更深层的网络</h2><hr><p>&emsp;当我们训练神经网络时，我们仅仅向其投喂数字8居中的图像。如果我们向他投喂更多的数据，包括数字8不居中以及不同大小的图像又会怎样呢？<br>&emsp;我们甚至不需要去收集新的训练数据，只需要写一个脚本让其自动生成位于图片不同位置不同大小的8的图像即可：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621033852185.png" alt=""><br></center><p>&emsp;利用这项技术，哦我们可以轻松地创建无数的数据用于训练。<br>&emsp;更多的数据对于我们较小的神经网络意味着困难重重。但我们可以扩大它的规模，以至于让它能够学习更复杂的模式。<br>&emsp;为了扩大神经网络的规模，我们可以增加其隐藏层（及其结点）的数量：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621080518086.png" alt=""><br></center><p>我们将这个新面孔称为<strong>” 深度神经网络 “</strong>，因为它对比传统神经网络有着更多的层数。</p><p>&emsp;自20世纪60年代后期以来，这个想法就被提出了。但是直到近些年，训练这么大的神经网络还是太慢了以至于让它看起来毫无用处。但是一旦我们搞清楚如何用<strong>3D 图形卡</strong>（被设计成用来快速进行矩阵乘法）来代替普通的计算机处理器，使用大型神经网络就会变得切实可行了。事实上，你用来玩OverWatch的NVIDA GeForce GTX 1080显卡就完全可以用来快速训练神经网络。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621040012014.png" alt="金钱的味道"><br></center><p>&emsp;但是即使我们可以构建自己的大型神经网络并且用3D 显卡来训练它，这仍然不会让我们能够高枕无忧。对于如何处理图像并将其传入神经网络中，我们需要更加聪明一点。<br>&emsp;仔细想想。分别训练神经网络去识别图像顶部的8以及图像底部的8是毫无意义的，因为它们根本就是两八竿子打不着边的独立对象。<br>&emsp;肯定有一些方法能够使得神经网络具有足够的智能，能够知道图像中任何位置的8都是相同的，而不需要任何额外的训练。幸运的是，还真有！</p><h2 id="终极解决方法就是：卷积"><a href="#终极解决方法就是：卷积" class="headerlink" title="终极解决方法就是：卷积"></a>终极解决方法就是：卷积</h2><hr><p>&emsp;作为一个人类，你直观地知道图片具有层次结构或者概念结构。琢磨一下下面这张图片：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621041751194.png" alt=""><br></center><p>&emsp;生而为人，你可以立刻识别出这张图片的层次结构：</p><ul><li>这块地被混凝土以及草坪所覆盖</li><li>图中有个小男孩</li><li>小男孩坐在一只玩具马上面</li><li>玩具马在草坪上面</li></ul><p>&emsp;重点在于，无论这个孩子站在那种地表上（混凝土、草坪、瓷砖等等）我们都会意识到他的存在，也就是我们不用去学习各种孩子站在不同地表上的图像。<br>&emsp;但是现在，我们的神经网络无法做到这些。它认为相同的”8“（孩子）位于图像的不同位置（地表）是完全不同的情况。它无法明白在图片上移动一个对象并没有改变该对象的本质。这就意味这它必须再学习各种对象处于不同位置的图像。这真是逊👎爆了。</p><p>&emsp;我们需要让我们的神经网络理解<strong>平移不变性</strong>—-无论它出现再图片任何地方，8 就是 8。<br>&emsp;我们将用<strong>卷积</strong>来完成这项工作。这个方法的灵感来源于计算机科学与生物学（疯狂的科学家们用奇怪的探针来拨开猫脑以期弄清猫脑是如何处理图像的）。</p><h2 id="卷积的工作原理"><a href="#卷积的工作原理" class="headerlink" title="卷积的工作原理"></a>卷积的工作原理</h2><hr><p>&emsp;并非将整个图像网格的数字都喂入我们的神经网络，而是利用一些更加聪明的方法：无论一个对象位于图片的哪个位置，它还是它，并无二意。</p><p>&emsp;下面一步一步地介绍了卷积的工作过程。</p><h3 id="Step1-将图像分解为图像切片"><a href="#Step1-将图像分解为图像切片" class="headerlink" title="Step1: 将图像分解为图像切片"></a>Step1: 将图像分解为图像切片</h3><hr><p>&emsp;类似于我们用滑动的窗口在图片上扫描一样，让窗口在整个原始图像上扫描，并记录存储每次扫描到的小块区域图像。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621045304985.png" alt=""><br></center><p>通过这项工作，我们将上述图像分成了77块相同尺寸的小图切片。</p><h3 id="Step2-将每张图像切片馈送到一个小的神经网络中"><a href="#Step2-将每张图像切片馈送到一个小的神经网络中" class="headerlink" title="Step2: 将每张图像切片馈送到一个小的神经网络中"></a>Step2: 将每张图像切片馈送到一个小的神经网络中</h3><hr><p>&emsp;早些时候，我们将单个图片馈入一个神经网络并观察它的对数字8的输出判断。现在我们在做同样的事情，只不过现在我们输入的是一个个小的图像切片，而不是一整个图片：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621051040412.png" alt=""><br></center><p>&emsp;然而，这儿有一个大的区别是：我们将为同一原图片的每一个小的图像切片保留相同的神经网络权值。换句话说，我们将平等地对待每一张图像切片。如果在某一切片上有些特别的事情发生，我们将会标记它。</p><h3 id="Step3-将每一个切片的结果保存到一个新的阵列中"><a href="#Step3-将每一个切片的结果保存到一个新的阵列中" class="headerlink" title="Step3: 将每一个切片的结果保存到一个新的阵列中"></a>Step3: 将每一个切片的结果保存到一个新的阵列中</h3><hr><p>&emsp;我们不想失去各个切片的的原有顺序，所以我们将处理后的结果按顺序保存到一个与原始图像布局相同的网格中。就像这样：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621053454821.png" alt=""><br></center><p>换句话说，我们从一张大图片开始，最后我们用一个稍微小一点的阵列来记录我们原始图像的哪些部分是异常的。</p><h3 id="Step4-下采样"><a href="#Step4-下采样" class="headerlink" title="Step4: 下采样"></a>Step4: 下采样</h3><hr><p>&emsp;步骤3的结果是一个阵列，用来确定(maps out映射出来)原图的哪些位置是异常的。但是这个数组还是太大了：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621054338433.png" alt=""><br></center><p>&emsp;为了减少该阵列的尺寸，我们应用 <strong>最大池化算法(Max Pooling)</strong> 对它进行下采样。这听起来像是痴人说梦，但事实并非如此！</p><p>&emsp;我们将目光放在每一个$2\times 2$网格上并仅保留其中（4个数）的最大值：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621055250215.png" alt=""><br></center><p>&emsp;关键在于如果我们在构成每个$2\times 2$网格方块的四个输入图块中的任何一个中发现了一异常的东西，我们将保留最值得关注的那个。这样就可以减少阵列的大小，同时保留追重要的部分。</p><h3 id="Final-step-做一个预测"><a href="#Final-step-做一个预测" class="headerlink" title="Final step: 做一个预测"></a>Final step: 做一个预测</h3><hr><p>&emsp;到目前为止，我们已经将原始的巨大的图像阵列变成了一个相当小的阵列了。</p><p>&emsp;你猜怎么着？现在的阵列仅仅是一小堆数字而已，因此我们可以以它作为输入投喂到另一个神经网络中了。这个最终的神经网络将会决定该输入原始图像是否匹配。为了区别于卷积步骤，我们称它为<strong>” 全连接网络 “</strong>。</p><p>&emsp;所以从头到尾，我们的整个五步走战略看起来像这样：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621060953644.png" alt=""><br></center><h2 id="添油加醋"><a href="#添油加醋" class="headerlink" title="添油加醋"></a>添油加醋</h2><hr><p>&emsp;让我们在脑海中想象一下整个的一系列步骤：卷积、最大值池化、输入全连接网络。</p><p>&emsp;在现实世界中解决一个问题时，这些步骤可以被结合甚至可以根据需要堆叠多次！两个、三个、甚至10个卷积层都可以。你还可以应用最大值池化操作来缩小你的数据规模。</p><p>&emsp;最根本的想法时从一个大图像开始，一步一步地将其浓缩提取，知道你最终得到一个想要的结果。你的卷积操作越多，你的神经网络就会学习到更多的图像特性。</p><p>&emsp;举个栗子，第一次卷积操作可能让神经网络学习到了识别图像尖锐的边缘，第二次卷积操作就可能利用先前学到的有关尖锐边缘的知识去识别鸟的喙了，而第三次卷积则可能利用喙的知识来识别出整个鸟了，等等。</p><p>&emsp;下面是一个更符合实际的深度卷积神经网络（就像你会在研究论文中看到的一样）的样子：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621062641541.png" alt=""><br></center><p>&emsp;在上图的例子的神经网络中，它接受一个$224\times 224$像素大小的图像，其两次应用卷积和最大值池化，三次引用卷积操作并且拥有两层全连接层。最终的输出结果是对应1000中类别的概率。</p><h2 id="构建正确的网络"><a href="#构建正确的网络" class="headerlink" title="构建正确的网络"></a>构建正确的网络</h2><hr><p>&emsp;那么，你如何知道入药合并哪些步骤才能使你的神经网络（分类器）正常工作呢？<br>&emsp;老实说，想要正确地回答这个问题你不得不去做大量的试验和测试。在你遭到最佳的结构和参数去解决你的问题前，你也许不得不去训练100个神经网络。机器学习需要大量的反复试验。</p><h2 id="构建我们的鸟类分类器"><a href="#构建我们的鸟类分类器" class="headerlink" title="构建我们的鸟类分类器"></a>构建我们的鸟类分类器</h2><hr><p>&emsp;现在我们终于有足够的知识去编写一个可以识别鸟类（是鸟/不是鸟）的程序了。</p><p>&emsp;一如既往地，我们需要一些数据。免费的<a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR10 数据集</a>包含了6,000张鸟类的图片和52,000张非鸟类图片。但是为了得到更多的数据我们也将加入<a href="http://www.vision.caltech.edu/visipedia/CUB-200-2011.html" target="_blank" rel="noopener">Caltech-UCSD Birds-2002001 数据集</a>，它包含了12,000张鸟类的图片。</p><p>下面是一些我们将采用的数据集中的部分图像：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621064754607.png" alt=""><br></center><p>还有52,000张非鸟类图像中的一些：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190621064908713.png" alt=""><br></center><p>&emsp;这些数据集可以很好地应用在我们的目的上。但是72,000低分辨率的图像对于真实世界的应用来说仍然很小。如果你想让你的神经网络达到Google的级别的性能的话，你需要数以百万计的大图像。在机器学习领域，数据量的重要性几乎盖过了一个好的算法。现在你知道为什么Google热衷于为你提供图像存储服务了吧，他们要的是你的数据！</p><p>&emsp;为了构建我们的鸟类分类器，我们将使用python的<a href="http://tflearn.org/" target="_blank" rel="noopener">TFLearn</a>库，TFLearn是Google的<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">Tensorflow</a>深度学习库的包装器，它公开了一个简化了的API。这使得构建卷积神经网络变得像写几行代码来构建网络层一样简单。</p><p>下面的代码定义并训练了一个神经网络：</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">Based on the tflearn example located here:</span></span><br><span class="line"><span class="hljs-string">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_cifar10.py</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division, print_function, absolute_import</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 导入tflearn和其他函数库</span></span><br><span class="line"><span class="hljs-keyword">import</span> tflearn</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.data_utils <span class="hljs-keyword">import</span> shuffle</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.layers.core <span class="hljs-keyword">import</span> input_data, dropout, fully_connected</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.layers.conv <span class="hljs-keyword">import</span> conv_2d, max_pool_2d</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.layers.estimator <span class="hljs-keyword">import</span> regression</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.data_preprocessing <span class="hljs-keyword">import</span> ImagePreprocessing</span><br><span class="line"><span class="hljs-keyword">from</span> tflearn.data_augmentation <span class="hljs-keyword">import</span> ImageAugmentation</span><br><span class="line"><span class="hljs-keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 载入数据集</span></span><br><span class="line">X, Y, X_test, Y_test = pickle.load(open(<span class="hljs-string">"full_dataset.pkl"</span>, <span class="hljs-string">"rb"</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 将数据随机排序</span></span><br><span class="line">X, Y = shuffle(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 确保数据已标准化（处理数据）</span></span><br><span class="line">img_prep = ImagePreprocessing()</span><br><span class="line">img_prep.add_featurewise_zero_center()</span><br><span class="line">img_prep.add_featurewise_stdnorm()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 通过翻转，旋转，和模糊来创建额外的训练数据</span></span><br><span class="line">img_aug = ImageAugmentation()</span><br><span class="line">img_aug.add_random_flip_leftright()</span><br><span class="line">img_aug.add_random_rotation(max_angle=<span class="hljs-number">25.</span>)</span><br><span class="line">img_aug.add_random_blur(sigma_max=<span class="hljs-number">3.</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 定义我们的神经网络架构：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 输入为一张32x32像素的图片，有3个颜色通道(红、绿、蓝)</span></span><br><span class="line">network = input_data(shape=[<span class="hljs-keyword">None</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>],</span><br><span class="line">                     data_preprocessing=img_prep,</span><br><span class="line">                     data_augmentation=img_aug)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 1: 卷积</span></span><br><span class="line">network = conv_2d(network, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 2: 最大值池化</span></span><br><span class="line">network = max_pool_2d(network, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 3: 又一次卷积</span></span><br><span class="line">network = conv_2d(network, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 4: 又又一次卷积</span></span><br><span class="line">network = conv_2d(network, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 5: 又一次最大值池化</span></span><br><span class="line">network = max_pool_2d(network, <span class="hljs-number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 6: 拥有512个结点的全连接层，采用ReLU(修正线性函数)作激活函数</span></span><br><span class="line">network = fully_connected(network, <span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 7: Dropout - 在训练期间随机地丢弃一些数据防止过度拟合</span></span><br><span class="line">network = dropout(network, <span class="hljs-number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Step 8: 全连接神经网络具有两个输出结点 (0=非鸟, 1=是鸟) 用以做出最后的预测</span></span><br><span class="line">network = fully_connected(network, <span class="hljs-number">2</span>, activation=<span class="hljs-string">'softmax'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 告诉 tflearn 我们要如何训练神经网络</span></span><br><span class="line">network = regression(network, optimizer=<span class="hljs-string">'adam'</span>,</span><br><span class="line">                     loss=<span class="hljs-string">'categorical_crossentropy'</span>,</span><br><span class="line">                     learning_rate=<span class="hljs-number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 将网络包装在模型（model）对象中</span></span><br><span class="line">model = tflearn.DNN(network, tensorboard_verbose=<span class="hljs-number">0</span>, checkpoint_path=<span class="hljs-string">'bird-classifier.tfl.ckpt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 训练它 ！ 我们会做100次训练并随时监控它</span></span><br><span class="line">model.fit(X, Y, n_epoch=<span class="hljs-number">100</span>, shuffle=<span class="hljs-keyword">True</span>, validation_set=(X_test, Y_test),</span><br><span class="line">          show_metric=<span class="hljs-keyword">True</span>, batch_size=<span class="hljs-number">96</span>,</span><br><span class="line">          snapshot_epoch=<span class="hljs-keyword">True</span>,</span><br><span class="line">          run_id=<span class="hljs-string">'bird-classifier'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 当网络训练完成后，保存训练号的模型至文件中</span></span><br><span class="line">model.save(<span class="hljs-string">"bird-classifier.tfl"</span>)</span><br><span class="line">print(<span class="hljs-string">"Network trained and saved as bird-classifier.tfl!"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;如果你使用快拥有足够显存的显卡（比如Nividia GeForce GTX 980 或更好的），会在一个小时之内训练完成。如果你用的是普通的CPU的话，可能会耗费很长时间。<br>&emsp;随着训练的进行，模型的准确性会逐渐提高。第一轮训练过去后，我得到了75.4%的准确率。十轮过去后，已经有91.7%了。而在50轮后，达到了95.5的准确率。之后传统的训练再无提升，我便停止了训练。</p><p>&emps;恭喜恭喜！我们的程序已经可以识别鸟类图像啦！</p><h2 id="测试我们的网络"><a href="#测试我们的网络" class="headerlink" title="测试我们的网络"></a>测试我们的网络</h2><hr><p>&emsp;现如今我们有了一个传统的神经网络，我们可以利用它<a href="https://gist.github.com/ageitgey/a40dded08e82e59724c70da23786bbf0" target="_blank" rel="noopener">这里有个简单的脚本</a>可以向网络输入一个图片并预测改图中是否有鸟类。</p><p>&emsp;但是为了了解我们的神经网络的效能究竟如何，我们需要用更多的图片来测试它。我所创建的数据集保留了15,000图片以供验证。当我用15,000张图像测试神经网络时，他的预测准确率达到了95%。</p><p>&emsp;这个结果看起来很不错，事实真的如此吗？这得看情况！</p><h3 id="95的准确率究竟如何？"><a href="#95的准确率究竟如何？" class="headerlink" title="%95的准确率究竟如何？"></a>%95的准确率究竟如何？</h3><hr><p>&emsp;我们的神经网络声称具有95%的准确率。但是魔鬼常常隐藏在细节之中。这可能意味着各种各样的事故。</p><p>&emsp;举个栗子，如果我们的训练数据集中仅有5%的图片是鸟类而95%的图像是其他东西呢？当然，每次识别是不是鸟的准确率高达95%，但它明显毫无用处（一个程序即使每次都猜不是鸟，他的准确率也能达到95%）。</p><p>&emsp;相较于整体准确率，我们必须更多地关注数字本身。为了更好地判断分类系统的真正性能，我们必须更多地关注它的具体的错误情况，而不仅仅是他的错误率。</p><p>&emsp;让我们将神经网络的输出结果分成多种类别，而不是只是判断对错这两种情况：</p><ul><li>首先，这里有一些我们的神经网络能够正确地将其识别为鸟类的图片。姑且称它们为 <strong>真正类</strong>：</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622093310182.png" alt=""><br></center><ul><li>其次，这里有一些我们的神经网络能够准确地将其识别为非鸟类的图片。姑且称它们为 <strong>真负类</strong>：</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622093621421.png" alt=""><br></center><ul><li>再者，这里有一些被识别为是鸟但事实上不是鸟的图片（诸如飞机等），这些是我们的 <strong>假正类</strong>：</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622094325985.png" alt=""><br></center><ul><li>最后，这里有一些鸟类的图片，但却无法正确识别它们为鸟类。这些是我们的所谓 <strong>假负类</strong>：</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622094501144.png" alt=""><br></center><p>&emsp;利用我们的拥有15,000张图片的验证集，下面列出了我们的预测落入每一个类别的次数：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622094712678.png" alt=""><br></center><p>&emsp;为何我们要将结果拆分成这样？因为并非所有的错误都是相同的。</p><p>&emsp;现象一下如果想要编写一个程序从核磁共振图像中检测肿瘤。如果我们检测到癌症，我们宁愿它是假阳性而不是假阴性。假阴性或许是最糟糕的情况了（当程序告诉一个为患癌症的人他没有癌症时）。</p><p>&emsp;我们不仅仅考虑整体准确率，并且计算精度和召回指标。精度和召回的指标让我们更清楚地了解神经网络的具体表现：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9C%9F%E6%9C%89%E8%B6%A3-%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20190622095809899.png" alt=""><br></center><p>&emsp;我们的决定无比正确！上述结果告诉我们识别鸟类的准确率高达97%。但也告诉我们我们只正确识别了数据集中的的90.83%的鸟类图片。换句话说，我们也许并没有找到数据集中所有的鸟类图片，但当我们找到它时，我们的预测答案具有很高的准确度。</p><hr><h2 id="扬帆起航"><a href="#扬帆起航" class="headerlink" title="扬帆起航"></a>扬帆起航</h2><hr><p>&emsp;现在你已经对基本的深度神经网络有了了解，你可以尝试使用tflearn附带的一些示例，以便用不同的神经网络架构来解决问题。它甚至还带有内置的数据集，因此你甚至无需去寻找数据集。</p><p>&emsp;你也有足够的知识去学习机器学习的其它内容了。试试<a href="http://karpathy.github.io/2016/05/31/rl/" target="_blank" rel="noopener">如何用算法去训练计算机自己打雅达利游戏</a>如何？</p><blockquote><p>作者：Adam Geitgey<br>英文原文链接：<a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721" target="_blank" rel="noopener">Machine Learning is Fun! Part 3: Deep Learning and Convolutional Neural Networks</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近看了Adam Geitgey的机器学习系列文章。寻思着闲着也是闲着，干脆翻译以下，顺便学习下英语啥的哈哈哈。第一次做这种事，有不到位的地方欢迎指教噢。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-卷积神经网络(0)</title>
    <link href="https://www.ccyh.xyz/2019/06/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D(0)/"/>
    <id>https://www.ccyh.xyz/2019/06/19/机器学习-卷积神经网络介绍(0)/</id>
    <published>2019-06-19T10:12:58.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;作为本系列的第一篇文章，本文仅对卷积神经网络的工作过程做一个简单的介绍，并不涉及数学原理与推导。若想要深入了解数学原理，那么可以去查看相关文献或者我将会在之后更新相关内容的文章。</p></blockquote><a id="more"></a><blockquote><p>&emsp;阅读这篇文章前你最好对简单的神经网络有一定的了解，如果没有，可以参看博主的神经人工神经网络学习笔记系列文章。<br>如果你已经做好了准备，那就让我们开始吧！</p></blockquote><hr><h2 id="什么是卷积神经网络？"><a href="#什么是卷积神经网络？" class="headerlink" title="什么是卷积神经网络？"></a>什么是卷积神经网络？</h2><hr><p>&emsp;卷积神经网络（Convolutional Neural Network，CNN）是前馈人工神经网络的一种。在图像识别领域有着广泛的应用并且非常有效。当人们谈到计算机视觉时，通常都绕不开卷积神经网络。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/google.gif" alt="谷歌相册图像搜索"><br></center><hr><h2 id="计算机眼中的图像"><a href="#计算机眼中的图像" class="headerlink" title="计算机眼中的图像"></a>计算机眼中的图像</h2><hr><p>&emsp;毫无疑问，你可以很快分辨下图中的动物是只猫。但在计算机“眼中”，它仅仅是一个数字序列。图像由一个个像素组成，每一个像素通常以RGB(Red,Green,Blue)三原色表示。但为了简化，我们使用灰度（0-255）表示，仅仅一个数字就可以表示（0：黑色 255：白色）。如此一来，对于一张$200\times 200$像素的图片，在计算机眼中就为一个$200\times 200$的矩阵，也即一个$40000$维的向量。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619123229184.png" alt="计算机眼中的图像"><br></center><br>&emsp;计算机学习（训练）识别图像的过程就是将许多图片向量输入某种算法处理后将结果与目标值相比对，对误差进行修正直到结果输出令人满意为止。待训练结束后再给它看一个从未看过的图像它也能准确地识别图像的内容。<br>&emsp;本系列文章我们将继续使用Mnist数据集来训练和测试神经网络。<br><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/mnist_8.gif" alt="Mnist数据集"><br></center><hr><h2 id="LeNet框架（20世纪90年代）"><a href="#LeNet框架（20世纪90年代）" class="headerlink" title="LeNet框架（20世纪90年代）"></a>LeNet框架（20世纪90年代）</h2><hr><p>&emsp;LeNet框架是卷积神经网络的祖师爷LeCun在1998年提出的，用于解决手写数字识别的视觉任务。自那时起，CNN的最基本的架构就定下来了：卷积层、池化层、全连接层。本篇文章也将围绕该框架来进行卷积神经网络的介绍。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/lenet.jpg" alt="LeNet框架简图"><br></center><hr><h2 id="LeNet-卷积神经网络的工作过程"><a href="#LeNet-卷积神经网络的工作过程" class="headerlink" title="LeNet 卷积神经网络的工作过程"></a>LeNet 卷积神经网络的工作过程</h2><hr><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/lenet_cal.png" alt="卷积神经网络的计算过程"><br></center><hr><h3 id="1、卷积运算："><a href="#1、卷积运算：" class="headerlink" title="1、卷积运算："></a>1、卷积运算：</h3><hr><p>&emsp;顾名思义，卷积神经网络得名于“卷积”运算。在卷积神经网络中，卷积的主要目的是从目标图像中提取“特征”。通过使用输入数据中的小方块（矩阵分块）来学习图像特征，卷积运算保留了像素间的空间关系。<br>&emsp;正如前文所说，每个图像都可以被计算机看成是一个像素值矩阵。现仅考虑一个$5\times 5$像素的图像矩阵$W_{img}$：</p><p><div align="center"><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619045802129.png" alt=""><br></div><br>再令一个$3\times 3$的矩阵$W_{f}$：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619050403433.png" alt=""><br></center><br>将$3\times 3$的矩阵在$5\times 5$矩阵上移动并将对应位的数值相乘并求和，得到一个新的矩阵即为卷积运算后的特征值矩阵：<br><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/cnn_image_sample.gif" alt="卷积运算"><br></center><p>&emsp;这个由特征值组成的矩阵被称为 <strong>卷积特征</strong> 或 <strong>特征映射</strong> 。而上述参与卷积运算的$3\times 3$矩阵被称为 <strong>卷积滤波器</strong> 或 <strong>核</strong> 或 <strong>特征探测器</strong> （以下统称滤波器，但是事实上过滤器的作用就是原始图像的 <strong>特征检测器</strong>）。上述例子中过滤器在图像矩阵上每次移动1个像素单位，称为 <strong>步幅</strong> 。</p><p>&emsp;不难发现，不同的滤波器作用于相同图像上会得到不同的特征映射，下图列出了一些滤波器的取值以及功能作用(边缘检测，锐化等)：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619053433213.png" alt=""><br></center><p>&emsp;总的来说，一个滤波器在输入图像上移动（卷积操作）以生成特征映射。在同一张图像上，另一个滤波器的卷积生成了不同的特征图。需要注意到，卷积操作捕获原始图像中的局部依赖关系很重要。还要注意这两个不同的滤波器如何从同一张原始图像得到不同的特征图。请记住，以上图像和两个滤波器只是数值矩阵。<br>&emsp;实际上，卷积神经网络在训练过程中会自己学习这些滤波器的值（尽管在训练过程之前我们仍需要指定诸如滤波器数目、大小，网络框架等参数）。我们拥有的滤波器数目越多，提取的图像特征就越多，我们的网络在识别新图像时效果就会越好。</p><p>特征映射（卷积特征）的大小由我们在执行卷积步骤之前需要决定的三个参数控制：</p><ul><li><strong>深度：</strong>深度对应于我们用于卷积运算的过滤器数量。在图6所示的网络中，我们使用三个不同的过滤器对初始的船图像进行卷积，从而生成三个不同的特征图。可以将这三个特征地图视为堆叠的二维矩阵，因此，特征映射的“深度”为3。</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619054522781.png" alt="卷积操作"><br></center><ul><li><strong>步幅：</strong>步幅是我们在输入矩阵上移动一次过滤器矩阵的像素数量。当步幅为1时，我们一次将过滤器移动1个像素。当步幅为2时，过滤器每次移动2个像素。步幅越大，生成的特征映射越小。</li><li><strong>零填充：</strong>有时，将输入矩阵边界用零来填充会很方便，这样我们可以将过滤器应用于输入图像矩阵的边界元素。零填充一个很好的特性是它允许我们控制特征映射的大小。添加零填充也称为宽卷积，而不使用零填充是为窄卷积。</li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619055337351.png" alt="边界零填充"><br></center><hr><h3 id="2、非线性操作（ReLU操作）"><a href="#2、非线性操作（ReLU操作）" class="headerlink" title="2、非线性操作（ReLU操作）"></a>2、非线性操作（ReLU操作）</h3><hr><p>&emsp;每次卷积操作之后，都会进行一次ReLU操作，其全称为修正线性单元（Rectified Linear Unit),是一种非线性操作。以下为修正线性函数的图像及表达式：</p><p>$$<br>f(x)=\begin{cases}<br>0, &amp; x&lt;0 \\<br>x, &amp; otherwise<br>\end{cases}<br>$$</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/ReLU.png" alt="修正线性函数"><br></center><p>&emsp;ReLU 是一个针对元素的操作（应用于每个像素），并将特征映射中的所有负像素值替换为零。ReLU 的目的是在卷积神经网络中引入非线性因素，因为在实际生活中我们想要用神经网络学习的数据大多数都是非线性的（卷积是一个线性运算 —— 按元素进行矩阵乘法和加法，所以我们希望通过引入 ReLU 这样的非线性函数来解决非线性问题）。<br>从可以很清楚地理解 ReLU 操作。它展示了将 ReLU 作用于某个特征映射得到的结果。这里的输出特征映射也被称为“修正”特征映射。</p><center><br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/relu_op.png" alt="修正线性函数"><br></center><p>其他非线性函数如 <strong>Sigmoid</strong> 或 <strong>tanh</strong> 也能达到类似效果，但是 <strong>ReLU</strong> 函数的效果是最好的。</p><hr><h3 id="3、池化（Pooling）"><a href="#3、池化（Pooling）" class="headerlink" title="3、池化（Pooling）"></a>3、池化（Pooling）</h3><hr><p>&emsp;空间池化（也称为子采样或下采样）可降低每个特征映射的维度，并保留最重要的信息。空间池化有几种不同的方式：<strong>最大值，平均值，求和等</strong>。</p><p>&emsp;在最大池化的情况下，我们定义一个空间邻域（例如一个2 × 2窗口），并取修正特征映射在该窗口内最大的元素。当然我们也可以取该窗口内所有元素的平均值（<strong>平均池化</strong>）或所有元素的总和。在实际运用中，<strong>最大池化</strong> 的表现更好。<br>&ensp;下图展示了通过2 × 2窗口在修正特征映射（卷积+ ReLU 操作后得到）上应用最大池化操作的示例:</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072042438.png" alt="Pooling"><br></center><p>&emsp;我们将2 x 2窗口移动2个单元格（也称为“步幅”），并取每个区域中的最大值。如图9所示，这样就降低了特征映射的维度,变成了一个$2\times 2$的矩阵。<br>&emsp;由于池化操作分别应用于每个特征映射（因此，我们从三个输入映射中得到了三个输出映射）。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072936964.png" alt="在修正后的特征映射上应用池化"><br></center><p>两种池化方法的结果对比：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619072355283.png" alt="Pool Diffrent"><br></center><p>&emsp;池化的作用是逐步减少输入的空间大小。具体来说有以下四点：</p><ul><li>使输入（特征维度）更小，更易于管理</li><li>减少网络中的参数和运算次数，因此可以控制过拟合</li><li>使网络对输入图像微小的变换、失真和平移更加稳健（输入图片小幅度的失真不会改池化的输出结果 —— 因为我们取了邻域的最大值/平均值）</li><li>可以得到尺度几乎不变的图像（确切的术语是“等变”）。这是非常有用的，这样无论图片中的物体位于何处，我们都可以检测到</li></ul><p>&emsp;目前为止，我们已经了解了卷积神经网络中 <strong>卷积</strong>、<strong>ReLU</strong>、<strong>池化</strong> 的工作原理。这一点非常重要，下面我们将举例来描述这一过程。</p><hr><h2 id="可视化卷积神经网络"><a href="#可视化卷积神经网络" class="headerlink" title="可视化卷积神经网络"></a>可视化卷积神经网络</h2><hr><p>&emsp;Adam Harley 创建了一个基于 MNIST 手写数字数据集训练卷积神经网络的可视化。我强烈推荐大家 使用它来了解卷积神经网络的工作细节。其链接如下,可以自行尝试：</p><ul><li><a href="http://scs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">2D Visualization of a Convolutional Neural Network.</a></li></ul><hr><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619074946589.png" alt=""><br></center><hr><h3 id="1、卷积层"><a href="#1、卷积层" class="headerlink" title="1、卷积层"></a>1、卷积层</h3><p>&emsp;将鼠标放在卷积层的某个像素点上并点击会出现：</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619075722203.png" alt=""><br></center><hr><h3 id="2、池化层"><a href="#2、池化层" class="headerlink" title="2、池化层"></a>2、池化层</h3><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080251028.png" alt=""><br></center><hr><h3 id="3、全连接层"><a href="#3、全连接层" class="headerlink" title="3、全连接层"></a>3、全连接层</h3><p>&emsp;全连接层的每一个结点都与其前一层的每一个结点相连接。</p><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080952782.png" alt=""><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%E7%BA%A7%E4%BB%8B%E7%BB%8D/20190619080746017.png" alt=""><br></center><hr><p>&emsp;该可视化项目还有3D版的，大家可以去玩玩，对于加深理解很有帮助。</p><hr><h2 id="卷积神经网络如何学习？"><a href="#卷积神经网络如何学习？" class="headerlink" title="卷积神经网络如何学习？"></a>卷积神经网络如何学习？</h2><hr><p>Waiting for update …</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;作为本系列的第一篇文章，本文仅对卷积神经网络的工作过程做一个简单的介绍，并不涉及数学原理与推导。若想要深入了解数学原理，那么可以去查看相关文献或者我将会在之后更新相关内容的文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（3）</title>
    <link href="https://www.ccyh.xyz/2019/06/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/07/人工神经网络学习笔记（3）/</id>
    <published>2019-06-07T12:02:15.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python-numpy编码实现人工神经网络"><a href="#Python-numpy编码实现人工神经网络" class="headerlink" title="Python-numpy编码实现人工神经网络"></a>Python-numpy编码实现人工神经网络</h3><hr><p>前面的几篇文章我们熟悉了人工神经网络的数学原理及其推导过程，但有道是‘纸上得来终觉浅’，是时候将理论变为现实了。现在我们将应用Python语言以及其强大的扩充程序库<a href="https://www.runoob.com/numpy/numpy-tutorial.html" target="_blank" rel="noopener">Numpy</a>来编写一个简单的神经网络。<br><a id="more"></a></p><hr><h4 id="准备数据："><a href="#准备数据：" class="headerlink" title="准备数据："></a>准备数据：</h4><ul><li><strong>训练集and测试集：</strong><a href="git@github.com:makeyourownneuralnetwork/makeyourownneuralnetwork.git">Mnist手写数字数据集(复制git链接克隆)</a>MINST数据库是由米国机器学习大佬Yann提供的手写数字数据库文件，其官方下载地址<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Download Mnist</a>。该数据集将会是神经网络的输入信号。</li></ul><p>每一张图片像素都为$28\times 28$,因此可作为一个$784\times 1$的向量传入神经网络。</p><div align="center"><br><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607010119916.png" alt="单个图片"><br><img src="/人工神经网络学习笔记（3）/20190607015526334.png" alt=""><br><br></div><ul><li>初始花链接权重矩阵：使用正态概率分布采样权重，平均值为0，标准方差为结点传入链接数目的开方，即$\frac{1}{\sqrt{inputconnects}}$</li></ul><hr><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>下面的代码实现了一个双隐层的神经网络，但是它的表现并不好（最起码在Mnist数据集的表现上差强人意），我训练了5个小时（5世代）也只能达到%96.54的准确率。相比而言当隐层的神经网络在Mnist数据集上的表现更好，三个小时（5世代）可以达到%97.34的准确率。你可以注释掉下面的部分代码将其退回到单隐层结构甚至加到三隐层结构。虽然代码写的很乱但代码中每一句都有详细的注释，别介意哈哈哈。<br>包含两个源代码文件：</p><ul><li>neural_network.py 包含神经网络主类用于训练神经网络</li><li>network_test.py 用于测试神经网络</li></ul><hr> <font size="3px" face="黑体" color="green"> neural_network.py </font><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.special</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.ndimage.interpolation</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">import</span> progressbar</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> anim</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 神经网络类定义</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">neuralNetwork</span>:</span></span><br><span class="line"><span class="hljs-comment"># 初始化神经网络</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,inputnodes,hiddennodes,hiddennodes_2,outputnodes,learningrate)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 设置神经网络的输入层、隐藏层、输出层、的结点数和学习率</span></span><br><span class="line">self.inodes = inputnodes</span><br><span class="line">self.hnodes = hiddennodes                <span class="hljs-comment"># 第一隐藏层结点数</span></span><br><span class="line">self.hnodes_2 = hiddennodes_2            <span class="hljs-comment"># 第二隐藏层结点数</span></span><br><span class="line"><span class="hljs-comment">#self.hnodes_3 = hiddennodes_3            # 第三隐藏层结点数</span></span><br><span class="line">self.onodes = outputnodes</span><br><span class="line"><span class="hljs-comment"># 学习率</span></span><br><span class="line">self.lr = learningrate</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># （常规版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络）</span></span><br><span class="line">self.wih = (numpy.random.rand(hiddennodes,inputnodes)<span class="hljs-number">-0.5</span>)            </span><br><span class="line">self.who = (numpy.random.rand(outputnodes,hiddennodes)<span class="hljs-number">-0.5</span>)           </span><br><span class="line"><span class="hljs-comment"># （进阶版）链接权重矩阵,随机权重在-0.5至0.5之间（三层神经网络）</span></span><br><span class="line">self.wih_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.hnodes,<span class="hljs-number">-0.5</span>),(hiddennodes,inputnodes))          <span class="hljs-comment"># 输入层到第一隐藏层权重矩阵</span></span><br><span class="line">self.wh12_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.hnodes_2,<span class="hljs-number">0.5</span>),(hiddennodes_2,hiddennodes))     <span class="hljs-comment"># 第一隐藏层到第二隐藏层权重矩阵</span></span><br><span class="line"><span class="hljs-comment">#self.wh23_ = numpy.random.normal(0.0,pow(self.hnodes_3,0.5),(hiddennodes_3,hiddennodes_2))   # 第二隐藏层到第三隐藏层权重矩阵</span></span><br><span class="line">self.who_ = numpy.random.normal(<span class="hljs-number">0.0</span>,pow(self.onodes,<span class="hljs-number">-0.5</span>),(outputnodes,hiddennodes_2))         <span class="hljs-comment"># 第三隐藏层到输出层权重矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#定义激活函数，由scipy库提供</span></span><br><span class="line">self.activation_function = <span class="hljs-keyword">lambda</span> x : scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 训练神经网络</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(self,inputs_list,targets_list)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 将输入信号列表和目标信号列表转换成列向量</span></span><br><span class="line">inputs = numpy.array(inputs_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line">targets = numpy.array(targets_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第一隐藏层的输入信号：</span></span><br><span class="line">hidden_inputs = numpy.dot(self.wih_,inputs)</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层的输出信号（激活函数作用）：</span></span><br><span class="line">hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层的输入信号:</span></span><br><span class="line">hidden_inputs_2 = numpy.dot(self.wh12_,hidden_outputs)</span><br><span class="line"><span class="hljs-comment"># 第二层隐藏层的输出信号：</span></span><br><span class="line">hidden_outputs_2 = self.activation_function(hidden_inputs_2)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输入信号：</span></span><br><span class="line"><span class="hljs-string">hidden_inputs_3 = numpy.dot(self.wh23_,hidden_outputs_2)</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输出信号：</span></span><br><span class="line"><span class="hljs-string">hidden_outputs_3 = self.activation_function(hidden_inputs_3)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 输出层的输入信号：</span></span><br><span class="line">final_inputs = numpy.dot(self.who_,hidden_outputs_2)</span><br><span class="line"><span class="hljs-comment"># 输出层的输出信号：</span></span><br><span class="line">final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 计算输出层误差向量</span></span><br><span class="line">output_errors = targets - final_outputs</span><br><span class="line"><span class="hljs-comment"># 计算第三隐藏层误差向量</span></span><br><span class="line"><span class="hljs-comment">#hidden_errors_3 = numpy.dot(self.who_.T,output_errors)</span></span><br><span class="line"><span class="hljs-comment"># 计算第二隐藏层的误差向量</span></span><br><span class="line">hidden_errors_2 = numpy.dot(self.who_.T,output_errors)</span><br><span class="line"><span class="hljs-comment"># 计算第一隐藏层的误差向量</span></span><br><span class="line">hidden_errors = numpy.dot(self.wh12_.T,hidden_errors_2)</span><br><span class="line"></span><br><span class="line"><span class="hljs-string">''' 优化链接权重值 '''</span></span><br><span class="line"><span class="hljs-comment"># 第三隐藏层与输出层间的链接权重优化</span></span><br><span class="line"><span class="hljs-comment">#self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)),numpy.transpose(hidden_outputs_3))</span></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层与第三隐藏层间的链接权重优化</span></span><br><span class="line">self.who_ += self.lr * numpy.dot((output_errors * final_outputs * (<span class="hljs-number">1.0</span> - final_outputs)),numpy.transpose(hidden_outputs_2))</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层与第二隐藏层间的链接权重优化</span></span><br><span class="line">self.wh12_ += self.lr * numpy.dot((hidden_errors_2 * hidden_outputs_2 * (<span class="hljs-number">1.0</span> - hidden_outputs_2)),numpy.transpose(hidden_outputs))</span><br><span class="line"><span class="hljs-comment"># 输入层与第一隐藏层间的链接权重优化</span></span><br><span class="line">self.wih_ += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="hljs-number">1.0</span> - hidden_outputs)),numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#return self.query(inputs_list)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 查询</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span><span class="hljs-params">(self,inputs_list)</span>:</span></span><br><span class="line"><span class="hljs-comment"># 将输入列表转成numpy向量对象并转置为列向量</span></span><br><span class="line">inputs = numpy.array(inputs_list,ndmin=<span class="hljs-number">2</span>).T</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层结点的输入信号：权重矩阵与输入信号向量的乘积</span></span><br><span class="line">self.hidden_inputs = numpy.dot(self.wih_,inputs)</span><br><span class="line"><span class="hljs-comment"># 第一隐藏层结点的输出信号：经过S函数的加权求和值</span></span><br><span class="line">self.hidden_outputs = self.activation_function(self.hidden_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 第二隐藏层的输入信号:</span></span><br><span class="line">self.hidden_inputs_2 = numpy.dot(self.wh12_,self.hidden_outputs)</span><br><span class="line"><span class="hljs-comment"># 第二层隐藏层的输出信号：</span></span><br><span class="line">self.hidden_outputs_2 = self.activation_function(self.hidden_inputs_2)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输入信号：</span></span><br><span class="line"><span class="hljs-string">self.hidden_inputs_3 = numpy.dot(self.wh23_,self.hidden_outputs_2)</span></span><br><span class="line"><span class="hljs-string"># 第三隐藏层的输出信号：</span></span><br><span class="line"><span class="hljs-string">self.hidden_outputs_3 = self.activation_function(self.hidden_inputs_3)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 输出层结点的输入信号：</span></span><br><span class="line">self.final_inputs = numpy.dot(self.who_,self.hidden_outputs_2)</span><br><span class="line"><span class="hljs-comment"># 输出层结点的最终输出信号：</span></span><br><span class="line">self.final_outputs = self.activation_function(self.final_inputs)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 返回最终输出信号</span></span><br><span class="line"><span class="hljs-keyword">return</span> self.final_outputs</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(Network,test_dataset_name)</span>:</span></span><br><span class="line">Network.wih_ = numpy.loadtxt(<span class="hljs-string">'wih_file.csv'</span>)</span><br><span class="line">Network.wh12_ = numpy.loadtxt(<span class="hljs-string">'wh12_file.csv'</span>)</span><br><span class="line"><span class="hljs-comment">#Network.wh23_ = numpy.loadtxt('wh23_file.csv')</span></span><br><span class="line">Network.who_ = numpy.loadtxt(<span class="hljs-string">'who_file.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 准备测试数据</span></span><br><span class="line">test_data_file = open(test_dataset_name,<span class="hljs-string">'r'</span>)</span><br><span class="line">test_data_list = test_data_file.readlines()</span><br><span class="line">test_data_file.close()</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">'\n'</span>)</span><br><span class="line">print(<span class="hljs-string">"Testing...\n"</span>)</span><br><span class="line"><span class="hljs-comment"># 统计</span></span><br><span class="line">correct_test = <span class="hljs-number">0</span></span><br><span class="line">all_test = <span class="hljs-number">0</span></span><br><span class="line">correct = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</span><br><span class="line">num_counter = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#测试进度条</span></span><br><span class="line">p_test = progressbar.ProgressBar()</span><br><span class="line">p_test.start(len(test_data_list))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 动画显示</span></span><br><span class="line"><span class="hljs-comment">#plt.figure(1)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> imag_list <span class="hljs-keyword">in</span> test_data_list:</span><br><span class="line">all_values = imag_list.split(<span class="hljs-string">','</span>)</span><br><span class="line">lable = int(all_values[<span class="hljs-number">0</span>])</span><br><span class="line">scaled_input = (numpy.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span></span><br><span class="line">imag_array = numpy.asfarray(scaled_input).reshape((<span class="hljs-number">28</span>,<span class="hljs-number">28</span>))</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">plt.imshow(imag_array,cmap='Greys',animated=True)</span></span><br><span class="line"><span class="hljs-string">plt.draw()</span></span><br><span class="line"><span class="hljs-string">plt.pause(0.00001)</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line">net_answer = Network.query(scaled_input).tolist().index(max(Network.final_outputs))</span><br><span class="line">num_counter[lable] += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> lable == int(net_answer):</span><br><span class="line">correct_test += <span class="hljs-number">1</span></span><br><span class="line">correct[lable] += <span class="hljs-number">1</span></span><br><span class="line">p_test.update(all_test + <span class="hljs-number">1</span>)</span><br><span class="line">all_test += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">p_test.finish()</span><br><span class="line">print(<span class="hljs-string">"Finish Test.\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 网络性能</span></span><br><span class="line">performance = correct_test/all_test</span><br><span class="line">Per_num_performance = []</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):</span><br><span class="line"><span class="hljs-comment"># 测试集可能不包含某些数字，故捕捉除以0异常</span></span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">Per_num_performance.append(correct[i]/num_counter[i])</span><br><span class="line"><span class="hljs-keyword">except</span> ZeroDivisionError:</span><br><span class="line">Per_num_performance.append(<span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"The correctRate of per number： "</span>,Per_num_performance)</span><br><span class="line">print(<span class="hljs-string">"Performance of the NeuralNetwork： "</span>,performance*<span class="hljs-number">100</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> performance</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 定义网络规模与学习率</span></span><br><span class="line">input_nodes = <span class="hljs-number">784</span></span><br><span class="line">hidden_nodes = <span class="hljs-number">700</span></span><br><span class="line">hidden_nodes_2 = <span class="hljs-number">700</span></span><br><span class="line"><span class="hljs-comment">#hidden_nodes_3 = 100</span></span><br><span class="line">output_nodes = <span class="hljs-number">10</span></span><br><span class="line">learningrate = <span class="hljs-number">0.0001</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 定义训练世代数</span></span><br><span class="line">epochs = <span class="hljs-number">5</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建神经网络实例</span></span><br><span class="line">Net = neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#plt.imshow(final_outputs,interpolation="nearest")</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 准备训练数据</span></span><br><span class="line">data_file = open(<span class="hljs-string">"mnist_train.csv"</span>,<span class="hljs-string">'r'</span>)</span><br><span class="line">data_list = data_file.readlines()</span><br><span class="line">N_train = len(data_list)</span><br><span class="line">data_file.close()</span><br><span class="line"><span class="hljs-comment"># 动画显示</span></span><br><span class="line"><span class="hljs-comment">#plt.figure(1)</span></span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"Training："</span>, epochs, <span class="hljs-string">"epochs..."</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> range(epochs):</span><br><span class="line"><span class="hljs-comment"># 训练进度条</span></span><br><span class="line">print(<span class="hljs-string">'\nThe '</span>+str(e+<span class="hljs-number">1</span>)+<span class="hljs-string">'th epoch trainning:\n'</span>)</span><br><span class="line">p_train = progressbar.ProgressBar()</span><br><span class="line">p_train.start(N_train)</span><br><span class="line">i = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> img_list <span class="hljs-keyword">in</span> data_list:</span><br><span class="line"><span class="hljs-comment"># 以逗号分割记录</span></span><br><span class="line">all_values = img_list.split(<span class="hljs-string">','</span>)</span><br><span class="line"><span class="hljs-comment"># 将0-255映射到0.01-0.99</span></span><br><span class="line">scaled_input = (numpy.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span></span><br><span class="line">imag_array = numpy.asfarray(scaled_input).reshape((<span class="hljs-number">28</span>,<span class="hljs-number">28</span>))</span><br><span class="line"><span class="hljs-comment">#plt.imshow(imag_array,cmap='Greys',animated=True)</span></span><br><span class="line"><span class="hljs-comment">#plt.draw()</span></span><br><span class="line"><span class="hljs-comment">#plt.pause(0.00001)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#旋转图像生成新的训练集</span></span><br><span class="line">input_plus_10imag = scipy.ndimage.interpolation.rotate(imag_array,<span class="hljs-number">10</span>,cval=<span class="hljs-number">0.01</span>,reshape=<span class="hljs-keyword">False</span>)</span><br><span class="line">input_minus_10imag = scipy.ndimage.interpolation.rotate(imag_array,<span class="hljs-number">-10</span>,cval=<span class="hljs-number">0.01</span>,reshape=<span class="hljs-keyword">False</span>)</span><br><span class="line">input_plus10 = input_plus_10imag.reshape((<span class="hljs-number">1</span>,<span class="hljs-number">784</span>))</span><br><span class="line">input_minus10 = input_minus_10imag.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">784</span>))</span><br><span class="line"><span class="hljs-comment"># 根据标签创建目标值向量</span></span><br><span class="line">targets = numpy.zeros(output_nodes) + <span class="hljs-number">0.01</span></span><br><span class="line">targets[int(all_values[<span class="hljs-number">0</span>])] = <span class="hljs-number">0.99</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 用三个训练集训练神经网络</span></span><br><span class="line">Net.train(scaled_input,targets)</span><br><span class="line">Net.train(input_plus10,targets)</span><br><span class="line">Net.train(input_minus10,targets)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#time.sleep(0.01)</span></span><br><span class="line">p_train.update(i+<span class="hljs-number">1</span>)</span><br><span class="line">i+=<span class="hljs-number">1</span></span><br><span class="line">p_train.finish()</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"\nTrainning finish.\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 将训练好的神经网络链接权重输出到csv文件中</span></span><br><span class="line">numpy.savetxt(<span class="hljs-string">'wih_file.csv'</span>,Net.wih_,fmt=<span class="hljs-string">'%f'</span>)</span><br><span class="line">numpy.savetxt(<span class="hljs-string">'wh12_file.csv'</span>,Net.wh12_,fmt=<span class="hljs-string">'%f'</span>)</span><br><span class="line"><span class="hljs-comment">#numpy.savetxt('wh23_file.csv',Net.wh23_,fmt='%f')</span></span><br><span class="line">numpy.savetxt(<span class="hljs-string">'who_file.csv'</span>,Net.who_,fmt=<span class="hljs-string">'%f'</span>)</span><br></pre></td></tr></table></figure> <font face="黑体" size="3px" color="green"> network_test.py </font><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> neural_network <span class="hljs-keyword">as</span> nk</span><br><span class="line"><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pl</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.special</span><br><span class="line"><span class="hljs-keyword">import</span> scipy.ndimage.interpolation</span><br><span class="line"><span class="hljs-keyword">import</span> json</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">import</span> progressbar</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 测试神经网络</span></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">input_nodes = nk.input_nodes</span><br><span class="line">hidden_nodes = nk.hidden_nodes</span><br><span class="line">hidden_nodes_2 = nk.hidden_nodes_2</span><br><span class="line"><span class="hljs-comment">#hidden_nodes_3 = nk.hidden_nodes_3</span></span><br><span class="line">output_nodes = nk.output_nodes</span><br><span class="line">learningrate = nk.learningrate</span><br><span class="line">Network = nk.neuralNetwork(input_nodes,hidden_nodes,hidden_nodes_2,output_nodes,learningrate)</span><br><span class="line">nk.test(Network,<span class="hljs-string">"mnist_test.csv"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># hidden_nodes = 200 lr = 0.01 performance = 97.34</span></span><br></pre></td></tr></table></figure><hr><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><ol><li>cd进入代码所在文件夹</li><li>(训练神经网络)输入命令：<font color="green" face="黑体">python</font> <font color="blue" face="黑体">neural_network.py</font></li></ol><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607011216578.png" alt="Training"></p><ol start="3"><li>（测试神经网络）输入命令：<font color="green" face="黑体">python</font> <font color="blue" face="黑体">network_test.py</font></li></ol><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/20190607011510082.png" alt="Testing"></p><font size="1px" color="red">[Warning] 运行时请确保训练集和测试集数据的.csv文件与源代码文件在同一个目录下，否则请修改源码中的文件路径</font>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python-numpy编码实现人工神经网络&quot;&gt;&lt;a href=&quot;#Python-numpy编码实现人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;Python-numpy编码实现人工神经网络&quot;&gt;&lt;/a&gt;Python-numpy编码实现人工神经网络&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;前面的几篇文章我们熟悉了人工神经网络的数学原理及其推导过程，但有道是‘纸上得来终觉浅’，是时候将理论变为现实了。现在我们将应用Python语言以及其强大的扩充程序库&lt;a href=&quot;https://www.runoob.com/numpy/numpy-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numpy&lt;/a&gt;来编写一个简单的神经网络。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（2）</title>
    <link href="https://www.ccyh.xyz/2019/06/04/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/04/人工神经网络学习笔记（2）/</id>
    <published>2019-06-04T10:02:53.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何更新权重"><a href="#如何更新权重" class="headerlink" title="如何更新权重"></a>如何更新权重</h3><p>在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？<br><a id="more"></a></p><ul><li><strong>暴力枚举：</strong>对于一个三层的神经网络，每层有3个神经元结点，有两个$3\times 3$的链接权重矩阵，共有18个权重值。假设每个权重在1和-1之间共有1000种取值，那么我们有$1000^{18}$种权重组合，这个数字已经很大了。但是，如果是每层有500个结点呢？那么权重数将达到$2\times 500\times 500 = 500000$个，将会有$1000^{500000}$种组合。想要遍历这么些种可能得等到人类灭绝…</li></ul><p>可见，暴力枚举并不能实际地解决我们的问题。</p><ul><li><strong>新的思路：</strong>让我们再次明确下我们的最终目的，让误差值降到最小。试着将其转化成数学上的求函数最小值问题。先前我们知道，误差是所有链接权重的函数:<br>$$<br>Error = F_{error}(w_{1,1},w_{2,1},……,w_{j,k})<br>$$<br>现在我们需要额就是找出该函数的最小值。但由于真正的误差函数的自变量太多，先举个简单的例子：<br>假设误差函数只有一个自变量（链接权重）：<br>$$<br>E_{simple}=F_e(x)<br>$$<br>其图像为：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604110727225.png" alt=""><br>可以将其想象成一个连绵的山脉，有山峰也有山谷。设想将一个小球至于山腰，那么在重力的作用下它必定沿着所在位置的斜率方向向下滚动直到山谷。但是很明显，我们并没有重力帮忙，因此必须人为指定“滚动方向”。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604112226207.png" alt=""><br>不难发现，当斜率为正时应向左滚动（x–），斜率为负时应向右滚动（x++）。这种方法在数学上被称为梯度下降（gradient descent）。<br><strong>可能的意外情况：</strong><br>我们可能会碰到这种情况：当小球的起始位置为左侧山腰时，其很有可能最终会在局部最小值（左侧的山谷）停下，这可不是我们所希望的结果。因为我们的目的是把误差降到最小，那里显然不是最小的地方。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604114310137.png" alt=""><br>为了避免上述情况，我们应从选择不同的其实位置对神经网络进行多次训练，以确保其并不总是终止于错误的地方。而不同的其实位置意味着不同的链接权重。</li></ul><hr><h3 id="选择误差函数的形式"><a href="#选择误差函数的形式" class="headerlink" title="选择误差函数的形式"></a>选择误差函数的形式</h3><p>可选项：</p><ol><li>$E=t_n-o_n$  (目标值 - 期望值)</li><li>$E=(t_n-o_n)^2$  方差形式</li></ol><p>我们选用方差形式，因为其具有很多优点：</p><ol><li>可以很容易地使用代数方法（链式法则求解偏导数）计算出梯度下降的斜率</li><li>误差函数平滑连续，这使得梯度下降算法可以很好地发挥作用</li><li>越接近最小值梯度（斜率）越小，按照斜率调整步长可以减少越过最佳位置的风险</li></ol><hr><h3 id="计算梯度值（斜率）"><a href="#计算梯度值（斜率）" class="headerlink" title="计算梯度值（斜率）"></a>计算梯度值（斜率）</h3><ul><li>当只有一个链接权重时，误差函数为二维曲线：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604012324203.png" alt=""><br>$$<br>k=\frac{\partial{E}}{\partial{x}}<br>$$</li><li>当有两个链接权重时，误差函数为一个三维曲面：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1559636048297&amp;di=a69a0ac50c0c4c39c6290d14fe697429&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.ph.126.net%2FwdlmGd6Cl2EyG0Bp-xEihQ%3D%3D%2F1016406140918957318.jpg" alt=""><br>$$<br>k=\frac{\partial{E}}{\partial{w_{j,k}}}<br>$$<br>上述表达式表示了当权重$w_{j,k}$改变时，误差$E$是如何改变的。这是误差函数的斜率，也就是我们希望使用梯度下降的方法达到最小值的方向。</li></ul><p><strong>计算梯度：</strong></p><ol><li>在开始计算前我们回顾一下网络中各个参数的意义：<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/20190604014334436.png" alt=""></li><li>展开误差函数：<br>由于一个结点的误差只与与其相连的链接权重有关，因此误差函数可以简单地表示为：<br>$$<br>E=(t_k-o_k)^2<br>$$<br>其中：$o_k=Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})$所以：<br>$$<br>E=(t_k-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))^2<br>$$<br>所以：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=\frac{\partial{(t_k-o_k)^2}}{\partial{w_{j,k}}}<br>$$<br>$$<br>=\frac{\partial{E}}{\partial{o_k}}\cdot \frac{\partial{o_k}}{\partial{w_{j,k}}}=-2(t_k-o_k)\cdot \frac{\partial{o_k}}{\partial{w_{j,k}}}<br>$$<br>其中：令$x=\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}$<br>$$<br>\frac{\partial{o_k}}{\partial{w_{j,k}}}=\frac{\partial{Sig(x)}}{\partial{w_{j,k}}}=\frac{\partial{Sig(x)}}{\partial{x}}\cdot \frac{\partial{x}}{\partial{w_{j,k}}}<br>$$<br>且：<br>$$<br>\frac{\partial{Sig(x)}}{\partial{x}}=Sig(x)\cdot (1-Sig(x))<br>$$<br>因此，我们得到了以下表达式：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=-2(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot \frac{\partial{(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}})}{\partial{w_{j,k}}}<br>$$<br>$$<br>=-2(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$<br>又由于我们只关心误差函数斜率的方向，因此可以将公式中的常数2省略，并不影响正负号：<br>$$<br>\frac{\partial{E}}{\partial{w_{j,k}}}=-(t_k-o_k)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$<br>$$<br>=-(e_j)\cdot Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}})\cdot (1-Sig(\sum_{j=1}^{n}{w_{j,k}\cdot o_{hj}}))\cdot o_{hj}<br>$$</li></ol><h3 id="改变链接权重"><a href="#改变链接权重" class="headerlink" title="改变链接权重"></a>改变链接权重</h3><p>之前提到过，权重的改变方向与梯度的方向相反。因此我们规定权重的改变方式为：<br>$$<br>w_{j,k}^{new}=w_{j,k}^{old}-\alpha \cdot \frac{\partial{E}}{\partial{w_{j,k}}}<br>$$<br>参数释义：</p><ul><li>$\alpha$为学习因子，可以调节这些权重变化的强度</li></ul><p><strong>用矩阵来简化运算：</strong><br>$$<br>\left(<br>\begin{matrix}<br>\vartriangle w_{1,1} &amp; \vartriangle w_{2,1} &amp; \vartriangle w_{3,1} &amp; …\\<br>\vartriangle w_{1,2} &amp; \vartriangle w_{2,2} &amp; \vartriangle w_{3,2} &amp; …\\<br>\vartriangle w_{1,3} &amp; \vartriangle w_{2,3} &amp; \vartriangle w_{3,3} &amp; …\\<br>… &amp; … &amp; … &amp; …<br>\end{matrix}<br>\right)=\alpha\cdot \left(\begin{matrix}e_1\cdot S_1\cdot (1-S_1)\\ e_2\cdot S_2\cdot (1-S_2)\\ e_k\cdot S_k\cdot (1-S_k)\\ …\end{matrix}\right) \cdot (o_1,o_2,o_3,…)<br>$$<br>将Sig函数简化为输出：<br>$$<br>\vartriangle w_{j,k} = \alpha\times E_k \times O_k \times (1-O_k) \cdot O_j^T<br>$$</p><hr><p>到此，所有的前期工作都已完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何更新权重&quot;&gt;&lt;a href=&quot;#如何更新权重&quot; class=&quot;headerlink&quot; title=&quot;如何更新权重&quot;&gt;&lt;/a&gt;如何更新权重&lt;/h3&gt;&lt;p&gt;在上一篇文章中我们算出了各个层的误差，现在是时候利用这些误差来指导链接权重的修改了。那么该如何修改？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（1）</title>
    <link href="https://www.ccyh.xyz/2019/06/03/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/03/人工神经网络学习比记（1）/</id>
    <published>2019-06-03T15:16:03.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何让网络可以学习"><a href="#如何让网络可以学习" class="headerlink" title="如何让网络可以学习"></a>如何让网络可以学习</h3><p>上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况：<br><a id="more"></a></p><ul><li>老师：1+1=？</li><li>小明：6</li><li>老师：1+2=？</li><li>小明：2</li><li>…</li></ul><p>可以发现，当小明给出答案后老师并没有给于他反馈。因此小明可能某一次猜中了正确答案，但只是凑巧而已，他不具备学习能力。<br>现在让老师给点反馈：</p><ul><li>老师：1+5=？</li><li>小明：4</li><li>老师：少了</li><li>小明：5</li><li>老师：少了</li><li>小明：6</li><li>老师：正确，你真棒！</li></ul><p>这样子，小明学会了1+5=6.<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023656961.png" alt="三层神经网络"><br>我们的神经网络也需要具备这样的学习能力。<br>也就是说，当网络输出错误的结果时要有一个改变下一次输出的机制。想要改变输出，可以改变哪些量呢？<br>观察输出函数：<br>$$<br>O_{output}=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot i_{oj}}) \\<br>\end{matrix}<br>\right]=\left[\begin{matrix}o_1\\o_2\\o_3\end{matrix}\right]<br>$$<br>不难发现，输出值与以下参数有关：</p><ol><li>SigMoid函数</li><li>链接权重</li><li>输入值</li></ol><p>显然，我们不可能去左右网络的输入值，因为那是网络要求解的问题，不可能以改变问题的方式改变答案。那么改变激活函数sig如何？这太麻烦了，试想那么多的神经元每一个都不同的激活函数会对运算造成大麻烦，将无法采用简洁的矩阵运算。<br>因此，<strong>改变链接权重</strong>会是一个好办法。</p><hr><h3 id="学习能力的养成"><a href="#学习能力的养成" class="headerlink" title="学习能力的养成"></a>学习能力的养成</h3><p>我们已经知道可以通过改变链接权重来改变网络的输出值，使其符合预期。那么问题又来了：</p><ol><li>改变权重的依据是什么？</li><li>如何改变？</li><li>改变的幅度多大合适？</li></ol><hr><h4 id="改变的依据"><a href="#改变的依据" class="headerlink" title="改变的依据"></a>改变的依据</h4><p>改变权重的目的是让输出值与期望值越接近越好（误差值越小越好），因此误差就是依据。所谓误差就是期望值与网络输出值的差：<br>$$<br>E=t-o<br>$$<br>我们知道输出层的误差为：$E_o=t_n-o_n$，但是其他层结点的误差是不知道的，因为其他层并没有一个输出期望值$t_n$。<br>不难发现，最终输出层造成的误差是所有层共同作用的结果，所以可以将总误差分摊给其他层。</p><h5 id="误差的反向传播"><a href="#误差的反向传播" class="headerlink" title="误差的反向传播"></a>误差的反向传播</h5><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/20190603111024704.png" alt="单个神经元的误差分配"></p><hr><p>如上图误差为$e_1$，因为链接权重越大说明对该误差的影响越大，因此以链接权重来决定每条链路所分摊误差的大小：<br>$$<br>e_{w_{1,1}}=\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\cdot e_1<br>$$<br>$$<br>e_{w_{2,1}}=\frac{w_{2,1}}{w_{1,1}+w_{2,1}}\cdot e_1<br>$$<br><strong>反向传播误差到更多层中：</strong><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%AE%B0%EF%BC%881%EF%BC%89/20190603113735974.png" alt="误差的反向传播"><br>隐藏层结点的误差值：<br>$$<br>e_{h1}=\frac{w_{1,1}}{w_{1,1}+w_{2,1}}\cdot e_{o1}+\frac{w_{1,2}}{w_{1,2}+w_{2,2}}\cdot e_{o2}<br>$$</p><hr><h5 id="使用矩阵乘法简化误差反向传播"><a href="#使用矩阵乘法简化误差反向传播" class="headerlink" title="使用矩阵乘法简化误差反向传播"></a>使用矩阵乘法简化误差反向传播</h5><ol><li>误差向量：<br>$$<br>error_{output}=<br>\left(<br>\begin{matrix}<br>e_1 \\<br>e_2<br>\end{matrix}<br>\right)<br>$$</li><li>隐藏层误差：<br>$$<br>error_{hidden}=<br>\left(<br>\begin{matrix}<br>\frac{w_{1,1}}{w_{1,1}+w_{2,1}} &amp; \frac{w_{1,2}}{w_{1,2}+w_{2,2}} \\<br>\\<br>\frac{w_{2,1}}{w_{1,1}+w_{2,1}} &amp; \frac{w_{2,2}}{w_{1,2}+w_{2,2}}<br>\end{matrix}<br>\right) \cdot \left(\begin{matrix}e_1 \\ e_2 \end{matrix} \right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>上述矩阵乘法太过复杂，无法通过简单的矩阵运算求解。观察上式可知，最重要的事情是输出误差链接权重$w_{j,k}$的乘法。较大的权重携带较大的误差给隐藏层，这些分数的分母是一种归一化因子。如果我们忽略掉这个因子，我们仅仅只是失去了后馈误差的真实值大小，但并没有失去其表示的真正含义（影响力）,也就是说反馈误差始终是以链接权重的强度来分配的。因此上式可以简化为：<br>$$<br>error_{hidden}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{1,2} \\<br>w_{2,1} &amp; w_{2,2}<br>\end{matrix}<br>\right)\cdot \left(\begin{matrix}e_1\\ e_2\end{matrix}\right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>不难发现，隐藏层至输出层的链接权重矩阵$W_{hidden\rightarrow output}$为:<br>$$<br>W_{hidden\rightarrow output}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} \\<br>w_{1,2} &amp; w_{2,2}<br>\end{matrix}<br>\right)=\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{1,2} \\<br>w_{2,1} &amp; w_{2,2}<br>\end{matrix}<br>\right)^T<br>$$<br>因此：<br>$$<br>error_{hidden}=W_{hidden\rightarrow output}^T\cdot error_{output}=<br>\left(<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} \\<br>w_{1,2} &amp; w_{2,2}<br>\end{matrix}<br>\right)^T\cdot \left(\begin{matrix}e_1\\ e_2\end{matrix}\right)=\left(\begin{matrix}e_{h1}\\e_{h2}\end{matrix}\right)<br>$$<br>到此我们得到了用矩阵来传播误差的算法：<br>$$<br>error_{hidden}=W_{hidden\rightarrow output}^T\cdot error_{output}<br>$$</li></ol><hr><p>到此，我们已经做了大量的工作了。我们计算出了所有层的误差，接下来的工作就是根据误差来调整链接权重了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何让网络可以学习&quot;&gt;&lt;a href=&quot;#如何让网络可以学习&quot; class=&quot;headerlink&quot; title=&quot;如何让网络可以学习&quot;&gt;&lt;/a&gt;如何让网络可以学习&lt;/h3&gt;&lt;p&gt;上一篇文章中的神经网络还没有学习能力，这好比如说该网络只接收外部输入并输出结果，却没有反馈机制没有对结果进行正确性分析，让我们以小明与老师之间的对话来比喻这种情况：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络学习笔记（0）</title>
    <link href="https://www.ccyh.xyz/2019/06/03/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/"/>
    <id>https://www.ccyh.xyz/2019/06/03/人工神经网络学习笔记（0）/</id>
    <published>2019-06-03T14:25:33.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="何为人工神经网络"><a href="#何为人工神经网络" class="headerlink" title="何为人工神经网络"></a>何为人工神经网络</h2><p>人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。<br><a id="more"></a></p><h2 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2877951112,4239204535&amp;fm=26&amp;gp=0.jpg" alt=""><br><strong>关键部件：</strong> 树突 &amp; 胞体 &amp; 轴突</p><ul><li>单个神经元的工作机制可以简单地描述为：树突接受其他神经元的神经末梢传来的电信号，信号传送到胞体并由某种机制决定是否激发下一次电信号的传递，若激发则电信号由轴突传递至神经末梢，再由神经末梢传递给其他神经元。其中，判断是否激发的机制有一大好处是可以减小神经元间微弱电信号（噪声）的干扰，使得自由足够强的电信号才能激发下一次传递。</li></ul><h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1784596280,2741805283&amp;fm=26&amp;gp=0.jpg" alt="人工神经元"></p><ul><li>由生物神经元得到的启发，人工神经元与其大同小异。上图中： $x_1,x_2,x_3,x_4$ 为该神经元树突所接受到的其他神经元传来的电信号。中间的圆圈为胞体，在胞体中将会由处理信号的机制，以决定输出信号y。<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3></li><li>在之前的生物神经元中已经说道，神经元对是否激发信号传递有一个判断机制，这是因为神经元不希望传递微小的噪声信号，而只传递有意识的明显信号。只有信号强度达到了某一个阙值，才会激发电信号的传递。<br><strong>那么在人工神经元中我们如何来实现这个机制呢？</strong></li><li>这样的一个函数也许能够满足我们的需要：<br>$$Function(x) = \begin{cases}<br>0 &amp; x \leq T \\<br>1 &amp; x&gt;T<br>\end{cases}$$<br>显而易见，这个简单的阶跃函数在输入信号大于T（阙值）时才会产生输出信号1（被激发），而较小的输入时输出为0（被抑制）；我们称这样的函数为激活函数。当然，激活函数不会就只有这么一种。常用的还有sigmoid函数：<br>$$Sigmoid(x) = \frac{1}{1+e^{-x}}$$<br>函数图像：<br><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2160826125,3899173269&amp;fm=26&amp;gp=0.jpg" alt=""><br>可以发现，sigmoid函数相对于阶跃函数而言更加平滑，自然，接近现实。我们的神经网络也将采用它。<br>如此一来，我们的单个神经元模型就成型了：<br><img src="https://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/model.jpeg" alt="人工神经元模型"><br>参数含义：</li><li>$x_1 ,x_2… x_m$为输入信号</li><li>$w_1 ,w_2… w_m$为权重值，表示各个输入信号对输出结果的影响力大小。对于为何引入权值可以做如下思考：你去相亲，你对未来对象的考量主要有身高，长相，身材，文化程度等，但遇到样样都好的概率实在是太底了，所以你决定适当放宽某些要求。比如如果学历高就可以降低身材长相的要求。这表示你比较注重伴侣的文化程度。因此，对方的文化程度对你的择偶有着重要的影响，其所占权重就会比较高。</li><li>求和函数将计算$x=\sum_{m}{x_iw_i},i=1,2,…m$后将所得的值传给激活函数Sigmoid即：<br>$$Output=Sig(x)=\frac{1}{1+e^{-(\sum_{m}{x_iw_i})}}$$<br>观察函数图不难发现，Sigmoid函数将加权求和的输入映射到0~1的值域内输出。<h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=266571296,2744303426&amp;fm=26&amp;gp=0.jpg" alt=""><br>介绍完单个神经元的功能，如果把这些小部件组合起来，就成了所谓的人工神经网络。<br><strong>层次结构：</strong></li><li>输入层：接受外部输入信息，可以是图片等。</li><li>隐藏层：隐藏层层数不一，可根据需求来定。</li><li>输出层：将结果输出到外部。</li></ul><p><strong>链接方式：</strong></p><ul><li>除输入层外，每一层的每个神经元都接受其上一层所有神经元传来的信号的加权值。</li><li>神经元的链接方式并不唯一，你可以创造自己的链接方式，但为了便于抽象计算编码，规则的链接方式能帮我们大忙。</li></ul><h3 id="一个三层神经网络示例"><a href="#一个三层神经网络示例" class="headerlink" title="一个三层神经网络示例"></a>一个三层神经网络示例</h3><p><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023656961.png" alt=""></p><hr><p><strong>参数释义：</strong></p><ul><li>$i_1,i_2,i_3$为输入信号。</li><li>$w_{j,k}$表示后层结点$j$与前一层节点$k$之间链接的权重值。</li><li>$o_1,o_2,o_3$为该网络输出的结果信号。</li></ul><hr><p><strong>信号的前向传播：</strong><br>前面我们介绍了单个人工神经元对信号的处理。但是现在网络中有多个神经元，我们当然不愿意对每一个神经元节点都进行编码计算，因此我们将其简化为矩阵运算。<br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89/20190603023612835.png" alt=""></p><ol><li>将输入看成一个多维列向量：<br>$$<br>I=<br>\left[<br>\begin{matrix}<br>i_1 \\<br>i_2 \\<br>i_3<br>\end{matrix} \right]<br>$$</li><li>链接权重为一个$3\times3$的矩阵：<br>$$<br>W_{input\rightarrow hidden}=<br>\left[<br>\begin{matrix}<br>w_{1,1} &amp; w_{2,1} &amp; w_{3,1} \\<br>w_{1,2} &amp; w_{2,2} &amp; w_{3,2} \\<br>w_{1,3} &amp; w_{2,3} &amp; w_{3,3}<br>\end{matrix} \right]<br>$$</li><li>将两者相乘得到隐藏层的输入信号：<br>$$<br>I_{hidden}=W_{input\rightarrow hidden}\cdot I=<br>\left[<br>\begin{matrix}<br>w_{1,1}\cdot i_1 + w_{2,1}\cdot i_2 + w_{3,1}\cdot i_3 \\<br>w_{1,2}\cdot i_1 + w_{2,2}\cdot i_2 + w_{3,2}\cdot i_3 \\<br>w_{1,3}\cdot i_1 + w_{2,3}\cdot i_2 + w_{3,3}\cdot i_3<br>\end{matrix} \right]<br>$$<br>也即：<br>$$<br>I_{hidden}=<br>\left[<br>\begin{matrix}<br>\sum_{j=1}^{3}{w_{j,1}\cdot i_j} \\<br>\sum_{j=1}^{3}{w_{j,2}\cdot i_j} \\<br>\sum_{j=1}^{3}{w_{j,3}\cdot i_j}<br>\end{matrix}\right]=[i_{h1},i_{h2},i_{h3}]^T<br>$$</li><li>再将加权求和的信号值经过Sigmoid激活函数处理我们可以得到最终的输出向量：<br>$$<br>O_{hidden}=Sig(W_{hidden\rightarrow output}\cdot I_{hidden})=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot o_{hj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot o_{hj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot o_{hj}}) \\<br>\end{matrix}<br>\right]=[o_{h1},o_{h2},o_{h3}]^T<br>$$<br>这里需要注意的是，输入层到隐藏层的链接权重矩阵与隐藏层到输出成的链接权重矩阵是不同的矩阵。但是计算过程是一致的，因此同理可得：<br>$$<br>I_{output}=Sig(W_{hidden\rightarrow output}\cdot O_{hidden})<br>$$<br>网络的最终输出为：<br>$$<br>O_{output}=<br>\left[<br>\begin{matrix}<br>Sig(\sum_{j=1}^{3}{w_{j,1}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,2}\cdot i_{oj}}) \\<br>Sig(\sum_{j=1}^{3}{w_{j,3}\cdot i_{oj}}) \\<br>\end{matrix}<br>\right]=[o_1,o_2,o_3]^T<br>$$<br>到此，我们已经了解了神经网络中信号的前向传播机制，但是目前这个网络模型远远达不到我们的要求，它除了单纯的传播信号什么事情也做不了。显然后续我们得为其添加反馈机制，使其能够具有学习能力。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;何为人工神经网络&quot;&gt;&lt;a href=&quot;#何为人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;何为人工神经网络&quot;&gt;&lt;/a&gt;何为人工神经网络&lt;/h2&gt;&lt;p&gt;人工神经网络是模拟人脑的神经网络，用以实现人工智能的机器学习技术。我们知道，人脑可以说是世界上最复杂最精妙的系统之一，它由千亿计的神经元细胞组成。各个神经细胞相互链接，彼此之间传递电信号。从而造就了人类高于其他物种的思维能力。科学家受到人脑神经元的启发从而提出了人工神经网络的设想，使得人工智能的实现不再遥不可及。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>感知机与逻辑门的实现</title>
    <link href="https://www.ccyh.xyz/2019/06/01/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.ccyh.xyz/2019/06/01/感知机与逻辑门的实现/</id>
    <published>2019-06-01T14:49:16.000Z</published>
    <updated>2020-02-29T06:06:38.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><hr><p>&emsp;感知机（Perceptron）由两层神经元组成，输入层接收外界信号后传递给输出层，输出层是M-P神经元（如下图），亦称<strong>” 阙值逻辑单元（threshold logic unit）“</strong>。</p><a id="more"></a><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20190624050228397.png" alt="M-P神经元简图"><br></center><h1 id="逻辑门的实现"><a href="#逻辑门的实现" class="headerlink" title="逻辑门的实现"></a>逻辑门的实现</h1><hr><p>&emsp;感知机能容易地实现逻辑与、或、非、异或运算。注意到$y=f(\sum_{i}{w_ix_i-\theta})$,假定$f$为阶跃函数:<br>$$<br>sgn(x) = \begin{cases}<br>1, &amp; x&gt;= 0 \\<br>0, &amp; x&lt;0<br>\end{cases}<br>$$<br>则有：</p><ul><li>与门（$ x_1\land x_2 $）：令$w_1=w_2=1,\theta=1.5$,则$y=f(1\cdot x_1+1\cdot x_2-2)$,仅当$x_1=x_2=1$时，$y=1$</li></ul><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python实现与门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AND</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    </span><br><span class="line">    w1,w2,theta = <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>或门（$x_1\lor x_2$）：令$w_1=w_2=1,\theta=0.5$,则$y=f(1\cdot x_1+1\cdot x_2-0.5)$,仅当$x_1=1$或$x_2=1$时，$y=1$。</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python实现或门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OR</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    w1,w2,theta = <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>非门（$\lnot x_1$）：令$w_1=-0.6$,$w_2=0,\theta=-0.5$,则$y=f(-0.6\cdot x_1+0\cdot x_2+0.5)$,仅当$x_1=1$时，$y=0$；当$x_1=0$时，$y=1$。</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现非门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NOT</span><span class="hljs-params">(x1)</span>:</span></span><br><span class="line">    w1, theta = <span class="hljs-number">-0.6</span>, <span class="hljs-number">-0.5</span></span><br><span class="line">    result = w1*x1 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>与非门：令$w_1=w_2=-1,\theta=-1.5$,则$y=f(1\cdot x_1+1\cdot x_2+1.5)$,仅当$x_1=x_2=1$时，$y=0$</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现与非门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NAND</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    w1,w2,theta = <span class="hljs-number">-1.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">-1.5</span></span><br><span class="line">    result = w1*x1 + w2*x2 - theta</span><br><span class="line">    <span class="hljs-keyword">if</span> result &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure></li><li><p>异或门（$x_1\oplus x_2$）：异或门在生活中有很多用处，我们常常听到下面这句话：“这件事要么你来做，要么我来做”。意思是这件事只能由我们之间的任何一个人来做，其他都不行。又比如你房间中的灯的开关一般门口一个床头一个，这样子你每按下其中任何一个开关都只会有两种结果（变得与另一个一样，变得与另一个不一样）利用这两种结果就可以构成灯的开与关。</p></li></ul><center><br><img src="http://hexoblog-1257022783.cos.ap-chengdu.myqcloud.com/%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20190624055322320.png" alt=""><br></center><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># python 实现异或门</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ExOR</span><span class="hljs-params">(x1,x2)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> AND(OR(x1,x2),NAND(x1,x2))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;感知机&quot;&gt;&lt;a href=&quot;#感知机&quot; class=&quot;headerlink&quot; title=&quot;感知机&quot;&gt;&lt;/a&gt;感知机&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;感知机（Perceptron）由两层神经元组成，输入层接收外界信号后传递给输出层，输出层是M-P神经元（如下图），亦称&lt;strong&gt;” 阙值逻辑单元（threshold logic unit）“&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.ccyh.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://www.ccyh.xyz/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-icarus修改文章详情页</title>
    <link href="https://www.ccyh.xyz/2019/05/01/Hexo-icarus%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E9%A1%B5/"/>
    <id>https://www.ccyh.xyz/2019/05/01/Hexo-icarus修改文章详情页/</id>
    <published>2019-05-01T18:46:04.000Z</published>
    <updated>2020-02-29T06:06:38.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么修改？"><a href="#为什么修改？" class="headerlink" title="为什么修改？"></a>为什么修改？</h2><a id="more"></a><p>由于Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局。但是三栏布局限制了文章内容的展示，因此试图将其改为两栏布局。</p><hr><h2 id="通过修改源代码来达成目标"><a href="#通过修改源代码来达成目标" class="headerlink" title="通过修改源代码来达成目标"></a>通过修改源代码来达成目标</h2><p>打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">col</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!is_post())&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> main_column_class();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'is-6-tablet is-6-desktop is-9-widescreen'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>再section标签中做如下改动：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"section"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"columns"</span>&gt;</span></span><br><span class="line">                <span class="hljs-comment">&lt;!-- 将main_column_class() 改为 col() --&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column &lt;%= col() %&gt; has-order-2 column-main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">body</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">left</span>' &#125;) %&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">partial</span>('<span class="hljs-attr">common</span>/<span class="hljs-attr">widget</span>', &#123; <span class="hljs-attr">position:</span> '<span class="hljs-attr">right</span>' &#125;) %&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。<br>通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。</p><p>为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。<br>将代码全选复制，再粘贴于末尾，做如下修改3处代码：<br><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="hljs-keyword">if</span> (get_widgets(position).length &amp;&amp; !is_post()) &#123; %&gt;        <span class="hljs-xml"><span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-1' : 'has-order-3';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!-- 粘贴的部分 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">position</span> === <span class="hljs-string">'left'</span> &amp;&amp; <span class="hljs-attr">is_post</span>()) &#123; %&gt;</span>                          <span class="hljs-comment">&lt;!-- 修改，可选保留的栏 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">side_column_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    switch (column_count()) &#123;</span></span><br><span class="line"><span class="hljs-xml">        case 2:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-4-widescreen';</span></span><br><span class="line"><span class="hljs-xml">        case 3:</span></span><br><span class="line"><span class="hljs-xml">            return 'is-4-tablet is-4-desktop is-3-widescreen';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">visibility_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    if (column_count() === 3 &amp;&amp; position === 'right') &#123;</span></span><br><span class="line"><span class="hljs-xml">        return 'is-hidden-touch is-hidden-desktop-only';</span></span><br><span class="line"><span class="hljs-xml">    &#125;</span></span><br><span class="line"><span class="hljs-xml">    return '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">order_class</span>() &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return position === 'left' ? 'has-order-3' : 'has-order-1';       <span class="hljs-comment">&lt;!-- 修改 --&gt;</span></span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">function</span> <span class="hljs-attr">sticky_class</span>(<span class="hljs-attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="hljs-xml">    return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';</span></span><br><span class="line"><span class="hljs-xml">&#125; %&gt;</span></span><br><span class="line">&lt;div class="column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;"&gt;</span><br><span class="line">    &lt;% get_widgets(position).forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">        &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% if (position === 'left') &#123; %&gt;</span><br><span class="line">        &lt;div class="column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;"&gt;</span><br><span class="line">        &lt;% get_widgets('right').forEach(widget =&gt; &#123;%&gt;</span><br><span class="line">            &lt;%- partial('widget/' + widget.type, &#123; widget, post: page &#125;) %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure></p><hr><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>我这里保存的是左边栏，若要保存右边栏可以在 widget.ejs 文件中更改（已标识）。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>见本站！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么修改？&quot;&gt;&lt;a href=&quot;#为什么修改？&quot; class=&quot;headerlink&quot; title=&quot;为什么修改？&quot;&gt;&lt;/a&gt;为什么修改？&lt;/h2&gt;
    
    </summary>
    
      <category term="教程" scheme="https://www.ccyh.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://www.ccyh.xyz/tags/Hexo/"/>
    
  </entry>
  
</feed>
